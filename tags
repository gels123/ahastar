!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
AAStarUtil	aha/AnnotatedAStar.h	/^namespace AAStarUtil {      $/;"	n
ABSNode	shared/aStar.h	/^	inline node *ABSNode(node *n) { return abstr->getNthParent(n, absLevel); }$/;"	f	class:aStar
ABSTRACTIONSEARCHENVIRONMENT_H	abstraction/AbstractionSearchEnvironment.h	/^#define ABSTRACTIONSEARCHENVIRONMENT_H$/;"	d
ABSTRACTION_OBJ	Makefile	/^ABSTRACTION_OBJ = $(ABSTRACTION_SRC:.cpp=.o)$/;"	m
ABSTRACTION_SRC	Makefile	/^ABSTRACTION_SRC = $(notdir $(wildcard abstraction\/*.cpp))$/;"	m
ABSTRACTION_SRC	apps/apps.mk	/^ABSTRACTION_SRC = $(wildcard ..\/abstraction\/*.cpp)$/;"	m
ACAUtil	aha/AnnotatedClusterAbstraction.h	/^namespace ACAUtil$/;"	n
AHACONSTANTS_H	aha/AHAConstants.h	/^#define AHACONSTANTS_H$/;"	d
AHAExperiment	aha/ScenarioManager.h	/^		AHAExperiment(int xs, int ys, int xg, int yg, int capability, int agentsize, float dist, string mapname) :$/;"	f	class:AHAExperiment
AHAExperiment	aha/ScenarioManager.h	/^class AHAExperiment : public Experiment$/;"	c
AHASCENARIOMANAGERMOCK_H	tests/AHAScenarioManagerMock.h	/^#define AHASCENARIOMANAGERMOCK_H$/;"	d
AHASTARTESTS_OBJ	Makefile	/^AHASTARTESTS_OBJ = $(AHASTAR_SRC:.cpp=.o)$/;"	m
AHASTARTESTS_SRC	Makefile	/^AHASTARTESTS_SRC = $(notdir $(wildcard tests\/*.cpp))$/;"	m
AHASTAR_OBJ	Makefile	/^AHASTAR_OBJ = $(AHASTAR_SRC:.cpp=.o)$/;"	m
AHASTAR_SRC	Makefile	/^AHASTAR_SRC = $(notdir $(wildcard aha\/*.cpp))$/;"	m
AHASTAR_SRC	apps/apps.mk	/^AHASTAR_SRC = $(wildcard ..\/aha\/*.cpp)$/;"	m
AHAScenarioManager	aha/ScenarioManager.h	/^		AHAScenarioManager() {};$/;"	f	class:AHAScenarioManager
AHAScenarioManager	aha/ScenarioManager.h	/^class AHAScenarioManager: public AbstractScenarioManager$/;"	c
AHAScenarioManagerMock	tests/AHAScenarioManagerMock.h	/^class AHAScenarioManagerMock : AbstractScenarioManager$/;"	c
ANNOTATEDASTARMOCK_H	tests/AnnotatedAStarMock.h	/^#define ANNOTATEDASTARMOCK_H$/;"	d
ANNOTATEDASTARTEST_H	tests/AnnotatedAStarTest.h	/^#define ANNOTATEDASTARTEST_H$/;"	d
ANNOTATEDASTAR_H	aha/AnnotatedAStar.h	/^#define ANNOTATEDASTAR_H$/;"	d
ANNOTATEDCLUSTERABSTRACTIONMOCK_H	tests/AnnotatedClusterAbstractionMock.h	/^#define ANNOTATEDCLUSTERABSTRACTIONMOCK_H$/;"	d
ANNOTATEDCLUSTERABSTRACTIONTEST_H	tests/AnnotatedClusterAbstractionTest.h	/^#define ANNOTATEDCLUSTERABSTRACTIONTEST_H$/;"	d
ANNOTATEDCLUSTERABSTRACTION_H	aha/AnnotatedClusterAbstraction.h	/^#define ANNOTATEDCLUSTERABSTRACTION_H$/;"	d
ANNOTATEDCLUSTERFACTORYTEST_H	tests/AnnotatedClusterFactoryTest.h	/^#define ANNOTATEDCLUSTERFACTORYTEST_H$/;"	d
ANNOTATEDCLUSTERFACTORY_H	aha/AnnotatedClusterFactory.h	/^#define ANNOTATEDCLUSTERFACTORY_H$/;"	d
ANNOTATEDCLUSTERMOCKFACTORY_H	tests/AnnotatedClusterMockFactory.h	/^#define ANNOTATEDCLUSTERMOCKFACTORY_H$/;"	d
ANNOTATEDCLUSTERMOCK_H	tests/AnnotatedClusterMock.h	/^#define ANNOTATEDCLUSTERMOCK_H$/;"	d
ANNOTATEDCLUSTERTEST_H	tests/AnnotatedClusterTest.h	/^#define ANNOTATEDCLUSTERTEST_H$/;"	d
ANNOTATEDCLUSTER_H	aha/AnnotatedCluster.h	/^#define ANNOTATEDCLUSTER_H$/;"	d
ANNOTATEDHIERARCHICALASTARTEST_H	tests/AnnotatedHierarchicalAStarTest.h	/^#define ANNOTATEDHIERARCHICALASTARTEST_H$/;"	d
ANNOTATEDHIERARCHICALASTAR_H	aha/AnnotatedHierarchicalAStar.h	/^#define ANNOTATEDHIERARCHICALASTAR_H$/;"	d
ANNOTATEDMAPABSTRACTIONMOCK_H	tests/AnnotatedMapAbstractionMock.h	/^#define ANNOTATEDMAPABSTRACTIONMOCK_H$/;"	d
ANNOTATEDMAPABSTRACTIONTEST_H	tests/AnnotatedMapAbstractionTest.h	/^#define ANNOTATEDMAPABSTRACTIONTEST_H$/;"	d
ANNOTATEDMAPABSTRACTION_H	aha/AnnotatedMapAbstraction.h	/^#define ANNOTATEDMAPABSTRACTION_H$/;"	d
APPS	apps/Makefile	/^APPS := $(filter-out %~ CVS Makefile %.mk libs,$(wildcard *))$/;"	m
ASTAR2_H	shared/aStar2.h	/^#define ASTAR2_H$/;"	d
ASTAR3_H	shared/aStar.h	/^#define ASTAR3_H$/;"	d
ASTAROld_H	shared/aStar3.h	/^#define ASTAROld_H$/;"	d
AStar3Util	shared/aStar.h	/^namespace AStar3Util$/;"	n
AbstractAnnotatedAStar	aha/AnnotatedAStar.h	/^		AbstractAnnotatedAStar(int _capability, int _clearance) : useCorridor(false), capability(_capability), clearance(_clearance) { capability=0; clearance=0; }$/;"	f	class:AbstractAnnotatedAStar
AbstractAnnotatedAStar	aha/AnnotatedAStar.h	/^class AbstractAnnotatedAStar : public aStarOld$/;"	c
AbstractAnnotatedMapAbstraction	aha/AnnotatedMapAbstraction.cpp	/^AbstractAnnotatedMapAbstraction::AbstractAnnotatedMapAbstraction(Map* m, AbstractAnnotatedAStar* alg) : mapAbstraction(m)$/;"	f	class:AbstractAnnotatedMapAbstraction
AbstractAnnotatedMapAbstraction	aha/AnnotatedMapAbstraction.h	/^class AbstractAnnotatedMapAbstraction : public mapAbstraction$/;"	c
AbstractScenarioManager	aha/ScenarioManager.h	/^		AbstractScenarioManager(){};$/;"	f	class:AbstractScenarioManager
AbstractScenarioManager	aha/ScenarioManager.h	/^class AbstractScenarioManager $/;"	c
AbstractionSearchEnvironment	abstraction/AbstractionSearchEnvironment.h	/^	AbstractionSearchEnvironment(graphAbstraction *_ga, int _level)$/;"	f	class:AbstractionSearchEnvironment
AbstractionSearchEnvironment	abstraction/AbstractionSearchEnvironment.h	/^class AbstractionSearchEnvironment : public SearchEnvironment$/;"	c
AnnotatedAStar	aha/AnnotatedAStar.h	/^		AnnotatedAStar(int _capability=0, int _clearance=0) : AbstractAnnotatedAStar(_capability, _clearance) { e = NULL; }$/;"	f	class:AnnotatedAStar
AnnotatedAStar	aha/AnnotatedAStar.h	/^class AnnotatedAStar : public AbstractAnnotatedAStar$/;"	c
AnnotatedAStarMock	tests/AnnotatedAStarMock.h	/^		AnnotatedAStarMock(int capability=0, int clearance=0) : AbstractAnnotatedAStar(capability, clearance) { curexp = NULL; }$/;"	f	class:AnnotatedAStarMock
AnnotatedAStarMock	tests/AnnotatedAStarMock.h	/^class AnnotatedAStarMock : public AbstractAnnotatedAStar$/;"	c
AnnotatedAStarTest	tests/AnnotatedAStarTest.cpp	/^CPPUNIT_TEST_SUITE_REGISTRATION( AnnotatedAStarTest );$/;"	v
AnnotatedAStarTest	tests/AnnotatedAStarTest.h	/^class AnnotatedAStarTest : public CPPUNIT_NS::TestFixture$/;"	c
AnnotatedCluster	aha/AnnotatedCluster.cpp	/^AnnotatedCluster::AnnotatedCluster(int startx, int starty, int width, int height) throw(InvalidClusterDimensionsException, InvalidClusterOriginCoordinatesException)$/;"	f	class:AnnotatedCluster
AnnotatedCluster	aha/AnnotatedCluster.h	/^class AnnotatedCluster : public Cluster$/;"	c
AnnotatedClusterAbstraction	aha/AnnotatedClusterAbstraction.cpp	/^AnnotatedClusterAbstraction::AnnotatedClusterAbstraction(Map* m, AbstractAnnotatedAStar* searchalg, int clustersize, ACAUtil::GraphQualityParameter qual)$/;"	f	class:AnnotatedClusterAbstraction
AnnotatedClusterAbstraction	aha/AnnotatedClusterAbstraction.h	/^class AnnotatedClusterAbstraction : public AnnotatedMapAbstraction$/;"	c
AnnotatedClusterAbstractionIsNullException	aha/AnnotatedCluster.h	/^class AnnotatedClusterAbstractionIsNullException : public std::exception$/;"	c
AnnotatedClusterAbstractionMock	tests/AnnotatedClusterAbstractionMock.h	/^		AnnotatedClusterAbstractionMock(Map* m, AbstractAnnotatedAStar* aastar, int clustersize, ACAUtil::GraphQualityParameter qual=ACAUtil::kHighQualityAbstraction)$/;"	f	class:AnnotatedClusterAbstractionMock
AnnotatedClusterAbstractionMock	tests/AnnotatedClusterAbstractionMock.h	/^class AnnotatedClusterAbstractionMock :  public AnnotatedClusterAbstraction, public MOCKPP_NS::ChainableMockObject$/;"	c
AnnotatedClusterAbstractionTest	tests/AnnotatedClusterAbstractionTest.cpp	/^CPPUNIT_TEST_SUITE_REGISTRATION( AnnotatedClusterAbstractionTest );$/;"	v
AnnotatedClusterAbstractionTest	tests/AnnotatedClusterAbstractionTest.h	/^class AnnotatedClusterAbstractionTest : public CPPUNIT_NS::TestFixture$/;"	c
AnnotatedClusterException	aha/AnnotatedCluster.h	/^		AnnotatedClusterException(node* problemNode, AnnotatedCluster* ac)  { this->problemNode = problemNode; this->ac = ac;}$/;"	f	class:AnnotatedClusterException
AnnotatedClusterException	aha/AnnotatedCluster.h	/^class AnnotatedClusterException : public std::exception$/;"	c
AnnotatedClusterFactory	aha/AnnotatedClusterFactory.h	/^class AnnotatedClusterFactory : public IAnnotatedClusterFactory$/;"	c
AnnotatedClusterFactoryTest	tests/AnnotatedClusterFactoryTest.cpp	/^CPPUNIT_TEST_SUITE_REGISTRATION( AnnotatedClusterFactoryTest );$/;"	v
AnnotatedClusterFactoryTest	tests/AnnotatedClusterFactoryTest.h	/^class AnnotatedClusterFactoryTest : public CPPUNIT_NS::TestFixture$/;"	c
AnnotatedClusterMock	tests/AnnotatedClusterMock.h	/^		AnnotatedClusterMock(int startx, int starty, int width, int height) $/;"	f	class:AnnotatedClusterMock
AnnotatedClusterMock	tests/AnnotatedClusterMock.h	/^class AnnotatedClusterMock : public AnnotatedCluster, public MOCKPP_NS::ChainableMockObject$/;"	c
AnnotatedClusterMockFactory	tests/AnnotatedClusterMockFactory.h	/^		AnnotatedClusterMockFactory(AnnotatedClusterAbstractionTest* testharness) : myharness(testharness) { currentTest = 0; }$/;"	f	class:AnnotatedClusterMockFactory
AnnotatedClusterMockFactory	tests/AnnotatedClusterMockFactory.h	/^class AnnotatedClusterMockFactory : public IAnnotatedClusterFactory$/;"	c
AnnotatedClusterTest	tests/AnnotatedClusterTest.cpp	/^CPPUNIT_TEST_SUITE_REGISTRATION( AnnotatedClusterTest );$/;"	v
AnnotatedClusterTest	tests/AnnotatedClusterTest.h	/^class AnnotatedClusterTest : public CPPUNIT_NS::TestFixture$/;"	c
AnnotatedHierarchicalAStar	aha/AnnotatedHierarchicalAStar.h	/^class AnnotatedHierarchicalAStar : public AnnotatedAStar$/;"	c
AnnotatedHierarchicalAStarTest	tests/AnnotatedHierarchicalAStarTest.cpp	/^CPPUNIT_TEST_SUITE_REGISTRATION( AnnotatedHierarchicalAStarTest );$/;"	v
AnnotatedHierarchicalAStarTest	tests/AnnotatedHierarchicalAStarTest.h	/^class AnnotatedHierarchicalAStarTest : public CPPUNIT_NS::TestFixture$/;"	c
AnnotatedMapAbstraction	aha/AnnotatedMapAbstraction.cpp	/^AnnotatedMapAbstraction::AnnotatedMapAbstraction(Map* m, AbstractAnnotatedAStar* searchalg) : AbstractAnnotatedMapAbstraction(m, searchalg) $/;"	f	class:AnnotatedMapAbstraction
AnnotatedMapAbstraction	aha/AnnotatedMapAbstraction.h	/^class AnnotatedMapAbstraction : public AbstractAnnotatedMapAbstraction$/;"	c
AnnotatedMapAbstractionMock	tests/AnnotatedMapAbstractionMock.h	/^		AnnotatedMapAbstractionMock(Map* m, AbstractAnnotatedAStar* searchalg) : AbstractAnnotatedMapAbstraction(m, searchalg) { annotateMap(); }$/;"	f	class:AnnotatedMapAbstractionMock
AnnotatedMapAbstractionMock	tests/AnnotatedMapAbstractionMock.h	/^class AnnotatedMapAbstractionMock : public AbstractAnnotatedMapAbstraction$/;"	c
AnnotatedMapAbstractionTest	tests/AnnotatedMapAbstractionTest.cpp	/^CPPUNIT_TEST_SUITE_REGISTRATION( AnnotatedMapAbstractionTest );$/;"	v
AnnotatedMapAbstractionTest	tests/AnnotatedMapAbstractionTest.h	/^class AnnotatedMapAbstractionTest: public CPPUNIT_NS::TestFixture$/;"	c
BEGIN	shared/craStar.h	/^		BEGIN,$/;"	e	enum:craStar::__anon17
BEGIN	shared/hpaStar.h	/^		BEGIN,$/;"	e	enum:hpaStar::__anon19
BIBTEX	papers/Makefile	/^BIBTEX=bibtex$/;"	m
CAPABILITYUNIT_H	aha/CapabilityUnit.h	/^#define CAPABILITYUNIT_H$/;"	d
CAPABILITYUNIT_H	tests/CapabilityUnitTest.h	/^#define CAPABILITYUNIT_H$/;"	d
CC	Makefile	/^CC = c++$/;"	m
CC	apps/apps.mk	/^CC = g++$/;"	m
CFLAGS	Makefile	/^CFLAGS = -Wall -O3 -g -I.\/aha -I.\/abstraction -I.\/driver -I.\/shared -I.\/simulation -I.\/util $/;"	m
CFLAGS	apps/apps.mk	/^CFLAGS = -Wall -O3 -g -I ..\/aha -I..\/abstraction -I..\/driver -I..\/shared -I..\/simulation -I..\/util$/;"	m
CGPoint	driver/main.h	/^struct CGPoint {$/;"	s
CGPoint	driver/main.h	/^typedef struct CGPoint CGPoint;$/;"	t	typeref:struct:CGPoint
CGRect	driver/main.h	/^struct CGRect {$/;"	s
CGRect	driver/main.h	/^typedef struct CGRect CGRect;$/;"	t	typeref:struct:CGRect
CGSize	driver/main.h	/^struct CGSize {$/;"	s
CGSize	driver/main.h	/^typedef struct CGSize CGSize;$/;"	t	typeref:struct:CGSize
CLC	driver/common.h	/^	commandLineCallback CLC;$/;"	m	class:commandLineCallbackData
CLUSTERABSTRACTION_H	abstraction/clusterAbstraction.h	/^#define CLUSTERABSTRACTION_H$/;"	d
CLUSTERSIZE	apps/sample/sample.cpp	/^int CLUSTERSIZE=10;$/;"	v
COMMON_H	driver/common.h	/^#define COMMON_H$/;"	d
CONSTANTS_H	simulation/constants.h	/^#define CONSTANTS_H$/;"	d
CORRIDORASTAR_H	shared/corridorAStar.h	/^#define CORRIDORASTAR_H$/;"	d
CRASTAR_H	shared/craStar.h	/^#define CRASTAR_H$/;"	d
CannotBuildEntranceFromAbstractNodeException	aha/AnnotatedCluster.h	/^class CannotBuildEntranceFromAbstractNodeException : public std::exception$/;"	c
CannotBuildEntranceToSelfException	aha/AnnotatedCluster.cpp	/^CannotBuildEntranceToSelfException::CannotBuildEntranceToSelfException(node* n1, node* n2) : EntranceException(n1, n2)$/;"	f	class:CannotBuildEntranceToSelfException
CannotBuildEntranceToSelfException	aha/AnnotatedCluster.h	/^class CannotBuildEntranceToSelfException : public EntranceException$/;"	c
CapabilityUnit	aha/CapabilityUnit.h	/^		CapabilityUnit(int _x, int _y, float _r, float _g, float _b, unit *_target, AbstractAnnotatedAStar *alg) : searchUnit(_x,_y,_r,_g,_b,_target,alg) { }$/;"	f	class:CapabilityUnit
CapabilityUnit	aha/CapabilityUnit.h	/^		CapabilityUnit(int _x, int _y, int _r, int _g, int _b, unit *_target, AbstractAnnotatedAStar *alg) : searchUnit(_x,_y,_r,_g,_b,_target,alg) { }$/;"	f	class:CapabilityUnit
CapabilityUnit	aha/CapabilityUnit.h	/^		CapabilityUnit(int x, int y, unit *target, AbstractAnnotatedAStar *alg) : searchUnit(x,y,target,alg) { }$/;"	f	class:CapabilityUnit
CapabilityUnit	aha/CapabilityUnit.h	/^class CapabilityUnit : public searchUnit $/;"	c
CapabilityUnitTest	tests/CapabilityUnitTest.h	/^class CapabilityUnitTest : CPPUNIT_NS::TestFixture$/;"	c
CheckOpenGLCaps	driver/MAC/macGlCheck.cpp	/^void CheckOpenGLCaps (CGDisplayCount maxDspys, $/;"	f
CleanString	driver/MAC/HID Support/HID_Utilities.cpp	/^static void CleanString (char * targetString)$/;"	f	file:
Cluster	abstraction/clusterAbstraction.h	/^  Cluster(int id, int row, int col, int horizOrigin, int vertOrigin,int width, int height)$/;"	f	class:Cluster
Cluster	abstraction/clusterAbstraction.h	/^class Cluster {$/;"	c
ClusterFullException	aha/AnnotatedCluster.h	/^		ClusterFullException(node* problemNode, AnnotatedCluster* ac) : AnnotatedClusterException(problemNode, ac) {  }$/;"	f	class:ClusterFullException
ClusterFullException	aha/AnnotatedCluster.h	/^class ClusterFullException : public AnnotatedClusterException$/;"	c
ClusterSearchEnvironment	abstraction/clusterAbstraction.cpp	/^	ClusterSearchEnvironment(graphAbstraction *_aMap, int _level)$/;"	f	class:ClusterSearchEnvironment
ClusterSearchEnvironment	abstraction/clusterAbstraction.cpp	/^class ClusterSearchEnvironment : public SearchEnvironment$/;"	c	file:
Complex	tests/ComplexNumberTest.h	/^  Complex( double r, double i = 0 ) $/;"	f	class:Complex
Complex	tests/ComplexNumberTest.h	/^class Complex { $/;"	c
ComplexNumberTest	tests/ComplexNumberTest.h	/^CPPUNIT_TEST_SUITE_REGISTRATION (ComplexNumberTest);$/;"	v
ComplexNumberTest	tests/ComplexNumberTest.h	/^class ComplexNumberTest : public CppUnit::TestFixture  {$/;"	c
CompositeGLBufferIntoFile	driver/MAC/mac_main.cpp	/^void CompositeGLBufferIntoFile(AGLContext ctx, Rect *bufferRect, const FSSpec *fileSpec)$/;"	f
CompositeGLBufferIntoWindow	driver/MAC/mac_main.cpp	/^void CompositeGLBufferIntoWindow(AGLContext ctx, Rect *bufferRect, WindowRef win)$/;"	f
Corridor	shared/aStar.h	/^		AStar3Util::NodeHash, AStar3Util::NodeEqual > Corridor;$/;"	t	namespace:AStar3Util
Corridor	util/GenericAStar.h	/^	typedef __gnu_cxx::hash_map<uint32_t, bool > Corridor;$/;"	t	namespace:GenericAStarUtil
CycleCounter	util/timer.h	/^	CycleCounter() { stamp(); }$/;"	f	struct:Timer::CycleCounter
CycleCounter	util/timer.h	/^struct CycleCounter {$/;"	s	class:Timer
DAT	apps/Makefile	/^DAT = $(@)$/;"	m
DEFAULT_SIZE	util/heap.h	/^#define DEFAULT_SIZE /;"	d
DLR	apps/Makefile	/^DLR = \$$/;"	m
DRIVER_OBJ	Makefile	/^DRIVER_OBJ = $(DRIVER_SRC:.cpp=.o)$/;"	m
DRIVER_SRC	Makefile	/^DRIVER_SRC = $(notdir $(wildcard driver\/*.cpp))$/;"	m
DRIVER_SRC	apps/apps.mk	/^DRIVER_SRC = $(wildcard ..\/driver\/*.cpp)$/;"	m
DVIPS	papers/Makefile	/^DVIPS=dvips$/;"	m
DVIPS_OPTS	papers/Makefile	/^DVIPS_OPTS=-Ppdf -t letter$/;"	m
Direction	shared/craStar.h	/^		NW} Direction;$/;"	t	class:craStar	typeref:enum:craStar::__anon16
Direction	shared/hpaStar.h	/^		NW} Direction;$/;"	t	class:hpaStar	typeref:enum:hpaStar::__anon18
EAST	shared/craStar.h	/^		EAST,$/;"	e	enum:craStar::__anon16
EAST	shared/hpaStar.h	/^		EAST,$/;"	e	enum:hpaStar::__anon18
EDGETEST_H	tests/EdgeTest.h	/^#define EDGETEST_H$/;"	d
EDGEWIDTH_H	abstraction/edgewidth.h	/^#define EDGEWIDTH_H$/;"	d
END	shared/craStar.h	/^		END,$/;"	e	enum:craStar::__anon17
END	shared/hpaStar.h	/^		END,$/;"	e	enum:hpaStar::__anon19
EXPERIMENTMANAGER_H	tests/ExperimentManager.h	/^#define EXPERIMENTMANAGER_H$/;"	d
EdgeEqual	abstraction/clusterAbstraction.h	/^	struct EdgeEqual {$/;"	s	namespace:clusterUtil
EdgeHash	abstraction/clusterAbstraction.h	/^	struct EdgeHash {$/;"	s	namespace:clusterUtil
EdgeTest	tests/EdgeTest.cpp	/^CPPUNIT_TEST_SUITE_REGISTRATION( EdgeTest );$/;"	v
EdgeTest	tests/EdgeTest.h	/^class EdgeTest : public CPPUNIT_NS::TestFixture$/;"	c
EndHIDInput	driver/MAC/HID Support/HIDSupport.cpp	/^void EndHIDInput (void)$/;"	f
Entrance	abstraction/clusterAbstraction.h	/^  Entrance(int center1Row, int center1Col, $/;"	f	class:Entrance
Entrance	abstraction/clusterAbstraction.h	/^class Entrance {$/;"	c
EntranceException	aha/AnnotatedCluster.h	/^		EntranceException(node* n1, node* n2) : endpoint1(n1), endpoint2(n2) { message=0; }$/;"	f	class:EntranceException
EntranceException	aha/AnnotatedCluster.h	/^class EntranceException : public std::exception$/;"	c
EntranceNodeIsHardObstacleException	aha/AnnotatedCluster.h	/^class EntranceNodeIsHardObstacleException : public std::exception$/;"	c
EntranceNodeIsNotTraversable	aha/AnnotatedCluster.h	/^class EntranceNodeIsNotTraversable : public std::exception$/;"	c
EntranceNodesAreNotAdjacentException	aha/AnnotatedCluster.h	/^class EntranceNodesAreNotAdjacentException : public std::exception$/;"	c
Error_Handler_h	driver/MAC/HID Support/HID_Error_Handler.h	/^#define Error_Handler_h$/;"	d
ExpMgrUtil	tests/ExperimentManager.h	/^namespace ExpMgrUtil$/;"	n
Experiment	shared/scenarioLoader.h	/^  Experiment(int sx,int sy,int gx,int gy,int b, double d, string m)$/;"	f	class:Experiment
Experiment	shared/scenarioLoader.h	/^  Experiment(int sx,int sy,int gx,int gy,int sizeX, int sizeY,int b, double d, string m)$/;"	f	class:Experiment
Experiment	shared/scenarioLoader.h	/^class Experiment{$/;"	c
ExperimentCollection	tests/ExperimentManager.h	/^	typedef __gnu_cxx::hash_map<int, TestExperiment*> ExperimentCollection;$/;"	t	namespace:ExpMgrUtil
ExperimentKey	tests/ExperimentManager.h	/^	enum ExperimentKey$/;"	g	namespace:ExpMgrUtil
ExperimentManager	tests/ExperimentManager.cpp	/^ExperimentManager::ExperimentManager()$/;"	f	class:ExperimentManager
ExperimentManager	tests/ExperimentManager.h	/^class ExperimentManager$/;"	c
GENERICIDASTAR_H	util/GenericIDAStar.h	/^#define GENERICIDASTAR_H$/;"	d
GENERICSTAR_H	util/GenericAStar.h	/^#define GENERICSTAR_H$/;"	d
GLCaps	driver/MAC/macGlCheck.h	/^} GLCaps;$/;"	t	typeref:struct:__anon15
GLUTIL_H	util/glUtil.h	/^#define GLUTIL_H$/;"	d
GLUT_ACTIVE_ALT	driver/STUB/GL/glut.h	/^#define GLUT_ACTIVE_ALT /;"	d
GLUT_ACTIVE_CTRL	driver/STUB/GL/glut.h	/^#define GLUT_ACTIVE_CTRL /;"	d
GLUT_ACTIVE_SHIFT	driver/STUB/GL/glut.h	/^#define GLUT_ACTIVE_SHIFT /;"	d
GLUT_DEPTH	driver/STUB/GL/glut.h	/^#define GLUT_DEPTH /;"	d
GLUT_DOUBLE	driver/STUB/GL/glut.h	/^#define GLUT_DOUBLE /;"	d
GLUT_DOWN	driver/STUB/GL/glut.h	/^#define GLUT_DOWN /;"	d
GLUT_H	driver/STUB/GL/glut.h	/^#define GLUT_H$/;"	d
GLUT_LEFT_BUTTON	driver/STUB/GL/glut.h	/^#define GLUT_LEFT_BUTTON /;"	d
GLUT_MIDDLE_BUTTON	driver/STUB/GL/glut.h	/^#define GLUT_MIDDLE_BUTTON /;"	d
GLUT_RGBA	driver/STUB/GL/glut.h	/^#define GLUT_RGBA /;"	d
GLUT_RIGHT_BUTTON	driver/STUB/GL/glut.h	/^#define GLUT_RIGHT_BUTTON /;"	d
GLUT_WINDOW_HEIGHT	driver/STUB/GL/glut.h	/^#define GLUT_WINDOW_HEIGHT /;"	d
GLUT_WINDOW_WIDTH	driver/STUB/GL/glut.h	/^#define GLUT_WINDOW_WIDTH /;"	d
GL_2D	driver/STUB/GL/gl.h	/^#define GL_2D	/;"	d
GL_3D	driver/STUB/GL/gl.h	/^#define GL_3D	/;"	d
GL_3D_COLOR	driver/STUB/GL/gl.h	/^#define GL_3D_COLOR	/;"	d
GL_3D_COLOR_TEXTURE	driver/STUB/GL/gl.h	/^#define GL_3D_COLOR_TEXTURE	/;"	d
GL_4D_COLOR_TEXTURE	driver/STUB/GL/gl.h	/^#define GL_4D_COLOR_TEXTURE	/;"	d
GL_ACCUM	driver/STUB/GL/gl.h	/^#define GL_ACCUM	/;"	d
GL_ACCUM_ALPHA_BITS	driver/STUB/GL/gl.h	/^#define GL_ACCUM_ALPHA_BITS	/;"	d
GL_ACCUM_BLUE_BITS	driver/STUB/GL/gl.h	/^#define GL_ACCUM_BLUE_BITS	/;"	d
GL_ACCUM_BUFFER_BIT	driver/STUB/GL/gl.h	/^#define GL_ACCUM_BUFFER_BIT	/;"	d
GL_ACCUM_CLEAR_VALUE	driver/STUB/GL/gl.h	/^#define GL_ACCUM_CLEAR_VALUE	/;"	d
GL_ACCUM_GREEN_BITS	driver/STUB/GL/gl.h	/^#define GL_ACCUM_GREEN_BITS	/;"	d
GL_ACCUM_RED_BITS	driver/STUB/GL/gl.h	/^#define GL_ACCUM_RED_BITS	/;"	d
GL_ADD	driver/STUB/GL/gl.h	/^#define GL_ADD	/;"	d
GL_ALL_ATTRIB_BITS	driver/STUB/GL/gl.h	/^#define GL_ALL_ATTRIB_BITS	/;"	d
GL_ALL_CLIENT_ATTRIB_BITS	driver/STUB/GL/gl.h	/^#define GL_ALL_CLIENT_ATTRIB_BITS /;"	d
GL_ALPHA	driver/STUB/GL/gl.h	/^#define GL_ALPHA	/;"	d
GL_ALPHA12	driver/STUB/GL/gl.h	/^#define GL_ALPHA12	/;"	d
GL_ALPHA16	driver/STUB/GL/gl.h	/^#define GL_ALPHA16	/;"	d
GL_ALPHA4	driver/STUB/GL/gl.h	/^#define GL_ALPHA4	/;"	d
GL_ALPHA8	driver/STUB/GL/gl.h	/^#define GL_ALPHA8	/;"	d
GL_ALPHA_BIAS	driver/STUB/GL/gl.h	/^#define GL_ALPHA_BIAS	/;"	d
GL_ALPHA_BITS	driver/STUB/GL/gl.h	/^#define GL_ALPHA_BITS	/;"	d
GL_ALPHA_SCALE	driver/STUB/GL/gl.h	/^#define GL_ALPHA_SCALE	/;"	d
GL_ALPHA_TEST	driver/STUB/GL/gl.h	/^#define GL_ALPHA_TEST	/;"	d
GL_ALPHA_TEST_FUNC	driver/STUB/GL/gl.h	/^#define GL_ALPHA_TEST_FUNC	/;"	d
GL_ALPHA_TEST_REF	driver/STUB/GL/gl.h	/^#define GL_ALPHA_TEST_REF	/;"	d
GL_ALWAYS	driver/STUB/GL/gl.h	/^#define GL_ALWAYS	/;"	d
GL_AMBIENT	driver/STUB/GL/gl.h	/^#define GL_AMBIENT	/;"	d
GL_AMBIENT_AND_DIFFUSE	driver/STUB/GL/gl.h	/^#define GL_AMBIENT_AND_DIFFUSE	/;"	d
GL_AND	driver/STUB/GL/gl.h	/^#define GL_AND	/;"	d
GL_AND_INVERTED	driver/STUB/GL/gl.h	/^#define GL_AND_INVERTED	/;"	d
GL_AND_REVERSE	driver/STUB/GL/gl.h	/^#define GL_AND_REVERSE	/;"	d
GL_ATTRIB_STACK_DEPTH	driver/STUB/GL/gl.h	/^#define GL_ATTRIB_STACK_DEPTH	/;"	d
GL_AUTO_NORMAL	driver/STUB/GL/gl.h	/^#define GL_AUTO_NORMAL	/;"	d
GL_AUX0	driver/STUB/GL/gl.h	/^#define GL_AUX0	/;"	d
GL_AUX1	driver/STUB/GL/gl.h	/^#define GL_AUX1	/;"	d
GL_AUX2	driver/STUB/GL/gl.h	/^#define GL_AUX2	/;"	d
GL_AUX3	driver/STUB/GL/gl.h	/^#define GL_AUX3	/;"	d
GL_AUX_BUFFERS	driver/STUB/GL/gl.h	/^#define GL_AUX_BUFFERS	/;"	d
GL_BACK	driver/STUB/GL/gl.h	/^#define GL_BACK	/;"	d
GL_BACK_LEFT	driver/STUB/GL/gl.h	/^#define GL_BACK_LEFT	/;"	d
GL_BACK_RIGHT	driver/STUB/GL/gl.h	/^#define GL_BACK_RIGHT	/;"	d
GL_BITMAP	driver/STUB/GL/gl.h	/^#define GL_BITMAP	/;"	d
GL_BITMAP_TOKEN	driver/STUB/GL/gl.h	/^#define GL_BITMAP_TOKEN	/;"	d
GL_BLEND	driver/STUB/GL/gl.h	/^#define GL_BLEND	/;"	d
GL_BLEND_DST	driver/STUB/GL/gl.h	/^#define GL_BLEND_DST	/;"	d
GL_BLEND_SRC	driver/STUB/GL/gl.h	/^#define GL_BLEND_SRC	/;"	d
GL_BLUE	driver/STUB/GL/gl.h	/^#define GL_BLUE	/;"	d
GL_BLUE_BIAS	driver/STUB/GL/gl.h	/^#define GL_BLUE_BIAS	/;"	d
GL_BLUE_BITS	driver/STUB/GL/gl.h	/^#define GL_BLUE_BITS	/;"	d
GL_BLUE_SCALE	driver/STUB/GL/gl.h	/^#define GL_BLUE_SCALE	/;"	d
GL_CCW	driver/STUB/GL/gl.h	/^#define GL_CCW	/;"	d
GL_CLAMP	driver/STUB/GL/gl.h	/^#define GL_CLAMP	/;"	d
GL_CLEAR	driver/STUB/GL/gl.h	/^#define GL_CLEAR	/;"	d
GL_CLIENT_ALL_ATTRIB_BITS	driver/STUB/GL/gl.h	/^#define GL_CLIENT_ALL_ATTRIB_BITS /;"	d
GL_CLIENT_ATTRIB_STACK_DEPTH	driver/STUB/GL/gl.h	/^#define GL_CLIENT_ATTRIB_STACK_DEPTH	/;"	d
GL_CLIENT_PIXEL_STORE_BIT	driver/STUB/GL/gl.h	/^#define GL_CLIENT_PIXEL_STORE_BIT	/;"	d
GL_CLIENT_VERTEX_ARRAY_BIT	driver/STUB/GL/gl.h	/^#define GL_CLIENT_VERTEX_ARRAY_BIT	/;"	d
GL_CLIP_PLANE0	driver/STUB/GL/gl.h	/^#define GL_CLIP_PLANE0	/;"	d
GL_CLIP_PLANE1	driver/STUB/GL/gl.h	/^#define GL_CLIP_PLANE1	/;"	d
GL_CLIP_PLANE2	driver/STUB/GL/gl.h	/^#define GL_CLIP_PLANE2	/;"	d
GL_CLIP_PLANE3	driver/STUB/GL/gl.h	/^#define GL_CLIP_PLANE3	/;"	d
GL_CLIP_PLANE4	driver/STUB/GL/gl.h	/^#define GL_CLIP_PLANE4	/;"	d
GL_CLIP_PLANE5	driver/STUB/GL/gl.h	/^#define GL_CLIP_PLANE5	/;"	d
GL_COEFF	driver/STUB/GL/gl.h	/^#define GL_COEFF	/;"	d
GL_COLOR	driver/STUB/GL/gl.h	/^#define GL_COLOR	/;"	d
GL_COLOR_BUFFER_BIT	driver/STUB/GL/gl.h	/^#define GL_COLOR_BUFFER_BIT	/;"	d
GL_COLOR_CLEAR_VALUE	driver/STUB/GL/gl.h	/^#define GL_COLOR_CLEAR_VALUE	/;"	d
GL_COLOR_INDEX	driver/STUB/GL/gl.h	/^#define GL_COLOR_INDEX	/;"	d
GL_COLOR_INDEXES	driver/STUB/GL/gl.h	/^#define GL_COLOR_INDEXES	/;"	d
GL_COLOR_LOGIC_OP	driver/STUB/GL/gl.h	/^#define GL_COLOR_LOGIC_OP	/;"	d
GL_COLOR_MATERIAL	driver/STUB/GL/gl.h	/^#define GL_COLOR_MATERIAL	/;"	d
GL_COLOR_MATERIAL_FACE	driver/STUB/GL/gl.h	/^#define GL_COLOR_MATERIAL_FACE	/;"	d
GL_COLOR_MATERIAL_PARAMETER	driver/STUB/GL/gl.h	/^#define GL_COLOR_MATERIAL_PARAMETER	/;"	d
GL_COLOR_WRITEMASK	driver/STUB/GL/gl.h	/^#define GL_COLOR_WRITEMASK	/;"	d
GL_COMPILE	driver/STUB/GL/gl.h	/^#define GL_COMPILE	/;"	d
GL_COMPILE_AND_EXECUTE	driver/STUB/GL/gl.h	/^#define GL_COMPILE_AND_EXECUTE	/;"	d
GL_CONSTANT_ATTENUATION	driver/STUB/GL/gl.h	/^#define GL_CONSTANT_ATTENUATION	/;"	d
GL_COPY	driver/STUB/GL/gl.h	/^#define GL_COPY	/;"	d
GL_COPY_INVERTED	driver/STUB/GL/gl.h	/^#define GL_COPY_INVERTED	/;"	d
GL_COPY_PIXEL_TOKEN	driver/STUB/GL/gl.h	/^#define GL_COPY_PIXEL_TOKEN	/;"	d
GL_CULL_FACE	driver/STUB/GL/gl.h	/^#define GL_CULL_FACE	/;"	d
GL_CULL_FACE_MODE	driver/STUB/GL/gl.h	/^#define GL_CULL_FACE_MODE	/;"	d
GL_CURRENT_BIT	driver/STUB/GL/gl.h	/^#define GL_CURRENT_BIT	/;"	d
GL_CURRENT_COLOR	driver/STUB/GL/gl.h	/^#define GL_CURRENT_COLOR	/;"	d
GL_CURRENT_INDEX	driver/STUB/GL/gl.h	/^#define GL_CURRENT_INDEX	/;"	d
GL_CURRENT_NORMAL	driver/STUB/GL/gl.h	/^#define GL_CURRENT_NORMAL	/;"	d
GL_CURRENT_RASTER_COLOR	driver/STUB/GL/gl.h	/^#define GL_CURRENT_RASTER_COLOR	/;"	d
GL_CURRENT_RASTER_DISTANCE	driver/STUB/GL/gl.h	/^#define GL_CURRENT_RASTER_DISTANCE	/;"	d
GL_CURRENT_RASTER_INDEX	driver/STUB/GL/gl.h	/^#define GL_CURRENT_RASTER_INDEX	/;"	d
GL_CURRENT_RASTER_POSITION	driver/STUB/GL/gl.h	/^#define GL_CURRENT_RASTER_POSITION	/;"	d
GL_CURRENT_RASTER_POSITION_VALID	driver/STUB/GL/gl.h	/^#define GL_CURRENT_RASTER_POSITION_VALID	/;"	d
GL_CURRENT_RASTER_TEXTURE_COORDS	driver/STUB/GL/gl.h	/^#define GL_CURRENT_RASTER_TEXTURE_COORDS	/;"	d
GL_CURRENT_TEXTURE_COORDS	driver/STUB/GL/gl.h	/^#define GL_CURRENT_TEXTURE_COORDS	/;"	d
GL_CW	driver/STUB/GL/gl.h	/^#define GL_CW	/;"	d
GL_DECAL	driver/STUB/GL/gl.h	/^#define GL_DECAL	/;"	d
GL_DECR	driver/STUB/GL/gl.h	/^#define GL_DECR	/;"	d
GL_DEPTH	driver/STUB/GL/gl.h	/^#define GL_DEPTH	/;"	d
GL_DEPTH_BIAS	driver/STUB/GL/gl.h	/^#define GL_DEPTH_BIAS	/;"	d
GL_DEPTH_BUFFER_BIT	driver/STUB/GL/gl.h	/^#define GL_DEPTH_BUFFER_BIT	/;"	d
GL_DEPTH_COMPONENT	driver/STUB/GL/gl.h	/^#define GL_DEPTH_COMPONENT	/;"	d
GL_DEPTH_SCALE	driver/STUB/GL/gl.h	/^#define GL_DEPTH_SCALE	/;"	d
GL_DEPTH_TEST	driver/STUB/GL/gl.h	/^#define GL_DEPTH_TEST	/;"	d
GL_DIFFUSE	driver/STUB/GL/gl.h	/^#define GL_DIFFUSE	/;"	d
GL_DITHER	driver/STUB/GL/gl.h	/^#define GL_DITHER	/;"	d
GL_DOMAIN	driver/STUB/GL/gl.h	/^#define GL_DOMAIN	/;"	d
GL_DONT_CARE	driver/STUB/GL/gl.h	/^#define GL_DONT_CARE	/;"	d
GL_DOUBLE	driver/STUB/GL/gl.h	/^#define GL_DOUBLE	/;"	d
GL_DOUBLEBUFFER	driver/STUB/GL/gl.h	/^#define GL_DOUBLEBUFFER	/;"	d
GL_DRAW_BUFFER	driver/STUB/GL/gl.h	/^#define GL_DRAW_BUFFER	/;"	d
GL_DRAW_PIXEL_TOKEN	driver/STUB/GL/gl.h	/^#define GL_DRAW_PIXEL_TOKEN	/;"	d
GL_DST_ALPHA	driver/STUB/GL/gl.h	/^#define GL_DST_ALPHA	/;"	d
GL_DST_COLOR	driver/STUB/GL/gl.h	/^#define GL_DST_COLOR	/;"	d
GL_EDGE_FLAG	driver/STUB/GL/gl.h	/^#define GL_EDGE_FLAG	/;"	d
GL_EMISSION	driver/STUB/GL/gl.h	/^#define GL_EMISSION	/;"	d
GL_ENABLE_BIT	driver/STUB/GL/gl.h	/^#define GL_ENABLE_BIT	/;"	d
GL_EQUIV	driver/STUB/GL/gl.h	/^#define GL_EQUIV	/;"	d
GL_EVAL_BIT	driver/STUB/GL/gl.h	/^#define GL_EVAL_BIT	/;"	d
GL_EXP	driver/STUB/GL/gl.h	/^#define GL_EXP	/;"	d
GL_EXP2	driver/STUB/GL/gl.h	/^#define GL_EXP2	/;"	d
GL_EXTENSIONS	driver/STUB/GL/gl.h	/^#define GL_EXTENSIONS	/;"	d
GL_EYE_LINEAR	driver/STUB/GL/gl.h	/^#define GL_EYE_LINEAR	/;"	d
GL_EYE_PLANE	driver/STUB/GL/gl.h	/^#define GL_EYE_PLANE	/;"	d
GL_FALSE	driver/STUB/GL/gl.h	/^#define GL_FALSE	/;"	d
GL_FASTEST	driver/STUB/GL/gl.h	/^#define GL_FASTEST	/;"	d
GL_FEEDBACK	driver/STUB/GL/gl.h	/^#define GL_FEEDBACK	/;"	d
GL_FEEDBACK_BUFFER_POINTER	driver/STUB/GL/gl.h	/^#define GL_FEEDBACK_BUFFER_POINTER	/;"	d
GL_FEEDBACK_BUFFER_SIZE	driver/STUB/GL/gl.h	/^#define GL_FEEDBACK_BUFFER_SIZE	/;"	d
GL_FEEDBACK_BUFFER_TYPE	driver/STUB/GL/gl.h	/^#define GL_FEEDBACK_BUFFER_TYPE	/;"	d
GL_FILL	driver/STUB/GL/gl.h	/^#define GL_FILL	/;"	d
GL_FLAT	driver/STUB/GL/gl.h	/^#define GL_FLAT	/;"	d
GL_FLOAT	driver/STUB/GL/gl.h	/^#define GL_FLOAT	/;"	d
GL_FOG	driver/STUB/GL/gl.h	/^#define GL_FOG	/;"	d
GL_FOG_BIT	driver/STUB/GL/gl.h	/^#define GL_FOG_BIT	/;"	d
GL_FOG_COLOR	driver/STUB/GL/gl.h	/^#define GL_FOG_COLOR	/;"	d
GL_FOG_DENSITY	driver/STUB/GL/gl.h	/^#define GL_FOG_DENSITY	/;"	d
GL_FOG_END	driver/STUB/GL/gl.h	/^#define GL_FOG_END	/;"	d
GL_FOG_HINT	driver/STUB/GL/gl.h	/^#define GL_FOG_HINT	/;"	d
GL_FOG_INDEX	driver/STUB/GL/gl.h	/^#define GL_FOG_INDEX	/;"	d
GL_FOG_MODE	driver/STUB/GL/gl.h	/^#define GL_FOG_MODE	/;"	d
GL_FOG_START	driver/STUB/GL/gl.h	/^#define GL_FOG_START	/;"	d
GL_FRONT	driver/STUB/GL/gl.h	/^#define GL_FRONT	/;"	d
GL_FRONT_AND_BACK	driver/STUB/GL/gl.h	/^#define GL_FRONT_AND_BACK	/;"	d
GL_FRONT_FACE	driver/STUB/GL/gl.h	/^#define GL_FRONT_FACE	/;"	d
GL_FRONT_LEFT	driver/STUB/GL/gl.h	/^#define GL_FRONT_LEFT	/;"	d
GL_FRONT_RIGHT	driver/STUB/GL/gl.h	/^#define GL_FRONT_RIGHT	/;"	d
GL_GREEN	driver/STUB/GL/gl.h	/^#define GL_GREEN	/;"	d
GL_GREEN_BIAS	driver/STUB/GL/gl.h	/^#define GL_GREEN_BIAS	/;"	d
GL_GREEN_BITS	driver/STUB/GL/gl.h	/^#define GL_GREEN_BITS	/;"	d
GL_GREEN_SCALE	driver/STUB/GL/gl.h	/^#define GL_GREEN_SCALE	/;"	d
GL_H	driver/STUB/GL/gl.h	/^#define GL_H$/;"	d
GL_HINT_BIT	driver/STUB/GL/gl.h	/^#define GL_HINT_BIT	/;"	d
GL_INCR	driver/STUB/GL/gl.h	/^#define GL_INCR	/;"	d
GL_INDEX_BITS	driver/STUB/GL/gl.h	/^#define GL_INDEX_BITS	/;"	d
GL_INDEX_CLEAR_VALUE	driver/STUB/GL/gl.h	/^#define GL_INDEX_CLEAR_VALUE	/;"	d
GL_INDEX_LOGIC_OP	driver/STUB/GL/gl.h	/^#define GL_INDEX_LOGIC_OP	/;"	d
GL_INDEX_MODE	driver/STUB/GL/gl.h	/^#define GL_INDEX_MODE	/;"	d
GL_INDEX_OFFSET	driver/STUB/GL/gl.h	/^#define GL_INDEX_OFFSET	/;"	d
GL_INDEX_SHIFT	driver/STUB/GL/gl.h	/^#define GL_INDEX_SHIFT	/;"	d
GL_INDEX_WRITEMASK	driver/STUB/GL/gl.h	/^#define GL_INDEX_WRITEMASK	/;"	d
GL_INTENSITY	driver/STUB/GL/gl.h	/^#define GL_INTENSITY	/;"	d
GL_INTENSITY12	driver/STUB/GL/gl.h	/^#define GL_INTENSITY12	/;"	d
GL_INTENSITY16	driver/STUB/GL/gl.h	/^#define GL_INTENSITY16	/;"	d
GL_INTENSITY4	driver/STUB/GL/gl.h	/^#define GL_INTENSITY4	/;"	d
GL_INTENSITY8	driver/STUB/GL/gl.h	/^#define GL_INTENSITY8	/;"	d
GL_INVALID_ENUM	driver/STUB/GL/gl.h	/^#define GL_INVALID_ENUM	/;"	d
GL_INVALID_OPERATION	driver/STUB/GL/gl.h	/^#define GL_INVALID_OPERATION	/;"	d
GL_INVALID_VALUE	driver/STUB/GL/gl.h	/^#define GL_INVALID_VALUE	/;"	d
GL_INVERT	driver/STUB/GL/gl.h	/^#define GL_INVERT	/;"	d
GL_KEEP	driver/STUB/GL/gl.h	/^#define GL_KEEP	/;"	d
GL_LEFT	driver/STUB/GL/gl.h	/^#define GL_LEFT	/;"	d
GL_LIGHT0	driver/STUB/GL/gl.h	/^#define GL_LIGHT0	/;"	d
GL_LIGHT1	driver/STUB/GL/gl.h	/^#define GL_LIGHT1	/;"	d
GL_LIGHT2	driver/STUB/GL/gl.h	/^#define GL_LIGHT2	/;"	d
GL_LIGHT3	driver/STUB/GL/gl.h	/^#define GL_LIGHT3	/;"	d
GL_LIGHT4	driver/STUB/GL/gl.h	/^#define GL_LIGHT4	/;"	d
GL_LIGHT5	driver/STUB/GL/gl.h	/^#define GL_LIGHT5	/;"	d
GL_LIGHT6	driver/STUB/GL/gl.h	/^#define GL_LIGHT6	/;"	d
GL_LIGHT7	driver/STUB/GL/gl.h	/^#define GL_LIGHT7	/;"	d
GL_LIGHTING	driver/STUB/GL/gl.h	/^#define GL_LIGHTING	/;"	d
GL_LIGHTING_BIT	driver/STUB/GL/gl.h	/^#define GL_LIGHTING_BIT	/;"	d
GL_LIGHT_MODEL_AMBIENT	driver/STUB/GL/gl.h	/^#define GL_LIGHT_MODEL_AMBIENT	/;"	d
GL_LIGHT_MODEL_LOCAL_VIEWER	driver/STUB/GL/gl.h	/^#define GL_LIGHT_MODEL_LOCAL_VIEWER	/;"	d
GL_LIGHT_MODEL_TWO_SIDE	driver/STUB/GL/gl.h	/^#define GL_LIGHT_MODEL_TWO_SIDE	/;"	d
GL_LINE	driver/STUB/GL/gl.h	/^#define GL_LINE	/;"	d
GL_LINEAR	driver/STUB/GL/gl.h	/^#define GL_LINEAR	/;"	d
GL_LINEAR_ATTENUATION	driver/STUB/GL/gl.h	/^#define GL_LINEAR_ATTENUATION	/;"	d
GL_LINEAR_MIPMAP_LINEAR	driver/STUB/GL/gl.h	/^#define GL_LINEAR_MIPMAP_LINEAR	/;"	d
GL_LINEAR_MIPMAP_NEAREST	driver/STUB/GL/gl.h	/^#define GL_LINEAR_MIPMAP_NEAREST	/;"	d
GL_LINES	driver/STUB/GL/gl.h	/^#define GL_LINES	/;"	d
GL_LINE_BIT	driver/STUB/GL/gl.h	/^#define GL_LINE_BIT	/;"	d
GL_LINE_LOOP	driver/STUB/GL/gl.h	/^#define GL_LINE_LOOP	/;"	d
GL_LINE_RESET_TOKEN	driver/STUB/GL/gl.h	/^#define GL_LINE_RESET_TOKEN	/;"	d
GL_LINE_SMOOTH	driver/STUB/GL/gl.h	/^#define GL_LINE_SMOOTH	/;"	d
GL_LINE_SMOOTH_HINT	driver/STUB/GL/gl.h	/^#define GL_LINE_SMOOTH_HINT	/;"	d
GL_LINE_STIPPLE	driver/STUB/GL/gl.h	/^#define GL_LINE_STIPPLE	/;"	d
GL_LINE_STIPPLE_PATTERN	driver/STUB/GL/gl.h	/^#define GL_LINE_STIPPLE_PATTERN	/;"	d
GL_LINE_STIPPLE_REPEAT	driver/STUB/GL/gl.h	/^#define GL_LINE_STIPPLE_REPEAT	/;"	d
GL_LINE_STRIP	driver/STUB/GL/gl.h	/^#define GL_LINE_STRIP	/;"	d
GL_LINE_TOKEN	driver/STUB/GL/gl.h	/^#define GL_LINE_TOKEN	/;"	d
GL_LINE_WIDTH	driver/STUB/GL/gl.h	/^#define GL_LINE_WIDTH	/;"	d
GL_LINE_WIDTH_GRANULARITY	driver/STUB/GL/gl.h	/^#define GL_LINE_WIDTH_GRANULARITY	/;"	d
GL_LINE_WIDTH_RANGE	driver/STUB/GL/gl.h	/^#define GL_LINE_WIDTH_RANGE	/;"	d
GL_LIST_BASE	driver/STUB/GL/gl.h	/^#define GL_LIST_BASE	/;"	d
GL_LIST_BIT	driver/STUB/GL/gl.h	/^#define GL_LIST_BIT	/;"	d
GL_LIST_INDEX	driver/STUB/GL/gl.h	/^#define GL_LIST_INDEX	/;"	d
GL_LIST_MODE	driver/STUB/GL/gl.h	/^#define GL_LIST_MODE	/;"	d
GL_LOAD	driver/STUB/GL/gl.h	/^#define GL_LOAD	/;"	d
GL_LOGIC_OP	driver/STUB/GL/gl.h	/^#define GL_LOGIC_OP	/;"	d
GL_LOGIC_OP_MODE	driver/STUB/GL/gl.h	/^#define GL_LOGIC_OP_MODE	/;"	d
GL_LUMINANCE	driver/STUB/GL/gl.h	/^#define GL_LUMINANCE	/;"	d
GL_LUMINANCE12	driver/STUB/GL/gl.h	/^#define GL_LUMINANCE12	/;"	d
GL_LUMINANCE12_ALPHA12	driver/STUB/GL/gl.h	/^#define GL_LUMINANCE12_ALPHA12	/;"	d
GL_LUMINANCE12_ALPHA4	driver/STUB/GL/gl.h	/^#define GL_LUMINANCE12_ALPHA4	/;"	d
GL_LUMINANCE16	driver/STUB/GL/gl.h	/^#define GL_LUMINANCE16	/;"	d
GL_LUMINANCE16_ALPHA16	driver/STUB/GL/gl.h	/^#define GL_LUMINANCE16_ALPHA16	/;"	d
GL_LUMINANCE4	driver/STUB/GL/gl.h	/^#define GL_LUMINANCE4	/;"	d
GL_LUMINANCE4_ALPHA4	driver/STUB/GL/gl.h	/^#define GL_LUMINANCE4_ALPHA4	/;"	d
GL_LUMINANCE6_ALPHA2	driver/STUB/GL/gl.h	/^#define GL_LUMINANCE6_ALPHA2	/;"	d
GL_LUMINANCE8	driver/STUB/GL/gl.h	/^#define GL_LUMINANCE8	/;"	d
GL_LUMINANCE8_ALPHA8	driver/STUB/GL/gl.h	/^#define GL_LUMINANCE8_ALPHA8	/;"	d
GL_LUMINANCE_ALPHA	driver/STUB/GL/gl.h	/^#define GL_LUMINANCE_ALPHA	/;"	d
GL_MAP1_COLOR_4	driver/STUB/GL/gl.h	/^#define GL_MAP1_COLOR_4	/;"	d
GL_MAP1_GRID_DOMAIN	driver/STUB/GL/gl.h	/^#define GL_MAP1_GRID_DOMAIN	/;"	d
GL_MAP1_GRID_SEGMENTS	driver/STUB/GL/gl.h	/^#define GL_MAP1_GRID_SEGMENTS	/;"	d
GL_MAP1_INDEX	driver/STUB/GL/gl.h	/^#define GL_MAP1_INDEX	/;"	d
GL_MAP1_NORMAL	driver/STUB/GL/gl.h	/^#define GL_MAP1_NORMAL	/;"	d
GL_MAP1_TEXTURE_COORD_1	driver/STUB/GL/gl.h	/^#define GL_MAP1_TEXTURE_COORD_1	/;"	d
GL_MAP1_TEXTURE_COORD_2	driver/STUB/GL/gl.h	/^#define GL_MAP1_TEXTURE_COORD_2	/;"	d
GL_MAP1_TEXTURE_COORD_3	driver/STUB/GL/gl.h	/^#define GL_MAP1_TEXTURE_COORD_3	/;"	d
GL_MAP1_TEXTURE_COORD_4	driver/STUB/GL/gl.h	/^#define GL_MAP1_TEXTURE_COORD_4	/;"	d
GL_MAP1_VERTEX_3	driver/STUB/GL/gl.h	/^#define GL_MAP1_VERTEX_3	/;"	d
GL_MAP1_VERTEX_4	driver/STUB/GL/gl.h	/^#define GL_MAP1_VERTEX_4	/;"	d
GL_MAP2_COLOR_4	driver/STUB/GL/gl.h	/^#define GL_MAP2_COLOR_4	/;"	d
GL_MAP2_GRID_DOMAIN	driver/STUB/GL/gl.h	/^#define GL_MAP2_GRID_DOMAIN	/;"	d
GL_MAP2_GRID_SEGMENTS	driver/STUB/GL/gl.h	/^#define GL_MAP2_GRID_SEGMENTS	/;"	d
GL_MAP2_INDEX	driver/STUB/GL/gl.h	/^#define GL_MAP2_INDEX	/;"	d
GL_MAP2_NORMAL	driver/STUB/GL/gl.h	/^#define GL_MAP2_NORMAL	/;"	d
GL_MAP2_TEXTURE_COORD_1	driver/STUB/GL/gl.h	/^#define GL_MAP2_TEXTURE_COORD_1	/;"	d
GL_MAP2_TEXTURE_COORD_2	driver/STUB/GL/gl.h	/^#define GL_MAP2_TEXTURE_COORD_2	/;"	d
GL_MAP2_TEXTURE_COORD_3	driver/STUB/GL/gl.h	/^#define GL_MAP2_TEXTURE_COORD_3	/;"	d
GL_MAP2_TEXTURE_COORD_4	driver/STUB/GL/gl.h	/^#define GL_MAP2_TEXTURE_COORD_4	/;"	d
GL_MAP2_VERTEX_3	driver/STUB/GL/gl.h	/^#define GL_MAP2_VERTEX_3	/;"	d
GL_MAP2_VERTEX_4	driver/STUB/GL/gl.h	/^#define GL_MAP2_VERTEX_4	/;"	d
GL_MAP_COLOR	driver/STUB/GL/gl.h	/^#define GL_MAP_COLOR	/;"	d
GL_MAP_STENCIL	driver/STUB/GL/gl.h	/^#define GL_MAP_STENCIL	/;"	d
GL_MATRIX_MODE	driver/STUB/GL/gl.h	/^#define GL_MATRIX_MODE	/;"	d
GL_MAX_ATTRIB_STACK_DEPTH	driver/STUB/GL/gl.h	/^#define GL_MAX_ATTRIB_STACK_DEPTH	/;"	d
GL_MAX_CLIENT_ATTRIB_STACK_DEPTH	driver/STUB/GL/gl.h	/^#define GL_MAX_CLIENT_ATTRIB_STACK_DEPTH	/;"	d
GL_MAX_CLIP_PLANES	driver/STUB/GL/gl.h	/^#define GL_MAX_CLIP_PLANES	/;"	d
GL_MAX_EVAL_ORDER	driver/STUB/GL/gl.h	/^#define GL_MAX_EVAL_ORDER	/;"	d
GL_MAX_LIGHTS	driver/STUB/GL/gl.h	/^#define GL_MAX_LIGHTS	/;"	d
GL_MAX_LIST_NESTING	driver/STUB/GL/gl.h	/^#define GL_MAX_LIST_NESTING	/;"	d
GL_MAX_MODELVIEW_STACK_DEPTH	driver/STUB/GL/gl.h	/^#define GL_MAX_MODELVIEW_STACK_DEPTH	/;"	d
GL_MAX_NAME_STACK_DEPTH	driver/STUB/GL/gl.h	/^#define GL_MAX_NAME_STACK_DEPTH	/;"	d
GL_MAX_PIXEL_MAP_TABLE	driver/STUB/GL/gl.h	/^#define GL_MAX_PIXEL_MAP_TABLE	/;"	d
GL_MAX_PROJECTION_STACK_DEPTH	driver/STUB/GL/gl.h	/^#define GL_MAX_PROJECTION_STACK_DEPTH	/;"	d
GL_MAX_TEXTURE_SIZE	driver/STUB/GL/gl.h	/^#define GL_MAX_TEXTURE_SIZE	/;"	d
GL_MAX_TEXTURE_STACK_DEPTH	driver/STUB/GL/gl.h	/^#define GL_MAX_TEXTURE_STACK_DEPTH	/;"	d
GL_MAX_VIEWPORT_DIMS	driver/STUB/GL/gl.h	/^#define GL_MAX_VIEWPORT_DIMS	/;"	d
GL_MODELVIEW	driver/STUB/GL/gl.h	/^#define GL_MODELVIEW	/;"	d
GL_MODELVIEW_MATRIX	driver/STUB/GL/gl.h	/^#define GL_MODELVIEW_MATRIX	/;"	d
GL_MODELVIEW_STACK_DEPTH	driver/STUB/GL/gl.h	/^#define GL_MODELVIEW_STACK_DEPTH	/;"	d
GL_MODULATE	driver/STUB/GL/gl.h	/^#define GL_MODULATE	/;"	d
GL_MULT	driver/STUB/GL/gl.h	/^#define GL_MULT	/;"	d
GL_NAME_STACK_DEPTH	driver/STUB/GL/gl.h	/^#define GL_NAME_STACK_DEPTH	/;"	d
GL_NAND	driver/STUB/GL/gl.h	/^#define GL_NAND	/;"	d
GL_NEAREST	driver/STUB/GL/gl.h	/^#define GL_NEAREST	/;"	d
GL_NEAREST_MIPMAP_LINEAR	driver/STUB/GL/gl.h	/^#define GL_NEAREST_MIPMAP_LINEAR	/;"	d
GL_NEAREST_MIPMAP_NEAREST	driver/STUB/GL/gl.h	/^#define GL_NEAREST_MIPMAP_NEAREST	/;"	d
GL_NICEST	driver/STUB/GL/gl.h	/^#define GL_NICEST	/;"	d
GL_NONE	driver/STUB/GL/gl.h	/^#define GL_NONE	/;"	d
GL_NOOP	driver/STUB/GL/gl.h	/^#define GL_NOOP	/;"	d
GL_NOR	driver/STUB/GL/gl.h	/^#define GL_NOR	/;"	d
GL_NORMALIZE	driver/STUB/GL/gl.h	/^#define GL_NORMALIZE	/;"	d
GL_NO_ERROR	driver/STUB/GL/gl.h	/^#define GL_NO_ERROR /;"	d
GL_OBJECT_LINEAR	driver/STUB/GL/gl.h	/^#define GL_OBJECT_LINEAR	/;"	d
GL_OBJECT_PLANE	driver/STUB/GL/gl.h	/^#define GL_OBJECT_PLANE	/;"	d
GL_ONE	driver/STUB/GL/gl.h	/^#define GL_ONE	/;"	d
GL_ONE_MINUS_DST_ALPHA	driver/STUB/GL/gl.h	/^#define GL_ONE_MINUS_DST_ALPHA	/;"	d
GL_ONE_MINUS_DST_COLOR	driver/STUB/GL/gl.h	/^#define GL_ONE_MINUS_DST_COLOR	/;"	d
GL_ONE_MINUS_SRC_ALPHA	driver/STUB/GL/gl.h	/^#define GL_ONE_MINUS_SRC_ALPHA	/;"	d
GL_ONE_MINUS_SRC_COLOR	driver/STUB/GL/gl.h	/^#define GL_ONE_MINUS_SRC_COLOR	/;"	d
GL_OR	driver/STUB/GL/gl.h	/^#define GL_OR	/;"	d
GL_ORDER	driver/STUB/GL/gl.h	/^#define GL_ORDER	/;"	d
GL_OR_INVERTED	driver/STUB/GL/gl.h	/^#define GL_OR_INVERTED	/;"	d
GL_OR_REVERSE	driver/STUB/GL/gl.h	/^#define GL_OR_REVERSE	/;"	d
GL_OUT_OF_MEMORY	driver/STUB/GL/gl.h	/^#define GL_OUT_OF_MEMORY	/;"	d
GL_PACK_ALIGNMENT	driver/STUB/GL/gl.h	/^#define GL_PACK_ALIGNMENT	/;"	d
GL_PACK_LSB_FIRST	driver/STUB/GL/gl.h	/^#define GL_PACK_LSB_FIRST	/;"	d
GL_PACK_ROW_LENGTH	driver/STUB/GL/gl.h	/^#define GL_PACK_ROW_LENGTH	/;"	d
GL_PACK_SKIP_PIXELS	driver/STUB/GL/gl.h	/^#define GL_PACK_SKIP_PIXELS	/;"	d
GL_PACK_SKIP_ROWS	driver/STUB/GL/gl.h	/^#define GL_PACK_SKIP_ROWS	/;"	d
GL_PACK_SWAP_BYTES	driver/STUB/GL/gl.h	/^#define GL_PACK_SWAP_BYTES	/;"	d
GL_PASS_THROUGH_TOKEN	driver/STUB/GL/gl.h	/^#define GL_PASS_THROUGH_TOKEN	/;"	d
GL_PERSPECTIVE_CORRECTION_HINT	driver/STUB/GL/gl.h	/^#define GL_PERSPECTIVE_CORRECTION_HINT	/;"	d
GL_PIXEL_MAP_A_TO_A	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_A_TO_A	/;"	d
GL_PIXEL_MAP_A_TO_A_SIZE	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_A_TO_A_SIZE	/;"	d
GL_PIXEL_MAP_B_TO_B	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_B_TO_B	/;"	d
GL_PIXEL_MAP_B_TO_B_SIZE	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_B_TO_B_SIZE	/;"	d
GL_PIXEL_MAP_G_TO_G	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_G_TO_G	/;"	d
GL_PIXEL_MAP_G_TO_G_SIZE	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_G_TO_G_SIZE	/;"	d
GL_PIXEL_MAP_I_TO_A	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_I_TO_A	/;"	d
GL_PIXEL_MAP_I_TO_A_SIZE	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_I_TO_A_SIZE	/;"	d
GL_PIXEL_MAP_I_TO_B	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_I_TO_B	/;"	d
GL_PIXEL_MAP_I_TO_B_SIZE	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_I_TO_B_SIZE	/;"	d
GL_PIXEL_MAP_I_TO_G	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_I_TO_G	/;"	d
GL_PIXEL_MAP_I_TO_G_SIZE	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_I_TO_G_SIZE	/;"	d
GL_PIXEL_MAP_I_TO_I	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_I_TO_I	/;"	d
GL_PIXEL_MAP_I_TO_I_SIZE	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_I_TO_I_SIZE	/;"	d
GL_PIXEL_MAP_I_TO_R	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_I_TO_R	/;"	d
GL_PIXEL_MAP_I_TO_R_SIZE	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_I_TO_R_SIZE	/;"	d
GL_PIXEL_MAP_R_TO_R	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_R_TO_R	/;"	d
GL_PIXEL_MAP_R_TO_R_SIZE	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_R_TO_R_SIZE	/;"	d
GL_PIXEL_MAP_S_TO_S	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_S_TO_S	/;"	d
GL_PIXEL_MAP_S_TO_S_SIZE	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MAP_S_TO_S_SIZE	/;"	d
GL_PIXEL_MODE_BIT	driver/STUB/GL/gl.h	/^#define GL_PIXEL_MODE_BIT	/;"	d
GL_POINT	driver/STUB/GL/gl.h	/^#define GL_POINT	/;"	d
GL_POINTS	driver/STUB/GL/gl.h	/^#define GL_POINTS	/;"	d
GL_POINT_BIT	driver/STUB/GL/gl.h	/^#define GL_POINT_BIT	/;"	d
GL_POINT_SMOOTH_HINT	driver/STUB/GL/gl.h	/^#define GL_POINT_SMOOTH_HINT	/;"	d
GL_POINT_TOKEN	driver/STUB/GL/gl.h	/^#define GL_POINT_TOKEN	/;"	d
GL_POLYGON	driver/STUB/GL/gl.h	/^#define GL_POLYGON /;"	d
GL_POLYGON_BIT	driver/STUB/GL/gl.h	/^#define GL_POLYGON_BIT	/;"	d
GL_POLYGON_MODE	driver/STUB/GL/gl.h	/^#define GL_POLYGON_MODE	/;"	d
GL_POLYGON_OFFSET_FACTOR	driver/STUB/GL/gl.h	/^#define GL_POLYGON_OFFSET_FACTOR	/;"	d
GL_POLYGON_OFFSET_FILL	driver/STUB/GL/gl.h	/^#define GL_POLYGON_OFFSET_FILL	/;"	d
GL_POLYGON_OFFSET_LINE	driver/STUB/GL/gl.h	/^#define GL_POLYGON_OFFSET_LINE	/;"	d
GL_POLYGON_OFFSET_POINT	driver/STUB/GL/gl.h	/^#define GL_POLYGON_OFFSET_POINT	/;"	d
GL_POLYGON_OFFSET_UNITS	driver/STUB/GL/gl.h	/^#define GL_POLYGON_OFFSET_UNITS	/;"	d
GL_POLYGON_SMOOTH	driver/STUB/GL/gl.h	/^#define GL_POLYGON_SMOOTH	/;"	d
GL_POLYGON_SMOOTH_HINT	driver/STUB/GL/gl.h	/^#define GL_POLYGON_SMOOTH_HINT	/;"	d
GL_POLYGON_STIPPLE	driver/STUB/GL/gl.h	/^#define GL_POLYGON_STIPPLE	/;"	d
GL_POLYGON_STIPPLE_BIT	driver/STUB/GL/gl.h	/^#define GL_POLYGON_STIPPLE_BIT	/;"	d
GL_POLYGON_TOKEN	driver/STUB/GL/gl.h	/^#define GL_POLYGON_TOKEN	/;"	d
GL_POSITION	driver/STUB/GL/gl.h	/^#define GL_POSITION	/;"	d
GL_PROJECTION	driver/STUB/GL/gl.h	/^#define GL_PROJECTION	/;"	d
GL_PROJECTION_MATRIX	driver/STUB/GL/gl.h	/^#define GL_PROJECTION_MATRIX	/;"	d
GL_PROJECTION_STACK_DEPTH	driver/STUB/GL/gl.h	/^#define GL_PROJECTION_STACK_DEPTH	/;"	d
GL_PROXY_TEXTURE_1D	driver/STUB/GL/gl.h	/^#define GL_PROXY_TEXTURE_1D	/;"	d
GL_PROXY_TEXTURE_2D	driver/STUB/GL/gl.h	/^#define GL_PROXY_TEXTURE_2D	/;"	d
GL_Q	driver/STUB/GL/gl.h	/^#define GL_Q	/;"	d
GL_QUADRATIC_ATTENUATION	driver/STUB/GL/gl.h	/^#define GL_QUADRATIC_ATTENUATION	/;"	d
GL_QUADS	driver/STUB/GL/gl.h	/^#define GL_QUADS	/;"	d
GL_QUAD_STRIP	driver/STUB/GL/gl.h	/^#define GL_QUAD_STRIP	/;"	d
GL_R	driver/STUB/GL/gl.h	/^#define GL_R	/;"	d
GL_R3_G3_B2	driver/STUB/GL/gl.h	/^#define GL_R3_G3_B2	/;"	d
GL_READ_BUFFER	driver/STUB/GL/gl.h	/^#define GL_READ_BUFFER	/;"	d
GL_RED	driver/STUB/GL/gl.h	/^#define GL_RED	/;"	d
GL_RED_BIAS	driver/STUB/GL/gl.h	/^#define GL_RED_BIAS	/;"	d
GL_RED_BITS	driver/STUB/GL/gl.h	/^#define GL_RED_BITS	/;"	d
GL_RED_SCALE	driver/STUB/GL/gl.h	/^#define GL_RED_SCALE	/;"	d
GL_RENDER	driver/STUB/GL/gl.h	/^#define GL_RENDER	/;"	d
GL_RENDERER	driver/STUB/GL/gl.h	/^#define GL_RENDERER	/;"	d
GL_RENDER_MODE	driver/STUB/GL/gl.h	/^#define GL_RENDER_MODE	/;"	d
GL_REPEAT	driver/STUB/GL/gl.h	/^#define GL_REPEAT	/;"	d
GL_REPLACE	driver/STUB/GL/gl.h	/^#define GL_REPLACE	/;"	d
GL_RETURN	driver/STUB/GL/gl.h	/^#define GL_RETURN	/;"	d
GL_RGB	driver/STUB/GL/gl.h	/^#define GL_RGB	/;"	d
GL_RGB10	driver/STUB/GL/gl.h	/^#define GL_RGB10	/;"	d
GL_RGB10_A2	driver/STUB/GL/gl.h	/^#define GL_RGB10_A2	/;"	d
GL_RGB12	driver/STUB/GL/gl.h	/^#define GL_RGB12	/;"	d
GL_RGB16	driver/STUB/GL/gl.h	/^#define GL_RGB16	/;"	d
GL_RGB4	driver/STUB/GL/gl.h	/^#define GL_RGB4	/;"	d
GL_RGB5	driver/STUB/GL/gl.h	/^#define GL_RGB5	/;"	d
GL_RGB5_A1	driver/STUB/GL/gl.h	/^#define GL_RGB5_A1	/;"	d
GL_RGB8	driver/STUB/GL/gl.h	/^#define GL_RGB8	/;"	d
GL_RGBA	driver/STUB/GL/gl.h	/^#define GL_RGBA	/;"	d
GL_RGBA12	driver/STUB/GL/gl.h	/^#define GL_RGBA12	/;"	d
GL_RGBA16	driver/STUB/GL/gl.h	/^#define GL_RGBA16	/;"	d
GL_RGBA2	driver/STUB/GL/gl.h	/^#define GL_RGBA2	/;"	d
GL_RGBA4	driver/STUB/GL/gl.h	/^#define GL_RGBA4	/;"	d
GL_RGBA8	driver/STUB/GL/gl.h	/^#define GL_RGBA8	/;"	d
GL_RGBA_MODE	driver/STUB/GL/gl.h	/^#define GL_RGBA_MODE	/;"	d
GL_RIGHT	driver/STUB/GL/gl.h	/^#define GL_RIGHT	/;"	d
GL_S	driver/STUB/GL/gl.h	/^#define GL_S	/;"	d
GL_SCISSOR_BIT	driver/STUB/GL/gl.h	/^#define GL_SCISSOR_BIT	/;"	d
GL_SCISSOR_BOX	driver/STUB/GL/gl.h	/^#define GL_SCISSOR_BOX	/;"	d
GL_SCISSOR_TEST	driver/STUB/GL/gl.h	/^#define GL_SCISSOR_TEST	/;"	d
GL_SELECT	driver/STUB/GL/gl.h	/^#define GL_SELECT	/;"	d
GL_SELECTION_BUFFER_POINTER	driver/STUB/GL/gl.h	/^#define GL_SELECTION_BUFFER_POINTER	/;"	d
GL_SELECTION_BUFFER_SIZE	driver/STUB/GL/gl.h	/^#define GL_SELECTION_BUFFER_SIZE	/;"	d
GL_SET	driver/STUB/GL/gl.h	/^#define GL_SET	/;"	d
GL_SHADE_MODEL	driver/STUB/GL/gl.h	/^#define GL_SHADE_MODEL	/;"	d
GL_SHININESS	driver/STUB/GL/gl.h	/^#define GL_SHININESS	/;"	d
GL_SMOOTH	driver/STUB/GL/gl.h	/^#define GL_SMOOTH	/;"	d
GL_SPECULAR	driver/STUB/GL/gl.h	/^#define GL_SPECULAR	/;"	d
GL_SPHERE_MAP	driver/STUB/GL/gl.h	/^#define GL_SPHERE_MAP	/;"	d
GL_SPOT_CUTOFF	driver/STUB/GL/gl.h	/^#define GL_SPOT_CUTOFF	/;"	d
GL_SPOT_DIRECTION	driver/STUB/GL/gl.h	/^#define GL_SPOT_DIRECTION	/;"	d
GL_SPOT_EXPONENT	driver/STUB/GL/gl.h	/^#define GL_SPOT_EXPONENT	/;"	d
GL_SRC_ALPHA	driver/STUB/GL/gl.h	/^#define GL_SRC_ALPHA	/;"	d
GL_SRC_ALPHA_SATURATE	driver/STUB/GL/gl.h	/^#define GL_SRC_ALPHA_SATURATE	/;"	d
GL_SRC_COLOR	driver/STUB/GL/gl.h	/^#define GL_SRC_COLOR	/;"	d
GL_STACK_OVERFLOW	driver/STUB/GL/gl.h	/^#define GL_STACK_OVERFLOW	/;"	d
GL_STACK_UNDERFLOW	driver/STUB/GL/gl.h	/^#define GL_STACK_UNDERFLOW	/;"	d
GL_STENCIL	driver/STUB/GL/gl.h	/^#define GL_STENCIL	/;"	d
GL_STENCIL_BITS	driver/STUB/GL/gl.h	/^#define GL_STENCIL_BITS	/;"	d
GL_STENCIL_BUFFER_BIT	driver/STUB/GL/gl.h	/^#define GL_STENCIL_BUFFER_BIT	/;"	d
GL_STENCIL_CLEAR_VALUE	driver/STUB/GL/gl.h	/^#define GL_STENCIL_CLEAR_VALUE	/;"	d
GL_STENCIL_FAIL	driver/STUB/GL/gl.h	/^#define GL_STENCIL_FAIL	/;"	d
GL_STENCIL_FUNC	driver/STUB/GL/gl.h	/^#define GL_STENCIL_FUNC	/;"	d
GL_STENCIL_INDEX	driver/STUB/GL/gl.h	/^#define GL_STENCIL_INDEX	/;"	d
GL_STENCIL_PASS_DEPTH_FAIL	driver/STUB/GL/gl.h	/^#define GL_STENCIL_PASS_DEPTH_FAIL	/;"	d
GL_STENCIL_PASS_DEPTH_PASS	driver/STUB/GL/gl.h	/^#define GL_STENCIL_PASS_DEPTH_PASS	/;"	d
GL_STENCIL_REF	driver/STUB/GL/gl.h	/^#define GL_STENCIL_REF	/;"	d
GL_STENCIL_TEST	driver/STUB/GL/gl.h	/^#define GL_STENCIL_TEST	/;"	d
GL_STENCIL_VALUE_MASK	driver/STUB/GL/gl.h	/^#define GL_STENCIL_VALUE_MASK	/;"	d
GL_STENCIL_WRITEMASK	driver/STUB/GL/gl.h	/^#define GL_STENCIL_WRITEMASK	/;"	d
GL_STEREO	driver/STUB/GL/gl.h	/^#define GL_STEREO	/;"	d
GL_SUBPIXEL_BITS	driver/STUB/GL/gl.h	/^#define GL_SUBPIXEL_BITS	/;"	d
GL_T	driver/STUB/GL/gl.h	/^#define GL_T	/;"	d
GL_TEXTURE	driver/STUB/GL/gl.h	/^#define GL_TEXTURE	/;"	d
GL_TEXTURE_1D	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_1D	/;"	d
GL_TEXTURE_2D	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_2D	/;"	d
GL_TEXTURE_ALPHA_SIZE	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_ALPHA_SIZE	/;"	d
GL_TEXTURE_BINDING_1D	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_BINDING_1D	/;"	d
GL_TEXTURE_BINDING_2D	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_BINDING_2D	/;"	d
GL_TEXTURE_BIT	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_BIT	/;"	d
GL_TEXTURE_BLUE_SIZE	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_BLUE_SIZE	/;"	d
GL_TEXTURE_BORDER	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_BORDER	/;"	d
GL_TEXTURE_BORDER_COLOR	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_BORDER_COLOR	/;"	d
GL_TEXTURE_COMPONENTS	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_COMPONENTS	/;"	d
GL_TEXTURE_ENV	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_ENV	/;"	d
GL_TEXTURE_ENV_COLOR	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_ENV_COLOR	/;"	d
GL_TEXTURE_ENV_MODE	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_ENV_MODE	/;"	d
GL_TEXTURE_GEN_MODE	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_GEN_MODE	/;"	d
GL_TEXTURE_GEN_Q	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_GEN_Q	/;"	d
GL_TEXTURE_GEN_R	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_GEN_R	/;"	d
GL_TEXTURE_GEN_S	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_GEN_S	/;"	d
GL_TEXTURE_GEN_T	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_GEN_T	/;"	d
GL_TEXTURE_GREEN_SIZE	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_GREEN_SIZE	/;"	d
GL_TEXTURE_HEIGHT	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_HEIGHT	/;"	d
GL_TEXTURE_INTENSITY_SIZE	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_INTENSITY_SIZE	/;"	d
GL_TEXTURE_INTERNAL_FORMAT	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_INTERNAL_FORMAT	/;"	d
GL_TEXTURE_LUMINANCE_SIZE	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_LUMINANCE_SIZE	/;"	d
GL_TEXTURE_MAG_FILTER	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_MAG_FILTER	/;"	d
GL_TEXTURE_MATRIX	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_MATRIX	/;"	d
GL_TEXTURE_MIN_FILTER	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_MIN_FILTER	/;"	d
GL_TEXTURE_PRIORITY	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_PRIORITY	/;"	d
GL_TEXTURE_RED_SIZE	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_RED_SIZE	/;"	d
GL_TEXTURE_RESIDENT	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_RESIDENT	/;"	d
GL_TEXTURE_STACK_DEPTH	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_STACK_DEPTH	/;"	d
GL_TEXTURE_WIDTH	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_WIDTH	/;"	d
GL_TEXTURE_WRAP_S	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_WRAP_S	/;"	d
GL_TEXTURE_WRAP_T	driver/STUB/GL/gl.h	/^#define GL_TEXTURE_WRAP_T	/;"	d
GL_TRANSFORM_BIT	driver/STUB/GL/gl.h	/^#define GL_TRANSFORM_BIT	/;"	d
GL_TRIANGLES	driver/STUB/GL/gl.h	/^#define GL_TRIANGLES	/;"	d
GL_TRIANGLE_FAN	driver/STUB/GL/gl.h	/^#define GL_TRIANGLE_FAN	/;"	d
GL_TRIANGLE_STRIP	driver/STUB/GL/gl.h	/^#define GL_TRIANGLE_STRIP	/;"	d
GL_TRUE	driver/STUB/GL/gl.h	/^#define GL_TRUE	/;"	d
GL_UNPACK_ALIGNMENT	driver/STUB/GL/gl.h	/^#define GL_UNPACK_ALIGNMENT	/;"	d
GL_UNPACK_LSB_FIRST	driver/STUB/GL/gl.h	/^#define GL_UNPACK_LSB_FIRST	/;"	d
GL_UNPACK_ROW_LENGTH	driver/STUB/GL/gl.h	/^#define GL_UNPACK_ROW_LENGTH	/;"	d
GL_UNPACK_SKIP_PIXELS	driver/STUB/GL/gl.h	/^#define GL_UNPACK_SKIP_PIXELS	/;"	d
GL_UNPACK_SKIP_ROWS	driver/STUB/GL/gl.h	/^#define GL_UNPACK_SKIP_ROWS	/;"	d
GL_UNPACK_SWAP_BYTES	driver/STUB/GL/gl.h	/^#define GL_UNPACK_SWAP_BYTES	/;"	d
GL_UNSIGNED_INT	driver/STUB/GL/gl.h	/^#define GL_UNSIGNED_INT	/;"	d
GL_VENDOR	driver/STUB/GL/gl.h	/^#define GL_VENDOR	/;"	d
GL_VERSION	driver/STUB/GL/gl.h	/^#define GL_VERSION	/;"	d
GL_VIEWPORT	driver/STUB/GL/gl.h	/^#define GL_VIEWPORT	/;"	d
GL_VIEWPORT_BIT	driver/STUB/GL/gl.h	/^#define GL_VIEWPORT_BIT	/;"	d
GL_XOR	driver/STUB/GL/gl.h	/^#define GL_XOR	/;"	d
GL_ZERO	driver/STUB/GL/gl.h	/^#define GL_ZERO	/;"	d
GL_ZOOM_X	driver/STUB/GL/gl.h	/^#define GL_ZOOM_X	/;"	d
GL_ZOOM_Y	driver/STUB/GL/gl.h	/^#define GL_ZOOM_Y	/;"	d
GLbitfield	driver/STUB/GL/gl.h	/^typedef unsigned int	GLbitfield;$/;"	t
GLboolean	driver/STUB/GL/gl.h	/^typedef unsigned char	GLboolean;$/;"	t
GLbyte	driver/STUB/GL/gl.h	/^typedef signed char	GLbyte;		\/* 1-byte signed *\/$/;"	t
GLclampd	driver/STUB/GL/gl.h	/^typedef double		GLclampd;	\/* double precision float in [0,1] *\/$/;"	t
GLclampf	driver/STUB/GL/gl.h	/^typedef float		GLclampf;	\/* single precision float in [0,1] *\/$/;"	t
GLdouble	driver/STUB/GL/gl.h	/^typedef double		GLdouble;	\/* double precision float *\/$/;"	t
GLenum	driver/STUB/GL/gl.h	/^typedef unsigned int	GLenum;$/;"	t
GLfloat	driver/STUB/GL/gl.h	/^typedef float		GLfloat;	\/* single precision float *\/$/;"	t
GLint	driver/STUB/GL/gl.h	/^typedef int		GLint;		\/* 4-byte signed *\/$/;"	t
GLshort	driver/STUB/GL/gl.h	/^typedef short		GLshort;	\/* 2-byte signed *\/$/;"	t
GLsizei	driver/STUB/GL/gl.h	/^typedef int		GLsizei;	\/* 4-byte signed *\/$/;"	t
GLubyte	driver/STUB/GL/gl.h	/^typedef unsigned char	GLubyte;	\/* 1-byte unsigned *\/$/;"	t
GLuint	driver/STUB/GL/gl.h	/^typedef unsigned int	GLuint;		\/* 4-byte unsigned *\/$/;"	t
GLushort	driver/STUB/GL/gl.h	/^typedef unsigned short	GLushort;	\/* 2-byte unsigned *\/$/;"	t
GLvoid	driver/STUB/GL/gl.h	/^typedef void		GLvoid;$/;"	t
GRAPH_H	util/graph.h	/^#define GRAPH_H$/;"	d
GenericAStar	util/GenericAStar.h	/^	GenericAStar() {}$/;"	f	class:GenericAStar
GenericAStar	util/GenericAStar.h	/^class GenericAStar {$/;"	c
GenericAStarUtil	util/GenericAStar.h	/^namespace GenericAStarUtil$/;"	n
GenericIDAStar	util/GenericIDAStar.h	/^	GenericIDAStar() {}$/;"	f	class:GenericIDAStar
GenericIDAStar	util/GenericIDAStar.h	/^class GenericIDAStar {$/;"	c
GetCurrentContextInfo	driver/MAC/mac_main.cpp	/^pRecContext GetCurrentContextInfo (WindowRef window)$/;"	f
GetElementNameFromVendorProduct	driver/MAC/HID Support/HID_Name_Lookup.cpp	/^void GetElementNameFromVendorProduct (long vendorID, long productID, long cookie, char * pName)$/;"	f
GetHIDTimerUPP	driver/MAC/HID Support/HIDSupport.cpp	/^EventLoopTimerUPP GetHIDTimerUPP (void)$/;"	f
GetInput	driver/MAC/HID Support/HIDSupport.cpp	/^static void GetInput (void)$/;"	f	file:
GetInputElements	driver/MAC/HID Support/HIDSupport.cpp	/^static Boolean GetInputElements (pRecDevice pDevice)$/;"	f	file:
GetOGLPos	driver/common.cpp	/^point3d GetOGLPos(int x, int y)$/;"	f
GraphQualityParameter	aha/AnnotatedClusterAbstraction.h	/^	enum GraphQualityParameter$/;"	g	namespace:ACAUtil
GraphSearchEnvironment	util/SearchEnvironment.h	/^	GraphSearchEnvironment(graph *_graph) :g(_graph) {  }$/;"	f	class:GraphSearchEnvironment
GraphSearchEnvironment	util/SearchEnvironment.h	/^class GraphSearchEnvironment : public SearchEnvironment$/;"	c
HDRS	apps/Makefile	/^HDRS = $(foreach T, $(APPS), $(wildcard $(T)\/*.h))$/;"	m
HEAP2_H	util/heap2.h	/^#define HEAP2_H$/;"	d
HEAP_H	util/heap.h	/^#define HEAP_H$/;"	d
HIDAddDevice	driver/MAC/HID Support/HID_Utilities.cpp	/^static void HIDAddDevice (pRecDevice *ppListDeviceHead, pRecDevice pNewDevice)$/;"	f	file:
HIDAddElement	driver/MAC/HID Support/HID_Utilities.cpp	/^static void HIDAddElement (CFTypeRef refElement, pRecElement * ppElementCurrent)$/;"	f	file:
HIDBuildDevice	driver/MAC/HID Support/HID_Utilities.cpp	/^static pRecDevice HIDBuildDevice (io_object_t hidDevice)$/;"	f	file:
HIDBuildDeviceList	driver/MAC/HID Support/HID_Utilities.cpp	/^Boolean HIDBuildDeviceList (UInt32 usagePage, UInt32 usage)$/;"	f
HIDBuildMultiDeviceList	driver/MAC/HID Support/HID_Utilities.cpp	/^Boolean HIDBuildMultiDeviceList (UInt32 *pUsagePage, UInt32 *pUsage, UInt32 numDeviceTypes)$/;"	f
HIDCalibrateValue	driver/MAC/HID Support/HID_Utilities.cpp	/^SInt32 HIDCalibrateValue (SInt32 value, pRecElement pElement)$/;"	f
HIDCloseReleaseInterface	driver/MAC/HID Support/HID_Queue_Utilities.cpp	/^IOReturn HIDCloseReleaseInterface (pRecDevice pDevice)$/;"	f
HIDCompareUpdateDeviceList	driver/MAC/HID Support/HID_Utilities.cpp	/^static Boolean HIDCompareUpdateDeviceList (pRecDevice *ppListDeviceHead, pRecDevice *ppNewDeviceList)$/;"	f	file:
HIDConfigureAction	driver/MAC/HID Support/HID_Config_Utilities.cpp	/^unsigned char HIDConfigureAction (pRecDevice * ppDevice, pRecElement * ppElement, float timeout)$/;"	f
HIDConfigureSingleDeviceAction	driver/MAC/HID Support/HID_Config_Utilities.cpp	/^unsigned char HIDConfigureSingleDeviceAction (pRecDevice pDevice, pRecElement * ppElement, float timeout)$/;"	f
HIDCountCurrentDevices	driver/MAC/HID Support/HID_Utilities.cpp	/^static UInt32 HIDCountCurrentDevices (pRecDevice pDeviceList)$/;"	f	file:
HIDCountDeviceElements	driver/MAC/HID Support/HID_Utilities.cpp	/^UInt32 HIDCountDeviceElements (pRecDevice pDevice, HIDElementTypeMask typeMask)$/;"	f
HIDCountDevices	driver/MAC/HID Support/HID_Utilities.cpp	/^UInt32 HIDCountDevices (void)$/;"	f
HIDCreateMultiTypeDeviceList	driver/MAC/HID Support/HID_Utilities.cpp	/^static pRecDevice HIDCreateMultiTypeDeviceList (UInt32 *usagePage, UInt32 *usage, UInt32 numDeviceTypes)$/;"	f	file:
HIDCreateOpenDeviceInterface	driver/MAC/HID Support/HID_Queue_Utilities.cpp	/^IOReturn HIDCreateOpenDeviceInterface (io_object_t hidDevice, pRecDevice pDevice)$/;"	f
HIDCreateQueue	driver/MAC/HID Support/HID_Queue_Utilities.cpp	/^static IOReturn HIDCreateQueue (pRecDevice pDevice)$/;"	f	file:
HIDCreateSingleTypeDeviceList	driver/MAC/HID Support/HID_Utilities.cpp	/^static pRecDevice HIDCreateSingleTypeDeviceList (io_iterator_t hidObjectIterator)$/;"	f	file:
HIDDequeueDevice	driver/MAC/HID Support/HID_Queue_Utilities.cpp	/^unsigned long  HIDDequeueDevice (pRecDevice pDevice)$/;"	f
HIDDequeueElement	driver/MAC/HID Support/HID_Queue_Utilities.cpp	/^unsigned long  HIDDequeueElement (pRecDevice pDevice, pRecElement pElement)$/;"	f
HIDDisposeDevice	driver/MAC/HID Support/HID_Utilities.cpp	/^static pRecDevice HIDDisposeDevice (pRecDevice *ppDevice)$/;"	f	file:
HIDDisposeDeviceElements	driver/MAC/HID Support/HID_Utilities.cpp	/^static void HIDDisposeDeviceElements (pRecElement pElement)$/;"	f	file:
HIDDisposeReleaseQueue	driver/MAC/HID Support/HID_Queue_Utilities.cpp	/^static IOReturn HIDDisposeReleaseQueue (pRecDevice pDevice)$/;"	f	file:
HIDDumpDevice	driver/MAC/HID Support/HID_Utilities.cpp	/^void HIDDumpDevice (pRecDevice pDevice)$/;"	f
HIDDumpDeviceList	driver/MAC/HID Support/HID_Utilities.cpp	/^void HIDDumpDeviceList (pRecDevice pDeviceList)$/;"	f
HIDElementTypeMask	driver/MAC/HID Support/HID_Utilities.h	/^enum HIDElementTypeMask$/;"	g
HIDElementTypeMask	driver/MAC/HID Support/HID_Utilities.h	/^typedef enum HIDElementTypeMask HIDElementTypeMask;$/;"	t	typeref:enum:HIDElementTypeMask
HIDElementTypeMask	driver/MAC/HID Support/HID_Utilities_External.h	/^enum HIDElementTypeMask$/;"	g
HIDElementTypeMask	driver/MAC/HID Support/HID_Utilities_External.h	/^typedef enum HIDElementTypeMask HIDElementTypeMask;$/;"	t	typeref:enum:HIDElementTypeMask
HIDFindDeviceInList	driver/MAC/HID Support/HID_Utilities.cpp	/^static Boolean HIDFindDeviceInList (pRecDevice pDeviceList, pRecDevice pFindDevice)$/;"	f	file:
HIDGetCollectionElements	driver/MAC/HID Support/HID_Utilities.cpp	/^static void HIDGetCollectionElements (CFMutableDictionaryRef deviceProperties, pRecElement *ppCurrentCollection)$/;"	f	file:
HIDGetDeviceElement	driver/MAC/HID Support/HID_Utilities.cpp	/^static pRecElement HIDGetDeviceElement (pRecElement pElement, HIDElementTypeMask typeMask)$/;"	f	file:
HIDGetDeviceInfo	driver/MAC/HID Support/HID_Utilities.cpp	/^static void HIDGetDeviceInfo (io_object_t hidDevice, CFMutableDictionaryRef hidProperties, pRecDevice pDevice)$/;"	f	file:
HIDGetElementConfig	driver/MAC/HID Support/HID_Config_Utilities.cpp	/^long HIDGetElementConfig (pRecSaveHID pConfigRec, pRecDevice * ppDevice, pRecElement * ppElement)$/;"	f
HIDGetElementInfo	driver/MAC/HID Support/HID_Utilities.cpp	/^static void HIDGetElementInfo (CFTypeRef refElement, pRecElement pElement)$/;"	f	file:
HIDGetElementValue	driver/MAC/HID Support/HID_Queue_Utilities.cpp	/^long HIDGetElementValue (pRecDevice pDevice, pRecElement pElement)$/;"	f
HIDGetElements	driver/MAC/HID Support/HID_Utilities.cpp	/^static void HIDGetElements (CFTypeRef refElementCurrent, pRecElement *ppCurrentElement)$/;"	f	file:
HIDGetElementsCFArrayHandler	driver/MAC/HID Support/HID_Utilities.cpp	/^static void HIDGetElementsCFArrayHandler (const void * value, void * parameter)$/;"	f	file:
HIDGetEvent	driver/MAC/HID Support/HID_Queue_Utilities.cpp	/^unsigned char HIDGetEvent (pRecDevice pDevice, void * pHIDEvent)$/;"	f
HIDGetFirstDevice	driver/MAC/HID Support/HID_Utilities.cpp	/^pRecDevice HIDGetFirstDevice (void)$/;"	f
HIDGetFirstDeviceElement	driver/MAC/HID Support/HID_Utilities.cpp	/^pRecElement HIDGetFirstDeviceElement (pRecDevice pDevice, HIDElementTypeMask typeMask)$/;"	f
HIDGetIterator	driver/MAC/HID Support/HID_Utilities.cpp	/^static io_iterator_t HIDGetIterator (const mach_port_t masterPort, UInt32 usagePage, UInt32 usage)$/;"	f	file:
HIDGetNextDevice	driver/MAC/HID Support/HID_Utilities.cpp	/^pRecDevice HIDGetNextDevice (pRecDevice pDevice)$/;"	f
HIDGetNextDeviceElement	driver/MAC/HID Support/HID_Utilities.cpp	/^pRecElement HIDGetNextDeviceElement (pRecElement pElement, HIDElementTypeMask typeMask)$/;"	f
HIDGetPreviousDeviceElement	driver/MAC/HID Support/HID_Utilities.cpp	/^pRecElement HIDGetPreviousDeviceElement (pRecElement pElement, HIDElementTypeMask typeMask)$/;"	f
HIDGetTypeName	driver/MAC/HID Support/HID_Utilities.cpp	/^void HIDGetTypeName (unsigned long type, char * cstrName)$/;"	f
HIDGetUsageName	driver/MAC/HID Support/HID_Utilities.cpp	/^void HIDGetUsageName (long valueUsagePage, long valueUsage, char * cstrName)$/;"	f
HIDHaveDeviceList	driver/MAC/HID Support/HID_Utilities.cpp	/^Boolean HIDHaveDeviceList (void)$/;"	f
HIDIsDeviceQueueEmpty	driver/MAC/HID Support/HID_Queue_Utilities.cpp	/^static unsigned char HIDIsDeviceQueueEmpty (pRecDevice pDevice)$/;"	f	file:
HIDMatchElementTypeMask	driver/MAC/HID Support/HID_Utilities.cpp	/^static Boolean HIDMatchElementTypeMask (IOHIDElementType type, HIDElementTypeMask typeMask)$/;"	f	file:
HIDMergeDeviceList	driver/MAC/HID Support/HID_Utilities.cpp	/^static void HIDMergeDeviceList (pRecDevice *ppNewDeviceList, pRecDevice *ppDeviceList)$/;"	f	file:
HIDMoveDevice	driver/MAC/HID Support/HID_Utilities.cpp	/^static pRecDevice HIDMoveDevice (pRecDevice *ppListDeviceHead, pRecDevice pNewDevice, pRecDevice *ppOldListDeviceHead)$/;"	f	file:
HIDQueueDevice	driver/MAC/HID Support/HID_Queue_Utilities.cpp	/^unsigned long  HIDQueueDevice (pRecDevice pDevice)$/;"	f
HIDQueueElement	driver/MAC/HID Support/HID_Queue_Utilities.cpp	/^unsigned long  HIDQueueElement (pRecDevice pDevice, pRecElement pElement)$/;"	f
HIDReleaseAllDeviceQueues	driver/MAC/HID Support/HID_Queue_Utilities.cpp	/^IOReturn HIDReleaseAllDeviceQueues (void)$/;"	f
HIDReleaseDeviceList	driver/MAC/HID Support/HID_Utilities.cpp	/^void HIDReleaseDeviceList (void)$/;"	f
HIDReportError	driver/MAC/HID Support/HID_Error_Handler.cpp	/^void HIDReportError (char * strError)$/;"	f
HIDReportErrorNum	driver/MAC/HID Support/HID_Error_Handler.cpp	/^void HIDReportErrorNum (char * strError, long numError)$/;"	f
HIDRestoreElementConfig	driver/MAC/HID Support/HID_Config_Utilities.cpp	/^long HIDRestoreElementConfig (FILE * fileRef, pRecDevice * ppDevice, pRecElement * ppElement)$/;"	f
HIDSaveElementConfig	driver/MAC/HID Support/HID_Config_Utilities.cpp	/^void HIDSaveElementConfig (FILE * fileRef, pRecDevice pDevice, pRecElement pElement, long actionCookie)$/;"	f
HIDScaleValue	driver/MAC/HID Support/HID_Utilities.cpp	/^SInt32 HIDScaleValue (SInt32 value, pRecElement pElement)$/;"	f
HIDSetElementConfig	driver/MAC/HID Support/HID_Config_Utilities.cpp	/^void HIDSetElementConfig (pRecSaveHID pConfigRec, pRecDevice pDevice, pRecElement pElement, long actionCookie)$/;"	f
HIDSetUpMatchingDictionary	driver/MAC/HID Support/HID_Utilities.cpp	/^static CFMutableDictionaryRef HIDSetUpMatchingDictionary (UInt32 usagePage, UInt32 usage)$/;"	f	file:
HIDTimer	driver/MAC/HID Support/HIDSupport.cpp	/^pascal void HIDTimer (EventLoopTimerRef inTimer, void* )$/;"	f
HIDTopLevelElementHandler	driver/MAC/HID Support/HID_Utilities.cpp	/^static void HIDTopLevelElementHandler (const void * value, void * parameter)$/;"	f	file:
HIDUpdateDeviceList	driver/MAC/HID Support/HID_Utilities.cpp	/^Boolean HIDUpdateDeviceList (UInt32 *pUsagePage, UInt32 *pUsage, UInt32 numDeviceTypes)$/;"	f
HOGHOME	driver/common.cpp	/^char* HOGHOME=0;$/;"	v
HOGHOME	tests/TestConstants.h	/^const string HOGHOME = "\/Users\/alinaharabor\/src\/ahastar\/";$/;"	v
HORIZONTAL	abstraction/clusterAbstraction.h	/^typedef enum{HORIZONTAL,VERTICAL} Orientation;$/;"	e	enum:__anon1
HPASTAR_H	shared/hpaStar.h	/^#define HPASTAR_H$/;"	d
HUMANUNIT_H	shared/humanUnit.h	/^#define HUMANUNIT_H$/;"	d
HaveOpenGLCapsChanged	driver/MAC/macGlCheck.cpp	/^unsigned char HaveOpenGLCapsChanged (GLCaps aDisplayCaps[], $/;"	f
IAnnotatedClusterFactory	aha/AnnotatedClusterFactory.h	/^class IAnnotatedClusterFactory$/;"	c
IndexTable	util/heap2.h	/^	typedef __gnu_cxx::hash_map<OBJ, unsigned int, HashKey, EqKey > IndexTable;$/;"	t	class:heap2
InitHIDInputArray	driver/MAC/HID Support/HIDSupport.cpp	/^static void InitHIDInputArray (void)$/;"	f	file:
InvalidCapabilityParameterException	aha/AnnotatedCluster.h	/^class InvalidCapabilityParameterException : public std::exception$/;"	c
InvalidClearanceParameterException	aha/AnnotatedCluster.h	/^class InvalidClearanceParameterException : public std::exception$/;"	c
InvalidClusterDimensionsException	aha/AnnotatedCluster.h	/^		InvalidClusterDimensionsException(int w, int h, int xo, int yo) { width=w; height=h; xorigin=xo; yorigin=yo; }$/;"	f	class:InvalidClusterDimensionsException
InvalidClusterDimensionsException	aha/AnnotatedCluster.h	/^class InvalidClusterDimensionsException : public std::exception$/;"	c
InvalidClusterOriginCoordinatesException	aha/AnnotatedCluster.h	/^		InvalidClusterOriginCoordinatesException(int xo, int yo) { xorigin=xo; yorigin=yo; }$/;"	f	class:InvalidClusterOriginCoordinatesException
InvalidClusterOriginCoordinatesException	aha/AnnotatedCluster.h	/^class InvalidClusterOriginCoordinatesException : public std::exception$/;"	c
InvalidTransitionWeightException	aha/AnnotatedCluster.h	/^class InvalidTransitionWeightException : public std::exception$/;"	c
InvertGLImage	driver/MAC/mac_main.cpp	/^void InvertGLImage(char *imageData, long imageSize, long rowBytes)$/;"	f
LATEX	papers/Makefile	/^LATEX=pdflatex$/;"	m
LATEX_OPTS	papers/Makefile	/^LATEX_OPTS=-interaction=nonstopmode -halt-on-error$/;"	m
LIBFLAGS	Makefile	/^LIBFLAGS = -Lapps\/libs -L\/usr\/X11R6\/lib64 -L\/usr\/X11R6\/lib -L\/usr\/lib -L$(HOME)\/lib$/;"	m
LIBFLAGS	Makefile	/^LIBFLAGS = -framework Foundation -framework AppKit -Lapps\/libs$/;"	m
LOCAL_PATH	simulation/unitSimulation.h	/^#define LOCAL_PATH$/;"	d
Locs	shared/patrolUnit.h	/^	std::vector<unit *> Locs;$/;"	m	class:patrolUnit
MAPABSTRACTION_H	abstraction/mapAbstraction.h	/^#define MAPABSTRACTION_H$/;"	d
MAPCLIQUEABSTRACTION_H	abstraction/mapCliqueAbstraction.h	/^#define MAPCLIQUEABSTRACTION_H$/;"	d
MAPFLATABSTRACTION_H	abstraction/mapFlatAbstraction.h	/^#define MAPFLATABSTRACTION_H$/;"	d
MAPLINEABSTRACTION_H	abstraction/MapLineAbstraction.h	/^#define MAPLINEABSTRACTION_H$/;"	d
MAPOVERLAY_H	util/mapOverlay.h	/^#define MAPOVERLAY_H$/;"	d
MAPPROVIDERINTERFACE_H	abstraction/mapProvider.h	/^#define MAPPROVIDERINTERFACE_H$/;"	d
MAPQUADTREEABSTRACTION_H	abstraction/mapQuadTreeAbstraction.h	/^#define MAPQUADTREEABSTRACTION_H$/;"	d
MAP_H	util/map.h	/^#define MAP_H$/;"	d
MAXAGENTSIZE	aha/AHAConstants.h	/^const int MAXAGENTSIZE = 2;$/;"	v
MAXINT	util/graph.h	/^#define MAXINT /;"	d
MAXTRIES	aha/ScenarioManager.h	/^	const int MAXTRIES=1000000;$/;"	v
MAX_ENTRANCE_WIDTH	abstraction/clusterAbstraction.h	/^const int MAX_ENTRANCE_WIDTH = 6;$/;"	v
MAX_INT	shared/craStar.cpp	/^const int MAX_INT = 2147483647;$/;"	v
MAX_INT	shared/hpaStar.cpp	/^const int MAX_INT = 2147483647;$/;"	v
MINAGENTSIZE	aha/AHAConstants.h	/^const int MINAGENTSIZE = 1;$/;"	v
Map	util/map.cpp	/^Map::Map(FILE *f)$/;"	f	class:Map
Map	util/map.cpp	/^Map::Map(Map *m)$/;"	f	class:Map
Map	util/map.cpp	/^Map::Map(const char *filename)$/;"	f	class:Map
Map	util/map.cpp	/^Map::Map(long _width, long _height)$/;"	f	class:Map
Map	util/map.cpp	/^Map::Map(std::istringstream &\/*data*\/)$/;"	f	class:Map
Map	util/map.h	/^class Map {$/;"	c
MapChar	driver/MAC/HID Support/HID_Utilities.cpp	/^static char MapChar (char c)$/;"	f	file:
MapLineAbstraction	abstraction/MapLineAbstraction.cpp	/^MapLineAbstraction::MapLineAbstraction(Map *_map, int dist, bool uniform)$/;"	f	class:MapLineAbstraction
MapLineAbstraction	abstraction/MapLineAbstraction.h	/^class MapLineAbstraction : public mapAbstraction {$/;"	c
MapOverlay	util/mapOverlay.cpp	/^MapOverlay::MapOverlay(Map *_m)$/;"	f	class:MapOverlay
MapOverlay	util/mapOverlay.h	/^class MapOverlay {$/;"	c
MapSearchEnvironment	util/SearchEnvironment.h	/^	MapSearchEnvironment(Map *_map) :map(_map) {  }$/;"	f	class:MapSearchEnvironment
MapSearchEnvironment	util/SearchEnvironment.h	/^class MapSearchEnvironment : public SearchEnvironment$/;"	c
NE	shared/craStar.h	/^		NE,$/;"	e	enum:craStar::__anon16
NE	shared/hpaStar.h	/^		NE,$/;"	e	enum:hpaStar::__anon18
NORTH	shared/craStar.h	/^		NORTH,$/;"	e	enum:craStar::__anon16
NORTH	shared/hpaStar.h	/^		NORTH,$/;"	e	enum:hpaStar::__anon18
NUM	papers/Makefile	/^NUM=""$/;"	m
NUMAGENTSIZES	aha/AHAConstants.h	/^const int NUMAGENTSIZES = 2;$/;"	v
NUMCAPABILITIES	aha/AHAConstants.h	/^const int NUMCAPABILITIES = 3;$/;"	v
NUMTERRAINS	aha/AHAConstants.h	/^const int NUMTERRAINS = 2;$/;"	v
NW	shared/craStar.h	/^		NW} Direction;$/;"	e	enum:craStar::__anon16
NW	shared/hpaStar.h	/^		NW} Direction;$/;"	e	enum:hpaStar::__anon18
NoExperimentsGeneratedWhenMapIsNotTraversable	tests/ScenarioManagerTest.cpp	/^void ScenarioManagerTest::NoExperimentsGeneratedWhenMapIsNotTraversable()$/;"	f	class:ScenarioManagerTest
NodeEqual	shared/aStar.h	/^	struct NodeEqual {$/;"	s	namespace:AStar3Util
NodeHasNonZeroAbstractionLevelException	aha/AnnotatedClusterAbstraction.h	/^class NodeHasNonZeroAbstractionLevelException : public std::exception$/;"	c
NodeHash	shared/aStar.h	/^	struct NodeHash {$/;"	s	namespace:AStar3Util
NodeHashTable	util/GenericIDAStar.h	/^typedef __gnu_cxx::hash_map<uint32_t, double> NodeHashTable;$/;"	t
NodeIsAlreadyAssignedToClusterException	aha/AnnotatedCluster.h	/^		NodeIsAlreadyAssignedToClusterException(node* problemNode, AnnotatedCluster* ac) : AnnotatedClusterException(problemNode, ac) {  }$/;"	f	class:NodeIsAlreadyAssignedToClusterException
NodeIsAlreadyAssignedToClusterException	aha/AnnotatedCluster.h	/^class NodeIsAlreadyAssignedToClusterException  : public AnnotatedClusterException$/;"	c
NodeIsHardObstacleException	aha/AnnotatedCluster.h	/^		NodeIsHardObstacleException(node* problemNode, AnnotatedCluster* ac) : AnnotatedClusterException(problemNode, ac) {  }$/;"	f	class:NodeIsHardObstacleException
NodeIsHardObstacleException	aha/AnnotatedCluster.h	/^class NodeIsHardObstacleException : public AnnotatedClusterException$/;"	c
NodeIsNullException	aha/AnnotatedCluster.h	/^		NodeIsNullException() : AnnotatedClusterException(NULL, NULL) { }$/;"	f	class:NodeIsNullException
NodeIsNullException	aha/AnnotatedCluster.h	/^		NodeIsNullException(node* problemNode, AnnotatedCluster* ac) : AnnotatedClusterException(problemNode, ac) {  }$/;"	f	class:NodeIsNullException
NodeIsNullException	aha/AnnotatedCluster.h	/^class NodeIsNullException : public AnnotatedClusterException$/;"	c
NodeLimitABSTRACTION_H	abstraction/NodeLimitAbstraction.h	/^#define NodeLimitABSTRACTION_H$/;"	d
NodeLimitAbstraction	abstraction/NodeLimitAbstraction.cpp	/^NodeLimitAbstraction::NodeLimitAbstraction(Map *_m, int _NodeLimit)$/;"	f	class:NodeLimitAbstraction
NodeLimitAbstraction	abstraction/NodeLimitAbstraction.h	/^class NodeLimitAbstraction : public mapAbstraction {$/;"	c
NodeLookupTable	shared/aStar.h	/^		AStar3Util::NodeHash, AStar3Util::NodeEqual > NodeLookupTable;$/;"	t	namespace:AStar3Util
NodeLookupTable	util/GenericAStar.h	/^	typedef __gnu_cxx::hash_map<uint32_t, GenericAStarUtil::SearchNode > NodeLookupTable;$/;"	t	namespace:GenericAStarUtil
NodeMap	aha/AnnotatedAStar.h	/^  typedef __gnu_cxx::hash_map<int,bool> NodeMap;$/;"	t	namespace:AAStarUtil
ONE	util/map.h	/^static const double ONE = 1.0f;$/;"	v
ONE_OVER_ROOT_TWO	util/map.h	/^static const double ONE_OVER_ROOT_TWO = 1.0\/ROOT_TWO;\/\/0.707106781f;$/;"	v
Orientation	abstraction/clusterAbstraction.h	/^typedef enum{HORIZONTAL,VERTICAL} Orientation;$/;"	t	typeref:enum:__anon1
PATH_H	util/path.h	/^#define PATH_H$/;"	d
PATROLUNIT_H	shared/patrolUnit.h	/^#define PATROLUNIT_H$/;"	d
PI	util/glUtil.h	/^static const double PI = 3.141592653589793238462643;$/;"	v
PID2	util/glUtil.h	/^static const double PID2 = PI\/2;$/;"	v
PQueue	shared/aStar.h	/^		AStar3Util::SearchNodeEqual, AStar3Util::SearchNodeCompare> PQueue;$/;"	t	namespace:AStar3Util
PQueue	util/GenericAStar.h	/^		GenericAStarUtil::SearchNodeEqual, GenericAStarUtil::SearchNodeCompare> PQueue;$/;"	t	namespace:GenericAStarUtil
PRASTAR2_H	shared/praStar2.h	/^#define PRASTAR2_H$/;"	d
PRASTARUNIT_H	shared/praStarUnit.h	/^#define PRASTARUNIT_H$/;"	d
PRASTAR_H	shared/praStar.h	/^#define PRASTAR_H$/;"	d
PS2PDF	papers/Makefile	/^PS2PDF=ps2pdf14$/;"	m
PS2PDF_OPTS	papers/Makefile	/^PS2PDF_OPTS=-dPDFSETTINGS=\/prepress -dSubsetFonts=true -dEmbedAllFonts=true$/;"	m
PathLookupTable	abstraction/clusterAbstraction.h	/^															clusterUtil::EdgeEqual > PathLookupTable;$/;"	t	namespace:clusterUtil
PathableReturnsFalseWhenNoValidPathExistsForLargeSingleTerrainAgent	tests/AnnotatedMapAbstractionTest.cpp	/^void AnnotatedMapAbstractionTest::PathableReturnsFalseWhenNoValidPathExistsForLargeSingleTerrainAgent()$/;"	f	class:AnnotatedMapAbstractionTest
PathableReturnsTrueWhenValidPathExistsForLargeSingleTerrainAgent	tests/AnnotatedMapAbstractionTest.cpp	/^void AnnotatedMapAbstractionTest::PathableReturnsTrueWhenValidPathExistsForLargeSingleTerrainAgent()$/;"	f	class:AnnotatedMapAbstractionTest
Print	driver/common.h	/^	void Print()$/;"	f	class:commandLineCallbackData
Print	util/graph.cpp	/^void edge::Print(ostream& out) const$/;"	f	class:edge
Print	util/graph.cpp	/^void graph::Print(ostream &out) const$/;"	f	class:graph
Print	util/graph.cpp	/^void graph_object::Print(ostream& \/*out*\/) const$/;"	f	class:graph_object
Print	util/graph.cpp	/^void node::Print(ostream& out) const$/;"	f	class:node
RADIUSABSTRACTION_H	abstraction/radiusAbstraction.h	/^#define RADIUSABSTRACTION_H$/;"	d
RERUN	papers/Makefile	/^RERUN = "(There were undefined references|Rerun to get (cross-references|the bars) right)"$/;"	m
RERUNBIB	papers/Makefile	/^RERUNBIB = "No file.*\\.bbl|Citation.*undefined"$/;"	m
RESERVATIONPROVIDER_H	simulation/reservationProvider.h	/^#define RESERVATIONPROVIDER_H$/;"	d
REWARDUNIT_H	shared/rewardUnit.h	/^#define REWARDUNIT_H$/;"	d
ROOT2D2	util/glUtil.h	/^static const double ROOT2D2 = 0.7071067811865475;$/;"	v
ROOT_TWO	util/map.h	/^static const double ROOT_TWO = 1.414213562f;\/\/1.5f?$/;"	v
SCENARIOLOADER_H	shared/scenarioLoader.h	/^#define SCENARIOLOADER_H$/;"	d
SCENARIOMANAGERTEST_H	tests/ScenarioManagerTest.h	/^#define SCENARIOMANAGERTEST_H$/;"	d
SCENARIOMANAGER_H	aha/ScenarioManager.h	/^#define SCENARIOMANAGER_H$/;"	d
SE	shared/craStar.h	/^		SE,$/;"	e	enum:craStar::__anon16
SE	shared/hpaStar.h	/^		SE,$/;"	e	enum:hpaStar::__anon18
SEARCHALGORITHM_H	shared/searchAlgorithm.h	/^#define SEARCHALGORITHM_H$/;"	d
SEARCHENVIRONMENT_H	util/SearchEnvironment.h	/^#define SEARCHENVIRONMENT_H$/;"	d
SHAREDAMAPGROUP_H	shared/sharedAMapGroup.h	/^#define SHAREDAMAPGROUP_H$/;"	d
SHARED_OBJ	Makefile	/^SHARED_OBJ = $(SHARED_SRC:.cpp=.o)$/;"	m
SHARED_SRC	Makefile	/^SHARED_SRC = $(notdir $(wildcard shared\/*.cpp))$/;"	m
SHARED_SRC	apps/apps.mk	/^SHARED_SRC = $(wildcard ..\/shared\/*.cpp)$/;"	m
SHELL	apps/Makefile	/^SHELL = \/bin\/tcsh$/;"	m
SHELL	apps/apps.mk	/^SHELL = \/bin\/tcsh$/;"	m
SIMULATION_OBJ	Makefile	/^SIMULATION_OBJ = $(SIMULATION_SRC:.cpp=.o)$/;"	m
SIMULATION_SRC	Makefile	/^SIMULATION_SRC = $(notdir $(wildcard simulation\/*.cpp))$/;"	m
SIMULATION_SRC	apps/apps.mk	/^SIMULATION_SRC = $(wildcard ..\/simulation\/*.cpp)$/;"	m
SOUTH	shared/craStar.h	/^		SOUTH,$/;"	e	enum:craStar::__anon16
SOUTH	shared/hpaStar.h	/^		SOUTH,$/;"	e	enum:hpaStar::__anon18
SPREADEXECSEARCHALGORITHM_H	shared/spreadExecSearchAlgorithm.h	/^#define SPREADEXECSEARCHALGORITHM_H$/;"	d
SPREADPRASTAR_H	shared/spreadPRAStar.h	/^#define SPREADPRASTAR_H$/;"	d
STATCOLLECTION_H	util/statCollection.h	/^#define STATCOLLECTION_H$/;"	d
SW	shared/craStar.h	/^		SW,$/;"	e	enum:craStar::__anon16
SW	shared/hpaStar.h	/^		SW,$/;"	e	enum:hpaStar::__anon18
ScenarioFileIsNotCreatedWhenNoExperimentsExist	tests/ScenarioManagerTest.cpp	/^void ScenarioManagerTest::ScenarioFileIsNotCreatedWhenNoExperimentsExist()$/;"	f	class:ScenarioManagerTest
ScenarioFileWrittenToDiskAndWellFormatted	tests/ScenarioManagerTest.cpp	/^void ScenarioManagerTest::ScenarioFileWrittenToDiskAndWellFormatted()$/;"	f	class:ScenarioManagerTest
ScenarioLoader	shared/scenarioLoader.cpp	/^ScenarioLoader::ScenarioLoader(const char* fname)$/;"	f	class:ScenarioLoader
ScenarioLoader	shared/scenarioLoader.h	/^class ScenarioLoader{$/;"	c
ScenarioManagerNS	aha/ScenarioManager.h	/^namespace ScenarioManagerNS$/;"	n
ScenarioManagerTest	tests/ScenarioManagerTest.h	/^class ScenarioManagerTest: public CppUnit::TestFixture$/;"	c
SearchEnvironment	util/SearchEnvironment.h	/^class SearchEnvironment$/;"	c
SearchNode	shared/aStar.h	/^		SearchNode(double _fCost=0, double _gCost=0, edge *_e=0, node *curr=0, node *prev=0)$/;"	f	class:AStar3Util::SearchNode
SearchNode	shared/aStar.h	/^	class SearchNode {$/;"	c	namespace:AStar3Util
SearchNode	util/GenericAStar.h	/^		SearchNode(double _fCost=0, double _gCost=0, uint32_t curr=0, uint32_t prev=0)$/;"	f	class:GenericAStarUtil::SearchNode
SearchNode	util/GenericAStar.h	/^		SearchNode(uint32_t curr)$/;"	f	class:GenericAStarUtil::SearchNode
SearchNode	util/GenericAStar.h	/^	class SearchNode {$/;"	c	namespace:GenericAStarUtil
SearchNodeCompare	shared/aStar.h	/^	struct SearchNodeCompare {$/;"	s	namespace:AStar3Util
SearchNodeCompare	util/GenericAStar.h	/^	struct SearchNodeCompare {$/;"	s	namespace:GenericAStarUtil
SearchNodeEqual	shared/aStar.h	/^	struct SearchNodeEqual {$/;"	s	namespace:AStar3Util
SearchNodeEqual	util/GenericAStar.h	/^	struct SearchNodeEqual {$/;"	s	namespace:GenericAStarUtil
SearchNodeHash	shared/aStar.h	/^	struct SearchNodeHash {$/;"	s	namespace:AStar3Util
SearchNodeHash	util/GenericAStar.h	/^	struct SearchNodeHash {$/;"	s	namespace:GenericAStarUtil
SetLighting	driver/common.cpp	/^void SetLighting(unsigned int mode)$/;"	f
SetupHIDInputs	driver/MAC/HID Support/HIDSupport.cpp	/^static Boolean SetupHIDInputs (void)$/;"	f	file:
SmoothType	shared/craStar.h	/^		TWO_BACK} SmoothType;$/;"	t	class:craStar	typeref:enum:craStar::__anon17
SmoothType	shared/hpaStar.h	/^		TWO_BACK} SmoothType;$/;"	t	class:hpaStar	typeref:enum:hpaStar::__anon19
StartHIDInput	driver/MAC/HID Support/HIDSupport.cpp	/^void StartHIDInput (void)$/;"	f
TARGETS	Makefile	/^TARGETS = $(filter-out %~ CVS Makefile %.mk libs,$(notdir $(wildcard apps\/*)))$/;"	m
TARGS	apps/Makefile	/^TARGS = $(foreach x, $(APPS), $(addsuffix .mk, $(x)))$/;"	m
TESTCLUSTERSIZE	tests/TestConstants.h	/^const int TESTCLUSTERSIZE=5;$/;"	v
TESTCONSTANTS_H	tests/TestConstants.h	/^#define TESTCONSTANTS_H$/;"	d
TESTGRAPH_H	tests/TestGraph.h	/^#define TESTGRAPH_H$/;"	d
TESTNODE_H	tests/TestNode.h	/^#define TESTNODE_H$/;"	d
TEXTBOX_H	driver/TextBox.h	/^#define TEXTBOX_H$/;"	d
TOLERANCE	util/fpUtil.h	/^static const double TOLERANCE = 0.000001;    \/\/ floating point tolerance$/;"	v
TWO	util/map.h	/^static const double TWO = 2.0f;$/;"	v
TWOPI	util/glUtil.h	/^static const double TWOPI = 6.283185307179586476925287;$/;"	v
TWO_BACK	shared/craStar.h	/^		TWO_BACK} SmoothType;$/;"	e	enum:craStar::__anon17
TWO_BACK	shared/hpaStar.h	/^		TWO_BACK} SmoothType;$/;"	e	enum:hpaStar::__anon19
TerrainAnnotationsTest	tests/TestNode.cpp	/^void TestNode::TerrainAnnotationsTest()$/;"	f	class:TestNode
TestEntrance	tests/AnnotatedClusterTest.cpp	/^TestEntrance::TestEntrance(int fromx, int fromy, int tox, int toy, int capability, int clearance, int fromClusterId, int toClusterId)$/;"	f	class:TestEntrance
TestEntrance	tests/AnnotatedClusterTest.h	/^class TestEntrance$/;"	c
TestExperiment	tests/ExperimentManager.cpp	/^ExpMgrUtil::TestExperiment::TestExperiment(ExperimentKey key, int sx, int sy, int sterrain, int gx, int gy, int gterrain, int caps, int size, double dist, string mapname, bool pathable)$/;"	f	class:ExpMgrUtil::TestExperiment
TestExperiment	tests/ExperimentManager.h	/^	class TestExperiment$/;"	c	namespace:ExpMgrUtil
TestGraph	tests/TestGraph.h	/^class TestGraph : public CPPUNIT_NS::TestFixture$/;"	c
TestNode	tests/TestNode.h	/^class TestNode : public CPPUNIT_NS::TestFixture$/;"	c
TextBox	driver/TextBox.cpp	/^TextBox::TextBox(char *_text, int _charLine, point3d topLeft, point3d bottomRight, double _duration, bool _deform, bool _scrolling)$/;"	f	class:TextBox
TextBox	driver/TextBox.h	/^class TextBox {$/;"	c
Tile	util/map.cpp	/^Tile::Tile()$/;"	f	class:Tile
Tile	util/map.h	/^class Tile {$/;"	c
Timer	util/timer.cpp	/^Timer::Timer()$/;"	f	class:Timer
Timer	util/timer.h	/^class Timer{$/;"	c
TooManyTriesException	aha/ScenarioManager.h	/^		TooManyTriesException(int _generated, int _target) : generated(_generated), target(_target) { }$/;"	f	class:TooManyTriesException
TooManyTriesException	aha/ScenarioManager.h	/^class TooManyTriesException : public std::exception$/;"	c
UINT32_MAX	util/SearchEnvironment.h	/^#define UINT32_MAX /;"	d
UNITGROUP_H	simulation/unitGroup.h	/^#define UNITGROUP_H$/;"	d
UNITRACESIMULATION_H	simulation/unitRaceSimulation.h	/^#define UNITRACESIMULATION_H$/;"	d
UNITREWARDSIMULATION_H	simulation/unitRewardSimulation.h	/^#define UNITREWARDSIMULATION_H$/;"	d
UNITSIMULATION_H	simulation/unitSimulation.h	/^#define UNITSIMULATION_H$/;"	d
UNITS_H	simulation/unit.h	/^#define UNITS_H$/;"	d
UTIL_OBJ	Makefile	/^UTIL_OBJ = $(UTIL_SRC:.cpp=.o)$/;"	m
UTIL_SRC	Makefile	/^UTIL_SRC = $(notdir $(wildcard util\/*.cpp))$/;"	m
UTIL_SRC	apps/apps.mk	/^UTIL_SRC = $(wildcard ..\/util\/*.cpp)$/;"	m
VCC	apps/Makefile	/^VCC = $(CC)$/;"	m
VCFLG	apps/Makefile	/^VCFLG = $(CFLAGS)$/;"	m
VERSION	simulation/unitSimulation.cpp	/^const float VERSION = 1.0;$/;"	v
VERTICAL	abstraction/clusterAbstraction.h	/^typedef enum{HORIZONTAL,VERTICAL} Orientation;$/;"	e	enum:__anon1
VPATH	Makefile	/^VPATH = aha\/:abstraction\/:driver\/:shared\/:simulation\/:util\/:objs\/:apps\/libs:bin\/$/;"	m
VPATH	apps/Makefile	/^VPATH = libs\/$/;"	m
VPATH	apps/sample.mk	/^VPATH = sample\/:sample\/objs$/;"	m
ValidateAnnotationsTest	tests/AnnotatedMapAbstractionTest.cpp	/^void AnnotatedMapAbstractionTest::ValidateAnnotationsTest() $/;"	f	class:AnnotatedMapAbstractionTest
ValidateMapAbstractionException	aha/AnnotatedCluster.h	/^class ValidateMapAbstractionException : public std::exception$/;"	c
ValidateTransitionEndpointsException	aha/AnnotatedCluster.h	/^		ValidateTransitionEndpointsException(const char* error) : errmsg(error) { };$/;"	f	class:ValidateTransitionEndpointsException
ValidateTransitionEndpointsException	aha/AnnotatedCluster.h	/^class ValidateTransitionEndpointsException : public std::exception$/;"	c
WEST	shared/craStar.h	/^		WEST,$/;"	e	enum:craStar::__anon16
WEST	shared/hpaStar.h	/^		WEST,$/;"	e	enum:hpaStar::__anon18
WIDTH_H	abstraction/width.h	/^#define WIDTH_H$/;"	d
_BITVECTOR_	util/bitVector.h	/^#define _BITVECTOR_$/;"	d
_HID_Config_Utilities_h_	driver/MAC/HID Support/HID_Config_Utilities.h	/^#define _HID_Config_Utilities_h_$/;"	d
_HID_Name_Lookup_h_	driver/MAC/HID Support/HID_Name_Lookup.h	/^#define _HID_Name_Lookup_h_$/;"	d
_HID_Queue_Utilities_h_	driver/MAC/HID Support/HID_Queue_Utilities.h	/^#define _HID_Queue_Utilities_h_$/;"	d
_HID_Utilities_External_h_	driver/MAC/HID Support/HID_Utilities_External.h	/^#define _HID_Utilities_External_h_$/;"	d
_HID_Utilities_Internal_h_	driver/MAC/HID Support/HID_Utilities_Internal.h	/^#define _HID_Utilities_Internal_h_$/;"	d
_HID_Utilities_h_	driver/MAC/HID Support/HID_Utilities.h	/^#define _HID_Utilities_h_$/;"	d
__STDC_CONSTANT_MACROS	util/SearchEnvironment.h	/^#define __STDC_CONSTANT_MACROS$/;"	d
__trackball_h__	driver/trackball.h	/^#define __trackball_h__$/;"	d
_allEdges	util/graph.h	/^  std::vector<edge *> _allEdges;$/;"	m	class:node
_edges	util/graph.h	/^  std::vector<edge *> _edges;$/;"	m	class:graph
_edgesIncoming	util/graph.h	/^  std::vector<edge *> _edgesIncoming;$/;"	m	class:node
_edgesOutgoing	util/graph.h	/^  std::vector<edge *> _edgesOutgoing;$/;"	m	class:node
_elts	util/heap.h	/^  std::vector<graph_object *> _elts;$/;"	m	class:heap
_elts	util/heap2.h	/^  std::vector<OBJ> _elts;$/;"	m	class:heap2
_getDictDouble	driver/MAC/macGlCheck.cpp	/^static double _getDictDouble (CFDictionaryRef refDict, CFStringRef key)$/;"	f	file:
_getDictLong	driver/MAC/macGlCheck.cpp	/^static long _getDictLong (CFDictionaryRef refDict, CFStringRef key)$/;"	f	file:
_nodes	util/graph.h	/^  std::vector<node *> _nodes;$/;"	m	class:graph
a	shared/patrolUnit.h	/^	aStar a;$/;"	m	class:patrolUnit
a	shared/rewardUnit.h	/^	aStar a;$/;"	m	class:rewardSeekingUnit
aMap	abstraction/clusterAbstraction.cpp	/^	graphAbstraction *aMap;$/;"	m	class:ClusterSearchEnvironment	file:
aMap	shared/sharedAMapGroup.h	/^	mapAbstraction *aMap;$/;"	m	class:sharedAMapGroup
aMap	shared/spreadExecSearchAlgorithm.h	/^	graphAbstraction *aMap;$/;"	m	class:spreadExecSearchAlgorithm
aMap	simulation/unitSimulation.h	/^	mapAbstraction *aMap;$/;"	m	class:unitSimulation
aStar	shared/aStar.h	/^	aStar() {}$/;"	f	class:aStar
aStar	shared/aStar.h	/^class aStar : public searchAlgorithm {$/;"	c
aStar2	shared/aStar2.h	/^  aStar2() :praStar() {}$/;"	f	class:aStar2
aStar2	shared/aStar2.h	/^class aStar2 : public praStar {$/;"	c
aStarName	shared/aStar3.h	/^	char aStarName[128];$/;"	m	class:aStarOld
aStarOld	shared/aStar3.cpp	/^aStarOld::aStarOld(double _weight, bool _doPathDraw)$/;"	f	class:aStarOld
aStarOld	shared/aStar3.h	/^class aStarOld : public searchAlgorithm {$/;"	c
aastar	tests/AnnotatedAStarTest.h	/^		AnnotatedAStar* aastar;$/;"	m	class:AnnotatedAStarTest
aastar_mock	tests/ScenarioManagerTest.h	/^		AnnotatedAStarMock* aastar_mock;$/;"	m	class:ScenarioManagerTest
absLevel	shared/aStar.h	/^	int absLevel;$/;"	m	class:aStar
absLevel	shared/craStar.h	/^	int absLevel;$/;"	m	class:craStar
absType	apps/sample/sample.cpp	/^int absType = 3;$/;"	v
absg	tests/AnnotatedClusterTest.h	/^		graph* absg;$/;"	m	class:AnnotatedClusterTest
absg	tests/AnnotatedClusterTest.h	/^		graph* absg;$/;"	m	class:exceptionThrownHelper
abstr	shared/aStar.h	/^	graphAbstraction *abstr;$/;"	m	class:aStar
abstractGraph	abstraction/loadedCliqueAbstraction.cpp	/^graph *loadedCliqueAbstraction::abstractGraph(graph *g)$/;"	f	class:loadedCliqueAbstraction
abstractGraph	abstraction/mapCliqueAbstraction.cpp	/^graph *mapCliqueAbstraction::abstractGraph(graph *g)$/;"	f	class:mapCliqueAbstraction
abstractUniformly	abstraction/MapLineAbstraction.h	/^	bool abstractUniformly;$/;"	m	class:MapLineAbstraction
abstractUniformly	abstraction/mapCliqueAbstraction.h	/^	bool abstractUniformly;$/;"	m	class:mapCliqueAbstraction
abstractUpEdge	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::abstractUpEdge(unsigned int absLevel, edge *e)$/;"	f	class:loadedCliqueAbstraction
abstractUpEdge	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::abstractUpEdge(unsigned int absLevel, edge *e)$/;"	f	class:mapCliqueAbstraction
abstractionBFS	abstraction/NodeLimitAbstraction.cpp	/^void NodeLimitAbstraction::abstractionBFS(node *which, node *parent, int count)$/;"	f	class:NodeLimitAbstraction
abstractionBFS	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::abstractionBFS(node *which, node *parent, int cluster, int numOrigNodes, int numNodesAfter)$/;"	f	class:clusterAbstraction
abstractionBFS	abstraction/mapQuadTreeAbstraction.cpp	/^void mapQuadTreeAbstraction::abstractionBFS(node *which, node *parent, int quadrant) \/\/ depth in edges...should we try literal distance?$/;"	f	class:mapQuadTreeAbstraction
abstractionBFS	abstraction/radiusAbstraction.cpp	/^void radiusAbstraction::abstractionBFS(node *which, node *parent, int depth) \/\/ depth in edges...should we try literal distance?$/;"	f	class:radiusAbstraction
abstractions	abstraction/graphAbstraction.h	/^		std::vector<graph *> abstractions;$/;"	m	class:graphAbstraction
ac	aha/AnnotatedCluster.h	/^		AnnotatedCluster* ac;$/;"	m	class:AnnotatedClusterException
ac	tests/AnnotatedClusterTest.h	/^		AnnotatedCluster* ac; $/;"	m	class:exceptionThrownHelper
ac	tests/AnnotatedClusterTest.h	/^		AnnotatedCluster* ac;$/;"	m	class:AnnotatedClusterTest
aca	tests/AnnotatedClusterAbstractionTest.h	/^		AnnotatedClusterAbstraction *aca;$/;"	m	class:AnnotatedClusterAbstractionTest
aca	tests/AnnotatedClusterTest.h	/^		AnnotatedClusterAbstraction* aca;$/;"	m	class:exceptionThrownHelper
aca_mock	tests/AnnotatedClusterTest.h	/^		AnnotatedClusterAbstractionMock* aca_mock;$/;"	m	class:AnnotatedClusterTest
acamock	tests/AnnotatedHierarchicalAStarTest.h	/^		AnnotatedClusterAbstractionMock* acamock;$/;"	m	class:AnnotatedHierarchicalAStarTest
acf	tests/AnnotatedClusterFactoryTest.h	/^		AnnotatedClusterFactory* acf;$/;"	m	class:AnnotatedClusterFactoryTest
acmap	tests/TestConstants.h	/^const string acmap = HOGHOME+"tests\/testmaps\/annotatedcluster.map";$/;"	v
acmock_factory	tests/AnnotatedClusterAbstractionTest.h	/^		AnnotatedClusterMockFactory* acmock_factory;$/;"	m	class:AnnotatedClusterAbstractionTest
actionCookie	driver/MAC/HID Support/HID_Config_Utilities.h	/^    long actionCookie;$/;"	m	struct:recSaveHID
actionCookie	driver/MAC/HID Support/HID_Utilities_External.h	/^    long actionCookie;$/;"	m	struct:recSaveHID
actionHistory	simulation/unitSimulation.h	/^	std::vector<timeStep> actionHistory;$/;"	m	class:unitInfo
actionRec	driver/MAC/HID Support/HIDSupport.h	/^struct actionRec \/\/ structure to store action device and element mapping and value$/;"	s
actionRec	driver/MAC/HID Support/HIDSupport.h	/^typedef struct actionRec actionRec;$/;"	t	typeref:struct:actionRec
add	util/heap.cpp	/^void heap::add(graph_object *val)$/;"	f	class:heap
add	util/heap2.h	/^void heap2<OBJ, HashKey, EqKey, CmpKey>::add(OBJ val)$/;"	f	class:heap2
addAbsNodes	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::addAbsNodes(graph* g)$/;"	f	class:clusterAbstraction
addCategory	util/statCollection.cpp	/^int statCollection::addCategory(const char *category)$/;"	f	class:statCollection
addCluster	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::addCluster(Cluster c)$/;"	f	class:clusterAbstraction
addCluster	aha/AnnotatedClusterAbstraction.cpp	/^void AnnotatedClusterAbstraction::addCluster(AnnotatedCluster* ac) $/;"	f	class:AnnotatedClusterAbstraction
addEdge	abstraction/MapLineAbstraction.cpp	/^void MapLineAbstraction::addEdge(edge *, unsigned int)$/;"	f	class:MapLineAbstraction
addEdge	abstraction/NodeLimitAbstraction.cpp	/^void NodeLimitAbstraction::addEdge(edge *, unsigned int)$/;"	f	class:NodeLimitAbstraction
addEdge	abstraction/clusterAbstraction.h	/^  void addEdge(edge*, unsigned int) {}$/;"	f	class:clusterAbstraction
addEdge	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::addEdge(edge *, unsigned int)$/;"	f	class:loadedCliqueAbstraction
addEdge	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::addEdge(edge *, unsigned int)$/;"	f	class:mapCliqueAbstraction
addEdge	abstraction/mapFlatAbstraction.cpp	/^void mapFlatAbstraction::addEdge(edge *e, unsigned int)$/;"	f	class:mapFlatAbstraction
addEdge	abstraction/mapQuadTreeAbstraction.cpp	/^void mapQuadTreeAbstraction::addEdge(edge *, unsigned int)$/;"	f	class:mapQuadTreeAbstraction
addEdge	abstraction/radiusAbstraction.cpp	/^void radiusAbstraction::addEdge(edge *, unsigned int)$/;"	f	class:radiusAbstraction
addEdge	aha/AnnotatedMapAbstraction.h	/^		void addEdge(edge*, unsigned int) { \/* need to  implement to add missing edges?? *\/ }$/;"	f	class:AnnotatedMapAbstraction
addEdge	tests/AnnotatedMapAbstractionMock.h	/^		void addEdge(edge*, unsigned int) { \/* need to  implement to add missing edges?? *\/ }$/;"	f	class:AnnotatedMapAbstractionMock
addEdge	util/graph.cpp	/^void graph::addEdge(edge *e)$/;"	f	class:graph
addEdge	util/graph.cpp	/^void node::addEdge(edge *e)$/;"	f	class:node
addEdgeToNode	tests/TestNode.cpp	/^void TestNode::addEdgeToNode(int caps, int clearance, double weight)$/;"	f	class:TestNode
addEdges	abstraction/MapLineAbstraction.cpp	/^void MapLineAbstraction::addEdges(graph *aGraph)$/;"	f	class:MapLineAbstraction
addEdges	abstraction/NodeLimitAbstraction.cpp	/^void NodeLimitAbstraction::addEdges(graph *aGraph)$/;"	f	class:NodeLimitAbstraction
addEdges	abstraction/mapQuadTreeAbstraction.cpp	/^void mapQuadTreeAbstraction::addEdges(graph *aGraph)$/;"	f	class:mapQuadTreeAbstraction
addEdges	abstraction/radiusAbstraction.cpp	/^void radiusAbstraction::addEdges(graph *aGraph)$/;"	f	class:radiusAbstraction
addEndpointsToAbstractGraph	aha/AnnotatedCluster.cpp	/^void AnnotatedCluster::addEndpointsToAbstractGraph(node* from, node* to, AnnotatedClusterAbstraction* aca) $/;"	f	class:AnnotatedCluster
addEndpointsToAbstractGraphShouldAddEachEntranceEndpointToItsCluster	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addEndpointsToAbstractGraphShouldAddEachEntranceEndpointToItsCluster()$/;"	f	class:AnnotatedClusterTest
addEndpointsToAbstractGraphShouldAddTwoNewAbstractNodesToAbstractGraphGivenAPairOfNodesInTheNonAbstractGraph	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addEndpointsToAbstractGraphShouldAddTwoNewAbstractNodesToAbstractGraphGivenAPairOfNodesInTheNonAbstractGraph()$/;"	f	class:AnnotatedClusterTest
addEndpointsToAbstractGraphShouldCreateAbstractNodesWhichHaveTheSameAnnotationsAsParameterNodes	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addEndpointsToAbstractGraphShouldCreateAbstractNodesWhichHaveTheSameAnnotationsAsParameterNodes()$/;"	f	class:AnnotatedClusterTest
addEndpointsToAbstractGraphShouldReuseExistingNodeEndpointsIfADifferentEntranceExistsAtSameLocation	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addEndpointsToAbstractGraphShouldReuseExistingNodeEndpointsIfADifferentEntranceExistsAtSameLocation()$/;"	f	class:AnnotatedClusterTest
addEndpointsToAbstractGraphShouldSetAbstractNodesAsParentsOfNonAbstractNodes	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addEndpointsToAbstractGraphShouldSetAbstractNodesAsParentsOfNonAbstractNodes()$/;"	f	class:AnnotatedClusterTest
addEndpointsToAbstractGraphShouldThrowExceptionIfParameterNodeHaveAnAbstractionLevelNotEqualToZero	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addEndpointsToAbstractGraphShouldThrowExceptionIfParameterNodeHaveAnAbstractionLevelNotEqualToZero()$/;"	f	class:AnnotatedClusterTest
addEndpointsToAbstractGraphShouldThrowExceptionIfParameterNodesAreNotAdjacent	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addEndpointsToAbstractGraphShouldThrowExceptionIfParameterNodesAreNotAdjacent()$/;"	f	class:AnnotatedClusterTest
addEndpointsToAbstractGraphShouldThrowExceptionIfParameterNodesShareTheSameCluster	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addEndpointsToAbstractGraphShouldThrowExceptionIfParameterNodesShareTheSameCluster()$/;"	f	class:AnnotatedClusterTest
addEntrance	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::addEntrance(Entrance e)$/;"	f	class:clusterAbstraction
addEntrance	aha/AnnotatedCluster.cpp	/^void AnnotatedCluster::addEntrance(node* from, node* to, int capability, int clearance, AnnotatedClusterAbstraction* aca) $/;"	f	class:AnnotatedCluster
addEntranceShouldSetEdgeWeightToExactlyOne	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addEntranceShouldSetEdgeWeightToExactlyOne()$/;"	f	class:AnnotatedClusterTest
addEntranceShouldThrowExceptionIfCapabilityClearanceOfFirstParameterNodeIsNotEqualToOrGreaterThanClearanceParameter	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addEntranceShouldThrowExceptionIfCapabilityClearanceOfFirstParameterNodeIsNotEqualToOrGreaterThanClearanceParameter()$/;"	f	class:AnnotatedClusterTest
addEntranceShouldThrowExceptionIfCapabilityClearanceOfSecondParameterNodeIsNotEqualToOrGreaterThanClearanceParameter	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addEntranceShouldThrowExceptionIfCapabilityClearanceOfSecondParameterNodeIsNotEqualToOrGreaterThanClearanceParameter()$/;"	f	class:AnnotatedClusterTest
addEntranceShouldThrowExceptionIfCapabilityParameterIsInvalid	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addEntranceShouldThrowExceptionIfCapabilityParameterIsInvalid()$/;"	f	class:AnnotatedClusterTest
addEntranceShouldThrowExceptionIfClearanceParameterLessThanOrEqualToZero	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addEntranceShouldThrowExceptionIfClearanceParameterLessThanOrEqualToZero()$/;"	f	class:AnnotatedClusterTest
addEntranceShouldThrowExceptionIfFirstParameterNodeIsAHardObstacle	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addEntranceShouldThrowExceptionIfFirstParameterNodeIsAHardObstacle()$/;"	f	class:AnnotatedClusterTest
addEntranceShouldThrowExceptionIfSecondParameterNodeIsAHardObstacle	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addEntranceShouldThrowExceptionIfSecondParameterNodeIsAHardObstacle()$/;"	f	class:AnnotatedClusterTest
addEntranceShouldTruncateClearanceTo_MAXAGENTSIZE_IfLarger	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addEntranceShouldTruncateClearanceTo_MAXAGENTSIZE_IfLarger()$/;"	f	class:AnnotatedClusterTest
addExcludeFilter	util/statCollection.cpp	/^void statCollection::addExcludeFilter(char *category) \/\/ exclude only added categories$/;"	f	class:statCollection
addExperiment	aha/ScenarioManager.h	/^		void addExperiment(Experiment* newexp) { experiments.push_back(newexp); }$/;"	f	class:AbstractScenarioManager
addFilter	util/statCollection.cpp	/^void statCollection::addFilter(char *category)$/;"	f	class:statCollection
addFrameToMovie	driver/MAC/mac_main.cpp	/^void addFrameToMovie(unsigned int which)$/;"	f
addIncludeFilter	util/statCollection.cpp	/^void statCollection::addIncludeFilter(char *category) \/\/ include only added categories$/;"	f	class:statCollection
addMapEdges	abstraction/mapAbstraction.cpp	/^void addMapEdges(Map *m, graph *g, int x, int y)$/;"	f
addMissingEdges	aha/AnnotatedMapAbstraction.cpp	/^void AbstractAnnotatedMapAbstraction::addMissingEdges()$/;"	f	class:AbstractAnnotatedMapAbstraction
addNeighborsToCorridor	shared/aStar.cpp	/^void aStar::addNeighborsToCorridor(graph *_g, node *n, int windowSize)$/;"	f	class:aStar
addNode	abstraction/MapLineAbstraction.cpp	/^void MapLineAbstraction::addNode(node *)$/;"	f	class:MapLineAbstraction
addNode	abstraction/NodeLimitAbstraction.cpp	/^void NodeLimitAbstraction::addNode(node *)$/;"	f	class:NodeLimitAbstraction
addNode	abstraction/clusterAbstraction.cpp	/^void Cluster::addNode(int n)$/;"	f	class:Cluster
addNode	abstraction/clusterAbstraction.h	/^  void addNode(node*) {}$/;"	f	class:clusterAbstraction
addNode	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::addNode(node *)$/;"	f	class:loadedCliqueAbstraction
addNode	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::addNode(node *n)$/;"	f	class:mapCliqueAbstraction
addNode	abstraction/mapFlatAbstraction.cpp	/^void mapFlatAbstraction::addNode(node *n)$/;"	f	class:mapFlatAbstraction
addNode	abstraction/mapQuadTreeAbstraction.cpp	/^void mapQuadTreeAbstraction::addNode(node *)$/;"	f	class:mapQuadTreeAbstraction
addNode	abstraction/radiusAbstraction.cpp	/^void radiusAbstraction::addNode(node *)$/;"	f	class:radiusAbstraction
addNode	aha/AnnotatedCluster.cpp	/^bool AnnotatedCluster::addNode(node* mynode) throw(NodeIsAlreadyAssignedToClusterException, ClusterFullException, NodeIsNullException)$/;"	f	class:AnnotatedCluster
addNode	aha/AnnotatedMapAbstraction.h	/^		void addNode(node*) {}$/;"	f	class:AnnotatedMapAbstraction
addNode	tests/AnnotatedMapAbstractionMock.h	/^		void addNode(node*) {}$/;"	f	class:AnnotatedMapAbstractionMock
addNode	util/graph.cpp	/^int graph::addNode(node *n)$/;"	f	class:graph
addNodeShouldIncrementByOneTotalNodesInCluster	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addNodeShouldIncrementByOneTotalNodesInCluster()$/;"	f	class:AnnotatedClusterTest
addNodeShouldSetTheParameterNodeParentClusterIdEqualToTheCurrentClusterId	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addNodeShouldSetTheParameterNodeParentClusterIdEqualToTheCurrentClusterId()$/;"	f	class:AnnotatedClusterTest
addNodeShouldThrowExceptionWhenClusterIsFull	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addNodeShouldThrowExceptionWhenClusterIsFull()$/;"	f	class:AnnotatedClusterTest
addNodeShouldThrowExceptionWhenNodeParameterIsNull	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addNodeShouldThrowExceptionWhenNodeParameterIsNull()$/;"	f	class:AnnotatedClusterTest
addNodeShouldThrowExceptionWhenParameterNodeIsAssignedToAnotherCluster	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addNodeShouldThrowExceptionWhenParameterNodeIsAssignedToAnotherCluster()$/;"	f	class:AnnotatedClusterTest
addNodeToRepairQ	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::addNodeToRepairQ(node *n)$/;"	f	class:loadedCliqueAbstraction
addNodeToRepairQ	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::addNodeToRepairQ(node *n)$/;"	f	class:mapCliqueAbstraction
addNodes	abstraction/MapLineAbstraction.cpp	/^void MapLineAbstraction::addNodes(graph *g)$/;"	f	class:MapLineAbstraction
addNodes	abstraction/NodeLimitAbstraction.cpp	/^void NodeLimitAbstraction::addNodes(graph *g)$/;"	f	class:NodeLimitAbstraction
addNodes	abstraction/mapQuadTreeAbstraction.cpp	/^void mapQuadTreeAbstraction::addNodes(graph *g)$/;"	f	class:mapQuadTreeAbstraction
addNodes	abstraction/radiusAbstraction.cpp	/^void radiusAbstraction::addNodes(graph *g)$/;"	f	class:radiusAbstraction
addNodesToCluster	aha/AnnotatedCluster.cpp	/^void AnnotatedCluster::addNodesToCluster(AnnotatedClusterAbstraction* aMap)$/;"	f	class:AnnotatedCluster
addNodesToCluster	tests/AnnotatedClusterMock.cpp	/^void AnnotatedClusterMock::addNodesToCluster(AnnotatedClusterAbstraction* aca)$/;"	f	class:AnnotatedClusterMock
addNodesToClusterMocker	tests/AnnotatedClusterMock.h	/^		MOCKPP_NS::ChainableMockMethod<void, AnnotatedClusterAbstraction*> addNodesToClusterMocker;$/;"	m	class:AnnotatedClusterMock
addNodesToClusterShouldAssignAllNodesInAreaMarkedByHeightAndWidthDimensions	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addNodesToClusterShouldAssignAllNodesInAreaMarkedByHeightAndWidthDimensions()$/;"	f	class:AnnotatedClusterTest
addNodesToClusterShouldThrowExceptionWhenMapAbstractionParameterIsNull	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addNodesToClusterShouldThrowExceptionWhenMapAbstractionParameterIsNull()$/;"	f	class:AnnotatedClusterTest
addNodesToParent	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::addNodesToParent(graph *g, node *n, node *parent, int width)$/;"	f	class:loadedCliqueAbstraction
addNodesToParent	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::addNodesToParent(graph *g, node *n, node *parent, int width)$/;"	f	class:mapCliqueAbstraction
addOwner	util/statCollection.cpp	/^int statCollection::addOwner(const char *owner)$/;"	f	class:statCollection
addParent	abstraction/clusterAbstraction.h	/^	virtual void addParent(node* n) { parents.push_back(n); } $/;"	f	class:Cluster
addParent	aha/AnnotatedCluster.cpp	/^void AnnotatedCluster::addParent(node* parentnode, AnnotatedClusterAbstraction* aca)$/;"	f	class:AnnotatedCluster
addParent	tests/AnnotatedClusterMock.cpp	/^void AnnotatedClusterMock::addParent(node* n, AnnotatedClusterAbstraction* aca)$/;"	f	class:AnnotatedClusterMock
addParentShouldAddParameterNodeToAbstaractNodesListInCluster	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addParentShouldAddParameterNodeToAbstaractNodesListInCluster()$/;"	f	class:AnnotatedClusterTest
addParentShouldNotAddAnyNodesAlreadyMarkedAsBelongingToTargetCluster	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addParentShouldNotAddAnyNodesAlreadyMarkedAsBelongingToTargetCluster()$/;"	f	class:AnnotatedClusterTest
addParentShouldThrowExceptionIfParameterNodeIsAlreadyAssignedToAnotherCluster	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addParentShouldThrowExceptionIfParameterNodeIsAlreadyAssignedToAnotherCluster()$/;"	f	class:AnnotatedClusterTest
addParentsShouldCreateEdgesToRepresentAllValidPathsBetweenNewNodeAndExistingClusterEndpoints	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addParentsShouldCreateEdgesToRepresentAllValidPathsBetweenNewNodeAndExistingClusterEndpoints()$/;"	f	class:AnnotatedClusterTest
addPathToCache	aha/AnnotatedClusterAbstraction.cpp	/^void AnnotatedClusterAbstraction::addPathToCache(edge* e, path* p)$/;"	f	class:AnnotatedClusterAbstraction
addPathToCache	shared/patrolUnit.cpp	/^void patrolUnit::addPathToCache(path *p)$/;"	f	class:patrolUnit
addPathToCache	shared/rewardUnit.cpp	/^void rewardSeekingUnit::addPathToCache(path *p)$/;"	f	class:rewardSeekingUnit
addPathToCache	shared/searchUnit.cpp	/^void searchUnit::addPathToCache(path *p)$/;"	f	class:searchUnit
addPathToCache	tests/AnnotatedClusterAbstractionMock.h	/^		virtual void addPathToCache(edge* e, path* p) { delete lastAdded; addPathsToCacheCounter++; lastAdded = p; }$/;"	f	class:AnnotatedClusterAbstractionMock
addPathToCacheShouldDoNothingIfEdgeOrPathParametersAreNull	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::addPathToCacheShouldDoNothingIfEdgeOrPathParametersAreNull()$/;"	f	class:AnnotatedClusterAbstractionTest
addPathToCacheShouldStoreAPathGivenAnEdge	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::addPathToCacheShouldStoreAPathGivenAnEdge()$/;"	f	class:AnnotatedClusterAbstractionTest
addPathsToCacheCounter	tests/AnnotatedClusterAbstractionMock.h	/^		int addPathsToCacheCounter;$/;"	m	class:AnnotatedClusterAbstractionMock
addPatrolLocation	shared/patrolUnit.cpp	/^void patrolUnit::addPatrolLocation(unit *ru)$/;"	f	class:patrolUnit
addRewardLocation	shared/rewardUnit.cpp	/^void rewardSeekingUnit::addRewardLocation(rewardUnit *ru)$/;"	f	class:rewardSeekingUnit
addStat	util/statCollection.cpp	/^void statCollection::addStat(const char *category, const char *owner, double value)$/;"	f	class:statCollection
addStat	util/statCollection.cpp	/^void statCollection::addStat(const char *category, const char *owner, long value)$/;"	f	class:statCollection
addToOpenList	shared/aStar.cpp	/^void aStar::addToOpenList(node *currOpenNode, node *neighbor, edge *e)$/;"	f	class:aStar
addToOpenList	util/GenericAStar.cpp	/^void GenericAStar::addToOpenList(uint32_t currOpenNode, uint32_t neighbor)$/;"	f	class:GenericAStar
addToRotationTrackball	driver/trackball.cpp	/^void addToRotationTrackball (float * dA, float * A)$/;"	f
addTransitionToAbstractGraph	aha/AnnotatedCluster.cpp	/^void AnnotatedCluster::addTransitionToAbstractGraph(node* from, node* to, int capability, int clearance, double weight, AnnotatedClusterAbstraction* aca) $/;"	f	class:AnnotatedCluster
addTransitionToAbstractGraphShouldAddANewPathToTheAnnotatedClusterAbstractionCacheForEachNewlyCreatedEdge	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addTransitionToAbstractGraphShouldAddANewPathToTheAnnotatedClusterAbstractionCacheForEachNewlyCreatedEdge()$/;"	f	class:AnnotatedClusterTest
addTransitionToAbstractGraphShouldConnectAbstractNodesWithANewAnnotatedEdge	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addTransitionToAbstractGraphShouldConnectAbstractNodesWithANewAnnotatedEdge()$/;"	f	class:AnnotatedClusterTest
addTransitionToAbstractGraphShouldReuseExistingEdgeIfOneExists	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addTransitionToAbstractGraphShouldReuseExistingEdgeIfOneExists()$/;"	f	class:AnnotatedClusterTest
addTransitionToAbstractGraphShouldThrowExceptionWhenWeightIsNotGreaterThanZero	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::addTransitionToAbstractGraphShouldThrowExceptionWhenWeightIsNotGreaterThanZero()$/;"	f	class:AnnotatedClusterTest
addTunnel	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::addTunnel(node *n, graph *g, node *newNode)$/;"	f	class:loadedCliqueAbstraction
addTunnel	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::addTunnel(node *n, graph *g, node *newNode)$/;"	f	class:mapCliqueAbstraction
addUnit	simulation/unitGroup.cpp	/^void unitGroup::addUnit(unit *u)$/;"	f	class:unitGroup
addUnit	simulation/unitRaceSimulation.h	/^	void addUnit(unit *u) { allRacesDone = false; unitSimulation::addUnit(u); }$/;"	f	class:unitRaceSimulation
addUnit	simulation/unitRaceSimulation.h	/^	void addUnit(unit *u, bool block)  { allRacesDone = false; unitSimulation::addUnit(u, block); }$/;"	f	class:unitRaceSimulation
addUnit	simulation/unitSimulation.cpp	/^void unitSimulation::addUnit(unit *u)$/;"	f	class:unitSimulation
addUnit	simulation/unitSimulation.cpp	/^void unitSimulation::addUnit(unit *u, bool _blocking)$/;"	f	class:unitSimulation
addUnitGroup	simulation/unitSimulation.cpp	/^void unitSimulation::addUnitGroup(unitGroup *ug)$/;"	f	class:unitSimulation
adjacentCorners	util/map.cpp	/^bool Map::adjacentCorners(long x, long y, tCorner corner) const$/;"	f	class:Map
adjacentEdges	util/map.cpp	/^bool Map::adjacentEdges(long x, long y, tEdge edge) const$/;"	f	class:Map
advanceTime	simulation/unitSimulation.cpp	/^void unitSimulation::advanceTime(double amount)$/;"	f	class:unitSimulation
agent	simulation/unitSimulation.h	/^	unit *agent;$/;"	m	class:unitInfo
agentsize	aha/ScenarioManager.h	/^		int capability, agentsize;$/;"	m	class:AHAExperiment
agentsize	tests/ScenarioManagerTest.h	/^		int agentsize;$/;"	m	class:ScenarioManagerTest
agentsizes	aha/AHAConstants.h	/^const int agentsizes[NUMAGENTSIZES] = {1, 2};$/;"	v
aglContext	driver/common.h	/^	AGLContext aglContext;$/;"	m	struct:recContext
aglPixFmt	driver/common.h	/^	AGLPixelFormat aglPixFmt;$/;"	m	struct:recContext
aglReportError	driver/MAC/mac_main.cpp	/^OSStatus aglReportError(void)$/;"	f
ahastar	tests/AnnotatedHierarchicalAStarTest.h	/^		AnnotatedHierarchicalAStar* ahastar;$/;"	m	class:AnnotatedHierarchicalAStarTest
algName	shared/craStar.h	/^  char algName[30];$/;"	m	class:craStar
algName	shared/hpaStar.h	/^	char algName[30];$/;"	m	class:hpaStar
algName	shared/praStar.h	/^  char algName[30];$/;"	m	class:praStar
algName	shared/praStar2.h	/^  char algName[30];$/;"	m	class:praStar2
algName	shared/spreadPRAStar.h	/^	char algName[30];$/;"	m	class:spreadPRAStar
algorithm	shared/praStarUnit.h	/^	praStar *algorithm;$/;"	m	class:praStarUnit
algorithm	shared/searchUnit.h	/^	searchAlgorithm *algorithm;$/;"	m	class:searchUnit
allRacesDone	simulation/unitRaceSimulation.h	/^	bool allRacesDone;$/;"	m	class:unitRaceSimulation
ama	tests/AnnotatedMapAbstractionTest.h	/^		AnnotatedMapAbstraction *ama;$/;"	m	class:AnnotatedMapAbstractionTest
ama_mock	tests/ScenarioManagerTest.h	/^		AnnotatedMapAbstractionMock* ama_mock;$/;"	m	class:ScenarioManagerTest
amamock	tests/AnnotatedAStarTest.h	/^		AnnotatedMapAbstractionMock* amamock;$/;"	m	class:AnnotatedAStarTest
animate	driver/common.h	/^	bool animate;$/;"	m	struct:recContext
annotateMap	aha/AnnotatedMapAbstraction.cpp	/^void AnnotatedMapAbstraction::annotateMap() $/;"	f	class:AnnotatedMapAbstraction
annotateMap	tests/AnnotatedMapAbstractionMock.cpp	/^void AnnotatedMapAbstractionMock::annotateMap()$/;"	f	class:AnnotatedMapAbstractionMock
annotateNode	aha/AnnotatedMapAbstraction.cpp	/^void AnnotatedMapAbstraction::annotateNode(node* n)$/;"	f	class:AnnotatedMapAbstraction
annotateNode	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::annotateNode(node* n, int t1, int t1c, int t2, int t2c, int t3, int t3c)$/;"	f	class:AnnotatedAStarTest
aperture	driver/common.h	/^	GLdouble aperture; \/\/ camera aperture$/;"	m	struct:__anon7
appEvtHndlr	driver/MAC/mac_main.cpp	/^static pascal OSStatus appEvtHndlr (EventHandlerCallRef myHandler, EventRef event, void* userData)$/;"	f	file:
appendTextToBuffer	driver/MAC/mac_main.cpp	/^void appendTextToBuffer(char *tempStr)$/;"	f
appendTextToBuffer	driver/main.cpp	/^void appendTextToBuffer(char *tempStr)$/;"	f
argument	driver/common.h	/^	const char *argument;$/;"	m	class:commandLineCallbackData
astar	shared/praStar.cpp	/^unsigned int praStar::astar(graph *g, unsigned int source, unsigned int destParent,$/;"	f	class:praStar
asynch	simulation/unitSimulation.h	/^	bool asynch;$/;"	m	class:unitSimulation
averageStatEntries	util/statUtil.cpp	/^double averageStatEntries(statCollection *stats, const char *category, const char *owner)$/;"	f
axis	driver/MAC/HID Support/HID_Utilities.h	/^    long axis;								\/\/ number of axis (calculated, not reported by device)$/;"	m	struct:recDevice
axis	driver/MAC/HID Support/HID_Utilities_External.h	/^    long axis;								\/\/ number of axis (calculated, not reported by device)$/;"	m	struct:recDevice
b	simulation/unit.h	/^	GLfloat r, g, b;$/;"	m	class:unit
b	util/glUtil.h	/^	GLfloat r,g,b;$/;"	m	class:recColor
backTwoNodes	shared/craStar.cpp	/^int craStar::backTwoNodes(int i, std::vector<node*> lookupVal)$/;"	f	class:craStar
backTwoNodes	shared/hpaStar.cpp	/^int hpaStar::backTwoNodes(int i, std::vector<node*> lookup)$/;"	f	class:hpaStar
backup	driver/main.cpp	/^pRecContext backup;$/;"	v
badmap	tests/TestConstants.h	/^const string badmap = HOGHOME+"maps\/local\/demo.map";$/;"	v
billiardBallUnit	simulation/unit.h	/^	billiardBallUnit(int _x, int _y, int _coolOffPeriod, double _probDirChange)$/;"	f	class:billiardBallUnit
billiardBallUnit	simulation/unit.h	/^	billiardBallUnit(int _x, int _y, int _r, int _g, int _b)$/;"	f	class:billiardBallUnit
billiardBallUnit	simulation/unit.h	/^class billiardBallUnit : public unit {$/;"	c
bitVector	util/bitVector.cpp	/^bitVector::bitVector(int _size)$/;"	f	class:bitVector
bitVector	util/bitVector.h	/^class bitVector {$/;"	c
blocking	simulation/unitSimulation.h	/^	bool blocking;		\/\/ this is the default for all units added$/;"	m	class:unitSimulation
blocking	simulation/unitSimulation.h	/^	bool blocking;$/;"	m	class:unitInfo
boldFontList	driver/common.h	/^	GLuint boldFontList;$/;"	m	struct:recContext
br	driver/TextBox.h	/^	point3d tl, br;$/;"	m	class:TextBox
bucket	shared/scenarioLoader.h	/^  int bucket;$/;"	m	class:Experiment
builEntrancesShouldCreateCorrectNumberOfVerticalAndHorizontalTransitionsToOtherClusters	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::builEntrancesShouldCreateCorrectNumberOfVerticalAndHorizontalTransitionsToOtherClusters()$/;"	f	class:AnnotatedClusterTest
buildAbstractPath	shared/craStar.cpp	/^path* craStar::buildAbstractPath(graphAbstraction *aMap, $/;"	f	class:craStar
buildAbstraction	abstraction/MapLineAbstraction.cpp	/^void MapLineAbstraction::buildAbstraction()$/;"	f	class:MapLineAbstraction
buildAbstraction	abstraction/NodeLimitAbstraction.cpp	/^void NodeLimitAbstraction::buildAbstraction()$/;"	f	class:NodeLimitAbstraction
buildAbstraction	abstraction/mapQuadTreeAbstraction.cpp	/^void mapQuadTreeAbstraction::buildAbstraction()$/;"	f	class:mapQuadTreeAbstraction
buildAbstraction	abstraction/radiusAbstraction.cpp	/^void radiusAbstraction::buildAbstraction()$/;"	f	class:radiusAbstraction
buildAbstractions	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::buildAbstractions(graph *_g)$/;"	f	class:loadedCliqueAbstraction
buildAbstractions	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::buildAbstractions()$/;"	f	class:mapCliqueAbstraction
buildClusters	aha/AnnotatedClusterAbstraction.cpp	/^void AnnotatedClusterAbstraction::buildClusters(IAnnotatedClusterFactory* acfactory)$/;"	f	class:AnnotatedClusterAbstraction
buildClusters	tests/AnnotatedClusterAbstractionMock.cpp	/^void AnnotatedClusterAbstractionMock::buildClusters()$/;"	f	class:AnnotatedClusterAbstractionMock
buildClustersMocker	tests/AnnotatedClusterAbstractionMock.h	/^		MOCKPP_NS::ChainableMockMethod<void> buildClustersMocker;$/;"	m	class:AnnotatedClusterAbstractionMock
buildClustersShouldCalculateCorrectClusterSize	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::buildClustersShouldCalculateCorrectClusterSize()$/;"	f	class:AnnotatedClusterAbstractionTest
buildClustersShouldSplitTheMapAreaIntoCorrectNumberOfClusters	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::buildClustersShouldSplitTheMapAreaIntoCorrectNumberOfClusters()$/;"	f	class:AnnotatedClusterAbstractionTest
buildConnectivityGroups	abstraction/mapFlatAbstraction.cpp	/^void mapFlatAbstraction::buildConnectivityGroups()$/;"	f	class:mapFlatAbstraction
buildCorridor	shared/aStar.cpp	/^void aStar::buildCorridor(path *p, int windowSize)$/;"	f	class:aStar
buildEntrances	aha/AnnotatedCluster.cpp	/^void AnnotatedCluster::buildEntrances(AnnotatedClusterAbstraction* aca) throw(AnnotatedClusterAbstractionIsNullException)$/;"	f	class:AnnotatedCluster
buildEntrances	aha/AnnotatedClusterAbstraction.cpp	/^void AnnotatedClusterAbstraction::buildEntrances()$/;"	f	class:AnnotatedClusterAbstraction
buildEntrances	tests/AnnotatedClusterMock.cpp	/^void AnnotatedClusterMock::buildEntrances(AnnotatedClusterAbstraction* aca) throw(AnnotatedClusterAbstractionIsNullException)$/;"	f	class:AnnotatedClusterMock
buildEntrancesMocker	tests/AnnotatedClusterMock.h	/^		MOCKPP_NS::ChainableMockMethod<void, AnnotatedClusterAbstraction*> buildEntrancesMocker;$/;"	m	class:AnnotatedClusterMock
buildEntrancesShouldAskEachClusterToCreateItsOwnEntrances	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::buildEntrancesShouldAskEachClusterToCreateItsOwnEntrances()$/;"	f	class:AnnotatedClusterAbstractionTest
buildEntrancesShouldCreateCorrectNumberOfTransitionsBetweenClustersAndAddTransitionsToAbstractGraph	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::buildEntrancesShouldCreateCorrectNumberOfTransitionsBetweenClustersAndAddTransitionsToAbstractGraph()$/;"	f	class:AnnotatedClusterAbstractionTest
buildEntrancesShouldCreateCorrectNumberOfTransitionsBetweenClustersAndAddTransitionsToAbstractGraphGivenALowQualityAbstraction	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::buildEntrancesShouldCreateCorrectNumberOfTransitionsBetweenClustersAndAddTransitionsToAbstractGraphGivenALowQualityAbstraction()$/;"	f	class:AnnotatedClusterAbstractionTest
buildEntrancesShouldResultInOneCachedPathForEachAbstractEdge	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::buildEntrancesShouldResultInOneCachedPathForEachAbstractEdge()$/;"	f	class:AnnotatedClusterAbstractionTest
buildEntrancesShouldThrowExceptionGivenAnInvalidACAParameter	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::buildEntrancesShouldThrowExceptionGivenAnInvalidACAParameter()$/;"	f	class:AnnotatedClusterTest
buildFontGL	driver/MAC/mac_main.cpp	/^GLuint buildFontGL(AGLContext ctx, GLint fontID, Style face, GLint size)$/;"	f
buildGL	driver/MAC/mac_main.cpp	/^OSStatus buildGL(WindowRef window)$/;"	f
buildGL	driver/main.cpp	/^void buildGL(void)$/;"	f
buildHorizontalEntrances	aha/AnnotatedCluster.cpp	/^void AnnotatedCluster::buildHorizontalEntrances(int curCapability, AnnotatedClusterAbstraction* aca)$/;"	f	class:AnnotatedCluster
buildHorizontalEntrancesShouldCreateOneMaximallySizedEntrancePerContiguousAreaAlongTheHorizontalBorderBetweenTwoClusters	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::buildHorizontalEntrancesShouldCreateOneMaximallySizedEntrancePerContiguousAreaAlongTheHorizontalBorderBetweenTwoClusters()$/;"	f	class:AnnotatedClusterTest
buildHorizontalEntrancesShouldCreateOneTransitionForEachLocalMaximaOfAnEntranceArea	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::buildHorizontalEntrancesShouldCreateOneTransitionForEachLocalMaximaOfAnEntranceArea()$/;"	f	class:AnnotatedClusterTest
buildHorizontalEntrancesShouldCreateTwoTransitionsAtEachEndOfTheEntranceAreaIfAllNodesAlongEachClusterBorderHaveIdenticalClearance	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::buildHorizontalEntrancesShouldCreateTwoTransitionsAtEachEndOfTheEntranceAreaIfAllNodesAlongEachClusterBorderHaveIdenticalClearance()$/;"	f	class:AnnotatedClusterTest
buildHorizontalEntrancesShouldNotAddAnyEntrancesGivenAnInvalidCapabilityParameter	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::buildHorizontalEntrancesShouldNotAddAnyEntrancesGivenAnInvalidCapabilityParameter()$/;"	f	class:AnnotatedClusterTest
buildHorizontalEntrancesShouldSkipClustersWhichHaveNoNeighboursAlongSouthernBorder	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::buildHorizontalEntrancesShouldSkipClustersWhichHaveNoNeighboursAlongSouthernBorder()$/;"	f	class:AnnotatedClusterTest
buildHorizontalEntrancesShouldThrowExceptionGivenAnInvalidACAParameter	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::buildHorizontalEntrancesShouldThrowExceptionGivenAnInvalidACAParameter()$/;"	f	class:AnnotatedClusterTest
buildNextAbstractPath	shared/craStar.cpp	/^path *craStar::buildNextAbstractPath(graphAbstraction *aMap, path *lastPath,$/;"	f	class:craStar
buildNextAbstractPath	shared/praStar2.cpp	/^path *praStar2::buildNextAbstractPath(graphAbstraction *aMap, path *lastPath,$/;"	f	class:praStar2
buildNextAbstractPath	shared/spreadPRAStar.cpp	/^path *spreadPRAStar::buildNextAbstractPath(graphAbstraction *_aMap, path *lastPth,$/;"	f	class:spreadPRAStar
buildNodeIntoParent	abstraction/MapLineAbstraction.cpp	/^void MapLineAbstraction::buildNodeIntoParent(node *n, node *parent)$/;"	f	class:MapLineAbstraction
buildNodeIntoParent	abstraction/NodeLimitAbstraction.cpp	/^void NodeLimitAbstraction::buildNodeIntoParent(node *n, node *parent)$/;"	f	class:NodeLimitAbstraction
buildNodeIntoParent	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::buildNodeIntoParent(node *n, node *parent)$/;"	f	class:clusterAbstraction
buildNodeIntoParent	abstraction/mapQuadTreeAbstraction.cpp	/^void mapQuadTreeAbstraction::buildNodeIntoParent(node *n, node *parent)$/;"	f	class:mapQuadTreeAbstraction
buildNodeIntoParent	abstraction/radiusAbstraction.cpp	/^void radiusAbstraction::buildNodeIntoParent(node *n, node *parent)$/;"	f	class:radiusAbstraction
buildVerticalEntrances	aha/AnnotatedCluster.cpp	/^void AnnotatedCluster::buildVerticalEntrances(int curCapability, AnnotatedClusterAbstraction* aca)$/;"	f	class:AnnotatedCluster
buildVerticalEntrancesShouldCreateOneMaximallySizedEntrancePerContiguousAreaAlongTheVerticalBorderBetweenTwoClusters	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::buildVerticalEntrancesShouldCreateOneMaximallySizedEntrancePerContiguousAreaAlongTheVerticalBorderBetweenTwoClusters()$/;"	f	class:AnnotatedClusterTest
buildVerticalEntrancesShouldCreateOneTransitionForEachLocalMaximaOfAnEntranceArea	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::buildVerticalEntrancesShouldCreateOneTransitionForEachLocalMaximaOfAnEntranceArea()$/;"	f	class:AnnotatedClusterTest
buildVerticalEntrancesShouldNotAddAnyEntrancesGivenAnInvalidCapabilityParameter	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::buildVerticalEntrancesShouldNotAddAnyEntrancesGivenAnInvalidCapabilityParameter()$/;"	f	class:AnnotatedClusterTest
buildVerticalEntrancesShouldSkipClustersWhichHaveNoNeighboursAlongEasternBorder	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::buildVerticalEntrancesShouldSkipClustersWhichHaveNoNeighboursAlongEasternBorder()$/;"	f	class:AnnotatedClusterTest
buildVerticalEntrancesShouldThrowExceptionGivenAnInvalidACAParameter	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::buildVerticalEntrancesShouldThrowExceptionGivenAnInvalidACAParameter()$/;"	f	class:AnnotatedClusterTest
buttons	driver/MAC/HID Support/HID_Utilities.h	/^    long buttons;							\/\/ number of buttons (calculated, not reported by device)$/;"	m	struct:recDevice
buttons	driver/MAC/HID Support/HID_Utilities_External.h	/^    long buttons;							\/\/ number of buttons (calculated, not reported by device)$/;"	m	struct:recDevice
bv	simulation/unitSimulation.h	/^	bitVector *bv;$/;"	m	class:unitSimulation
c4	util/timer.h	/^		struct { uint32_t l, h; } c4;$/;"	m	union:Timer::CycleCounter::__anon27	typeref:struct:Timer::CycleCounter::__anon27::__anon28
c8	util/timer.h	/^		uint64_t c8;$/;"	m	union:Timer::CycleCounter::__anon27
cAStar	shared/craStar.h	/^	corridorAStar cAStar;$/;"	m	class:craStar
cAStar	shared/praStar2.h	/^	corridorAStar cAStar;$/;"	m	class:praStar2
cAStar	shared/spreadPRAStar.h	/^	corridorAStar cAStar;$/;"	m	class:spreadPRAStar
cUnit	tests/CapabilityUnitTest.h	/^		CapabilityUnit* cUnit;$/;"	m	class:CapabilityUnitTest
cache	shared/praStar.h	/^	path **cache;$/;"	m	class:praStar
cache	shared/praStarUnit.h	/^	path *cache;$/;"	m	class:praStarUnit
call	driver/common.h	/^	keyboardCallback call;$/;"	m	class:keyboardCallbackData
camera	driver/common.h	/^	recCamera camera;$/;"	m	struct:recContext
cameraLookAt	driver/common.cpp	/^void cameraLookAt(GLfloat x, GLfloat y, GLfloat z, float cameraSpeed)$/;"	f
cameraMoveTo	driver/common.cpp	/^void cameraMoveTo(GLfloat x, GLfloat y, GLfloat z, float cameraSpeed)$/;"	f
canCrossDiagonally	simulation/unitSimulation.h	/^	bool canCrossDiagonally() { return (!disallowDiagonalCrossingMoves); }$/;"	f	class:unitSimulation
canMove	simulation/unitSimulation.h	/^	virtual bool canMove(node *, node *, double, unit *) { return true;}$/;"	f	class:unitSimulation
canStep	util/map.cpp	/^bool Map::canStep(long x1, long y1, long x2, long y2) const$/;"	f	class:Map
capabilities	aha/AHAConstants.h	/^const int capabilities[NUMCAPABILITIES] = {kGround, kTrees, (kGround|kTrees)};$/;"	v
capability	aha/AnnotatedAStar.h	/^		int capability, clearance; $/;"	m	class:AbstractAnnotatedAStar
capability	aha/ScenarioManager.h	/^		int capability, agentsize;$/;"	m	class:AHAExperiment
capability	tests/AnnotatedClusterTest.h	/^		int fromx, fromy, tox, toy, capability, clearance, fromClusterId, toClusterId;$/;"	m	class:TestEntrance
capability	tests/ScenarioManagerTest.h	/^		int capability;$/;"	m	class:ScenarioManagerTest
capability	util/graph.h	/^	int capability;$/;"	m	class:edge
caps	tests/ExperimentManager.h	/^			int caps; \/\/ agent capabilities; ie. which terrain types are traversable$/;"	m	class:ExpMgrUtil::TestExperiment
captureNextMovieFrame	driver/MAC/mac_main.cpp	/^void captureNextMovieFrame(pRecContext pContextInfo, WindowRef win, double duration)$/;"	f
categories	util/statCollection.h	/^	std::vector<const char *> categories;$/;"	m	class:statCollection
category	util/statCollection.h	/^	int category, owner;$/;"	m	class:stat
cgDisplayID	driver/MAC/macGlCheck.h	/^  CGDirectDisplayID cgDisplayID; \/\/ CG display ID (main identifier)$/;"	m	struct:__anon15
cglDisplayMask	driver/MAC/macGlCheck.h	/^  CGOpenGLDisplayMask cglDisplayMask; \/\/ CGL display mask$/;"	m	struct:__anon15
charLine	driver/TextBox.h	/^	int charLine;$/;"	m	class:TextBox
check	simulation/unitSimulation.h	/^#undef check$/;"	d
check	tests/AnnotatedClusterAbstractionMock.h	/^#undef check$/;"	d
check	tests/AnnotatedClusterMock.h	/^#undef check$/;"	d
check	util/timer.h	/^#undef check$/;"	d
checkAddParentThrowsCorrectException	tests/AnnotatedClusterTest.h	/^		void checkAddParentThrowsCorrectException(node* target)$/;"	f	class:exceptionThrownHelper
checkAndCreateParent	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::checkAndCreateParent(node *which)$/;"	f	class:loadedCliqueAbstraction
checkAndCreateParent	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::checkAndCreateParent(node *which)$/;"	f	class:mapCliqueAbstraction
checkBuildEntrancesThrowsCorrectException	tests/AnnotatedClusterTest.h	/^		void checkBuildEntrancesThrowsCorrectException()$/;"	f	class:exceptionThrownHelper
checkBuildHorizontalEntrancesThrowsCorrectException	tests/AnnotatedClusterTest.h	/^		void checkBuildHorizontalEntrancesThrowsCorrectException(int capability)$/;"	f	class:exceptionThrownHelper
checkBuildVerticalEntrancesThrowsCorrectException	tests/AnnotatedClusterTest.h	/^		void checkBuildVerticalEntrancesThrowsCorrectException(int capability)$/;"	f	class:exceptionThrownHelper
checkNeighborClique	abstraction/loadedCliqueAbstraction.cpp	/^bool loadedCliqueAbstraction::checkNeighborClique(node *child, node *neighbor)$/;"	f	class:loadedCliqueAbstraction
checkNeighborClique	abstraction/mapCliqueAbstraction.cpp	/^bool mapCliqueAbstraction::checkNeighborClique(node *child, node *neighbor)$/;"	f	class:mapCliqueAbstraction
checkNextNode	util/GenericAStar.cpp	/^uint32_t GenericAStar::checkNextNode()$/;"	f	class:GenericAStar
checkNodeAnnotationsAgainstExpectations	tests/AnnotatedMapAbstractionTest.cpp	/^void AnnotatedMapAbstractionTest::checkNodeAnnotationsAgainstExpectations()$/;"	f	class:AnnotatedMapAbstractionTest
checkSingleNodeAnnotations	tests/AnnotatedMapAbstractionTest.cpp	/^void AnnotatedMapAbstractionTest::checkSingleNodeAnnotations(node* n, int x, int y)$/;"	f	class:AnnotatedMapAbstractionTest
checkValidateMapAbstractionThrowsCorrectException	tests/AnnotatedClusterTest.h	/^		void checkValidateMapAbstractionThrowsCorrectException()$/;"	f	class:exceptionThrownHelper
checkValidateTransitionEndpointsThrowsCorrectException	tests/AnnotatedClusterTest.h	/^		void checkValidateTransitionEndpointsThrowsCorrectException(node* from, node* to)$/;"	f	class:exceptionThrownHelper
checkaddEndpointsToAbstractGraphThrowsCorrectException	tests/AnnotatedClusterTest.h	/^		void checkaddEndpointsToAbstractGraphThrowsCorrectException(node* n1, node* n2)$/;"	f	class:exceptionThrownHelper
checkaddEntranceThrowsCorrectException	tests/AnnotatedClusterTest.h	/^		void checkaddEntranceThrowsCorrectException(node* n1, node* n2, int capability, int clearance)$/;"	f	class:exceptionThrownHelper
checkaddTransitionToAbstractGraphThrowsCorrectException	tests/AnnotatedClusterTest.h	/^		void checkaddTransitionToAbstractGraphThrowsCorrectException(node* n1, node* n2, int capability, int clearance, double weight)$/;"	f	class:exceptionThrownHelper
cheight	tests/AnnotatedClusterTest.h	/^		int cwidth, cheight;$/;"	m	class:AnnotatedClusterTest
cleanMemory	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::cleanMemory()$/;"	f	class:loadedCliqueAbstraction
cleanMemory	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::cleanMemory()$/;"	f	class:mapCliqueAbstraction
cleanUpSearch	shared/hpaStar.cpp	/^void hpaStar::cleanUpSearch()$/;"	f	class:hpaStar
clear	util/bitVector.cpp	/^void bitVector::clear()$/;"	f	class:bitVector
clearAllReservations	simulation/unitSimulation.h	/^	virtual void clearAllReservations() {}$/;"	f	class:unitSimulation
clearAllStats	util/statCollection.cpp	/^void statCollection::clearAllStats()$/;"	f	class:statCollection
clearAllUnits	simulation/unitSimulation.cpp	/^void unitSimulation::clearAllUnits()$/;"	f	class:unitSimulation
clearDisplayList	simulation/unit.h	/^	static void clearDisplayList() { if (sphereDispList != 0) glDeleteLists(sphereDispList, 1); sphereDispList = 0; }$/;"	f	class:unit
clearDisplayLists	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::clearDisplayLists()$/;"	f	class:loadedCliqueAbstraction
clearDisplayLists	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::clearDisplayLists()$/;"	f	class:mapCliqueAbstraction
clearExperiments	aha/ScenarioManager.h	/^		void clearExperiments() { experiments.clear(); }$/;"	f	class:AbstractScenarioManager
clearFilters	util/statCollection.cpp	/^void statCollection::clearFilters()$/;"	f	class:statCollection
clearMap	simulation/unitSimulation.h	/^	bool clearMap;$/;"	m	class:unitSimulation
clearMarkedNodes	abstraction/graphAbstraction.cpp	/^void graphAbstraction::clearMarkedNodes()$/;"	f	class:graphAbstraction
clearMarkedNodes	abstraction/mapAbstraction.cpp	/^void mapAbstraction::clearMarkedNodes()$/;"	f	class:mapAbstraction
clearMove	simulation/unitSimulation.h	/^	virtual bool clearMove(node *, node *, double, unit *) { return true; }$/;"	f	class:unitSimulation
clearance	aha/AnnotatedAStar.h	/^		int capability, clearance; $/;"	m	class:AbstractAnnotatedAStar
clearance	tests/AnnotatedClusterTest.h	/^		int fromx, fromy, tox, toy, capability, clearance, fromClusterId, toClusterId;$/;"	m	class:TestEntrance
clearance	util/graph.h	/^	int clearance;$/;"	m	class:edge
clearance	util/graph.h	/^  int clearance[3];$/;"	m	class:node
cliqueAbstractGraph	abstraction/loadedCliqueAbstraction.cpp	/^graph *loadedCliqueAbstraction::cliqueAbstractGraph(graph *g)$/;"	f	class:loadedCliqueAbstraction
cliqueAbstractGraph	abstraction/mapCliqueAbstraction.cpp	/^graph *mapCliqueAbstraction::cliqueAbstractGraph(graph *g)$/;"	f	class:mapCliqueAbstraction
clone	abstraction/MapLineAbstraction.h	/^	mapAbstraction *clone(Map *_m) { return new MapLineAbstraction(_m); }$/;"	f	class:MapLineAbstraction
clone	abstraction/NodeLimitAbstraction.h	/^	mapAbstraction *clone(Map *_m) { return new NodeLimitAbstraction(_m, nodeLimit); }$/;"	f	class:NodeLimitAbstraction
clone	abstraction/clusterAbstraction.h	/^	mapAbstraction* clone(Map* map)$/;"	f	class:clusterAbstraction
clone	abstraction/mapCliqueAbstraction.h	/^	virtual mapAbstraction *clone(Map *_m) { return new mapCliqueAbstraction(_m); }$/;"	f	class:mapCliqueAbstraction
clone	abstraction/mapFlatAbstraction.h	/^	virtual mapAbstraction *clone(Map *_m) { return new mapFlatAbstraction(_m); }$/;"	f	class:mapFlatAbstraction
clone	abstraction/mapQuadTreeAbstraction.h	/^	mapAbstraction *clone(Map *_m) { return new mapQuadTreeAbstraction(_m, sectorSize); }$/;"	f	class:mapQuadTreeAbstraction
clone	abstraction/radiusAbstraction.h	/^	mapAbstraction *clone(Map *_m) { return new radiusAbstraction(_m, radius); }$/;"	f	class:radiusAbstraction
clone	aha/AnnotatedMapAbstraction.h	/^		mapAbstraction* clone(Map *) { return NULL; }$/;"	f	class:AnnotatedMapAbstraction
clone	tests/AnnotatedMapAbstractionMock.h	/^		mapAbstraction *clone(Map *) {}$/;"	f	class:AnnotatedMapAbstractionMock
clone	util/bitVector.cpp	/^bitVector *bitVector::clone()$/;"	f	class:bitVector
clone	util/graph.cpp	/^graph_object *graph::clone() const$/;"	f	class:graph
clone	util/graph.cpp	/^graph_object *node::clone() const$/;"	f	class:node
clone	util/graph.cpp	/^graph_object* edge::clone() const$/;"	f	class:edge
clone	util/map.h	/^	Map *clone() { return new Map(this); }$/;"	f	class:Map
clone	util/path.h	/^	path *clone() { return next?(new path(n, next->clone())):new path(n, next);}$/;"	f	class:path
cloneAll	util/graph.cpp	/^graph *graph::cloneAll() const$/;"	f	class:graph
cloneShouldDeepCopyEdgeAnnotations	tests/EdgeTest.cpp	/^void EdgeTest::cloneShouldDeepCopyEdgeAnnotations()$/;"	f	class:EdgeTest
cloneShouldDeepCopyNodeAndAllAnnotationsExceptParentClusterId	tests/TestNode.cpp	/^void TestNode::cloneShouldDeepCopyNodeAndAllAnnotationsExceptParentClusterId()$/;"	f	class:TestNode
cloneShouldNotDeepCopyEdges	tests/TestNode.cpp	/^void TestNode::cloneShouldNotDeepCopyEdges()$/;"	f	class:TestNode
closedList	shared/aStar.h	/^	AStar3Util::NodeLookupTable openList, closedList;$/;"	m	class:aStar
closedList	util/GenericAStar.h	/^	GenericAStarUtil::NodeLookupTable closedList; \/\/openList$/;"	m	class:GenericAStar
closedListIterNext	util/GenericAStar.cpp	/^uint32_t GenericAStar::closedListIterNext(closedList_iterator& it) const$/;"	f	class:GenericAStar
closedList_iterator	util/GenericAStar.h	/^typedef GenericAStarUtil::NodeLookupTable::const_iterator closedList_iterator;$/;"	t
cluster1	aha/AnnotatedAStar.h	/^		int cluster1, cluster2;$/;"	m	class:AbstractAnnotatedAStar
cluster2	aha/AnnotatedAStar.h	/^		int cluster1, cluster2;$/;"	m	class:AbstractAnnotatedAStar
clusterAbstraction	abstraction/clusterAbstraction.cpp	/^clusterAbstraction::clusterAbstraction(Map *map, int _clusterSize)$/;"	f	class:clusterAbstraction
clusterAbstraction	abstraction/clusterAbstraction.h	/^class clusterAbstraction : public mapAbstraction {$/;"	c
clusterSize	abstraction/clusterAbstraction.h	/^  int clusterSize;$/;"	m	class:clusterAbstraction
clusterUtil	abstraction/clusterAbstraction.h	/^namespace clusterUtil {$/;"	n
clusterid	util/graph.h	/^  int clusterid;$/;"	m	class:node
clusters	abstraction/clusterAbstraction.h	/^  std::vector<Cluster> clusters;$/;"	m	class:clusterAbstraction
clusters	aha/AnnotatedClusterAbstraction.h	/^		std::vector<AnnotatedCluster *> clusters;$/;"	m	class:AnnotatedClusterAbstraction
clustersize	aha/AnnotatedClusterAbstraction.h	/^		int clustersize;$/;"	m	class:AnnotatedClusterAbstraction
clval	tests/TestNode.h	/^	int clval[4];$/;"	m	class:TestNode
collections	driver/MAC/HID Support/HID_Utilities.h	/^	long collections;						\/\/ number of elements of type kIOHIDElementTypeCollection$/;"	m	struct:recDevice
collections	driver/MAC/HID Support/HID_Utilities_External.h	/^	long collections;						\/\/ number of elements of type kIOHIDElementTypeCollection$/;"	m	struct:recDevice
collisionStatus	simulation/unit.h	/^	int collisionStatus;$/;"	m	class:billiardBallUnit
colorMap	util/mapOverlay.h	/^	int colorMap;$/;"	m	class:MapOverlay
colorScheme	driver/common.h	/^	long colorScheme;$/;"	m	struct:recContext
columns	abstraction/clusterAbstraction.h	/^  int columns; \/\/columns of clusters$/;"	m	class:clusterAbstraction
commandLineCallback	driver/common.h	/^typedef int (*commandLineCallback)(char**, int);$/;"	t
commandLineCallbackData	driver/common.h	/^	commandLineCallbackData(commandLineCallback _CLC, const char *_argument,$/;"	f	class:commandLineCallbackData
commandLineCallbackData	driver/common.h	/^class commandLineCallbackData {$/;"	c
commandLineCallbacks	driver/common.cpp	/^static std::vector<commandLineCallbackData *> commandLineCallbacks;$/;"	v	file:
computeClusterPaths	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::computeClusterPaths(graph* g)$/;"	f	class:clusterAbstraction
computeWidth	abstraction/graphAbstraction.cpp	/^int graphAbstraction::computeWidth(node *n)$/;"	f	class:graphAbstraction
connectEntranceEndpoints	aha/AnnotatedCluster.cpp	/^void AnnotatedCluster::connectEntranceEndpoints(node* newendpoint, AnnotatedClusterAbstraction* aca)$/;"	f	class:AnnotatedCluster
connectEntranceEndpointsForAGivenCapabilityAndSize	aha/AnnotatedCluster.cpp	/^void AnnotatedCluster::connectEntranceEndpointsForAGivenCapabilityAndSize(node* newendpoint, node* existingendpoint, int capability, int size, AnnotatedClusterAbstraction* aca)$/;"	f	class:AnnotatedCluster
connectEntranceEndpointsShouldAddAPathToTheAnnotatedClusterAbstractionCacheEachTimeTwoEndpointsAreConnected	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::connectEntranceEndpointsShouldAddAPathToTheAnnotatedClusterAbstractionCacheEachTimeTwoEndpointsAreConnected()$/;"	f	class:AnnotatedClusterTest
connectEntranceEndpointsShouldCalculateFirstTheSetOfShortestPathsWithLargestClearanceGivenALowQualityAbstraction	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::connectEntranceEndpointsShouldCalculateFirstTheSetOfShortestPathsWithLargestClearanceGivenALowQualityAbstraction()$/;"	f	class:AnnotatedClusterTest
connectEntranceEndpointsShouldCalculateTheShortestPathBetweenEachPairOfParentNodesForEachEligibleCapabilityGivenAHighQualityAbstraction	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::connectEntranceEndpointsShouldCalculateTheShortestPathBetweenEachPairOfParentNodesForEachEligibleCapabilityGivenAHighQualityAbstraction()$/;"	f	class:AnnotatedClusterTest
connectedBFS	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::connectedBFS(node *which, node *parent)$/;"	f	class:clusterAbstraction
constructorShouldCreateANewGraphObject	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::constructorShouldCreateANewGraphObject()$/;"	f	class:AnnotatedClusterAbstractionTest
constructorShouldInitialiseClearanceAndCapabilityValuesToZero	tests/EdgeTest.cpp	/^void EdgeTest::constructorShouldInitialiseClearanceAndCapabilityValuesToZero()$/;"	f	class:EdgeTest
constructorShouldThrowExceptionWhenHeightDimensionParameterIsInvalid	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::constructorShouldThrowExceptionWhenHeightDimensionParameterIsInvalid()$/;"	f	class:AnnotatedClusterTest
constructorShouldThrowExceptionWhenWidthDimensionParameterIsInvalid	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::constructorShouldThrowExceptionWhenWidthDimensionParameterIsInvalid()$/;"	f	class:AnnotatedClusterTest
constructorShouldThrowExceptionWhenXOriginParameterIsInvalid	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::constructorShouldThrowExceptionWhenXOriginParameterIsInvalid()$/;"	f	class:AnnotatedClusterTest
constructorShouldThrowExceptionWhenYOriginParameterIsInvalid	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::constructorShouldThrowExceptionWhenYOriginParameterIsInvalid()$/;"	f	class:AnnotatedClusterTest
cookie	driver/MAC/HID Support/HID_Config_Utilities.h	/^    void * cookie;$/;"	m	struct:recSaveHID
cookie	driver/MAC/HID Support/HID_Utilities.h	/^    IOHIDElementCookie cookie;				\/\/ unique value (within device of specific vendorID and productID) which identifies element, will NOT change$/;"	m	struct:recElement
cookie	driver/MAC/HID Support/HID_Utilities_External.h	/^    void * cookie;							\/\/ unique value (within device of specific vendorID and productID) which identifies element, will NOT change$/;"	m	struct:recElement
cookie	driver/MAC/HID Support/HID_Utilities_External.h	/^    void * cookie;$/;"	m	struct:recSaveHID
coolOffPeriod	simulation/unit.h	/^	int coolOffPeriod;$/;"	m	class:billiardBallUnit
corners	util/map.h	/^  long corners[3];$/;"	m	class:halfTile
corridor	abstraction/clusterAbstraction.cpp	/^	std::vector<node *> corridor;$/;"	m	class:ClusterSearchEnvironment	file:
corridor	shared/corridorAStar.h	/^	const std::vector<node *> *corridor;$/;"	m	class:corridorAStar
corridorAStar	shared/corridorAStar.cpp	/^corridorAStar::corridorAStar()$/;"	f	class:corridorAStar
corridorAStar	shared/corridorAStar.h	/^class corridorAStar : public searchAlgorithm {$/;"	c
corridorLevel	abstraction/clusterAbstraction.cpp	/^	int corridorLevel;$/;"	m	class:ClusterSearchEnvironment	file:
count	util/heap.h	/^  int count;$/;"	m	class:heap
count	util/timer.h	/^	uint64_t count() const { return count_.c8; }$/;"	f	struct:Timer::CycleCounter
countEdgesAtDistance	abstraction/graphAbstraction.cpp	/^int graphAbstraction::countEdgesAtDistance(node *child, node *parent, std::vector<int> &dists)$/;"	f	class:graphAbstraction
countStatEntries	util/statUtil.cpp	/^long unsigned countStatEntries(statCollection *stats, const char *category, const char *owner)$/;"	f
count_	util/timer.h	/^	} count_;$/;"	m	struct:Timer::CycleCounter	typeref:union:Timer::CycleCounter::__anon27
craStar	shared/craStar.cpp	/^craStar::craStar()$/;"	f	class:craStar
craStar	shared/craStar.h	/^class craStar : public searchAlgorithm {$/;"	c
createAbstractGraph	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::createAbstractGraph()$/;"	f	class:clusterAbstraction
createCluster	aha/AnnotatedClusterFactory.cpp	/^AnnotatedCluster* AnnotatedClusterFactory::createCluster(int xpos, int ypos, int width, int height)$/;"	f	class:AnnotatedClusterFactory
createCluster	tests/AnnotatedClusterMockFactory.cpp	/^AnnotatedCluster* AnnotatedClusterMockFactory::createCluster(int startx, int starty, int width, int height)$/;"	f	class:AnnotatedClusterMockFactory
createClusterShouldReturnANewInstanceOfAnnotatedCluster	tests/AnnotatedClusterFactoryTest.cpp	/^void AnnotatedClusterFactoryTest::createClusterShouldReturnANewInstanceOfAnnotatedCluster()$/;"	f	class:AnnotatedClusterFactoryTest
createClustersAndEntrances	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::createClustersAndEntrances()$/;"	f	class:clusterAbstraction
createConnectivityGraph	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::createConnectivityGraph()$/;"	f	class:clusterAbstraction
createEntranceNodes	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::createEntranceNodes()$/;"	f	class:AnnotatedClusterTest
createHorizEntrances	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::createHorizEntrances(int start, int end, int latitude, int row, int col)$/;"	f	class:clusterAbstraction
createMenus	driver/main.cpp	/^void createMenus()$/;"	f
createNewWindow	driver/MAC/mac_main.cpp	/^void createNewWindow(void)$/;"	f
createParent	abstraction/MapLineAbstraction.cpp	/^node *MapLineAbstraction::createParent(graph *g, node *n)$/;"	f	class:MapLineAbstraction
createSimulation	apps/sample/sample.cpp	/^void createSimulation(unitSimulation * &unitSim)$/;"	f
createVertEntrances	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::createVertEntrances(int start, int end, int meridian, int row, int col)$/;"	f	class:clusterAbstraction
cstr2pstr	driver/MAC/mac_main.cpp	/^static void cstr2pstr(StringPtr outString, const char *inString)$/;"	f	file:
curexp	tests/AnnotatedAStarMock.h	/^		ExpMgrUtil::TestExperiment* curexp;$/;"	m	class:AnnotatedAStarMock
curexp	tests/AnnotatedMapAbstractionMock.h	/^		ExpMgrUtil::TestExperiment* curexp;$/;"	m	class:AnnotatedMapAbstractionMock
currDist	simulation/unitSimulation.h	/^	double currDist;        \/\/ total distance moved so far$/;"	m	class:unitSimulation
currNode	shared/aStar.h	/^		node *currNode;$/;"	m	class:AStar3Util::SearchNode
currNode	util/GenericAStar.h	/^		uint32_t currNode;$/;"	m	class:GenericAStarUtil::SearchNode
currRound	simulation/unitRaceSimulation.h	/^	int currRound;$/;"	m	class:unitRaceSimulation
currTarget	shared/patrolUnit.h	/^	int currTarget;$/;"	m	class:patrolUnit
currTime	simulation/unitSimulation.h	/^	double currTime, viewTime;$/;"	m	class:unitSimulation
currentTest	tests/AnnotatedClusterMockFactory.h	/^		int currentTest;$/;"	m	class:AnnotatedClusterMockFactory
currx	simulation/unitSimulation.h	/^	int currx, curry;$/;"	m	class:unitInfo
curry	simulation/unitSimulation.h	/^	int currx, curry;$/;"	m	class:unitInfo
cwidth	tests/AnnotatedClusterTest.h	/^		int cwidth, cheight;$/;"	m	class:AnnotatedClusterTest
cycleDisplayMode	simulation/unitGroup.h	/^	virtual void cycleDisplayMode(void) { }$/;"	f	class:unitGroup
cyclemapAbstractionDisplay	simulation/unitSimulation.cpp	/^void unitSimulation::cyclemapAbstractionDisplay()$/;"	f	class:unitSimulation
dList	driver/TextBox.h	/^	GLuint dList;$/;"	m	class:TextBox
dList	util/map.h	/^  GLuint dList;$/;"	m	class:Map
debuginfo	aha/AnnotatedMapAbstraction.h	/^		bool debuginfo;$/;"	m	class:AbstractAnnotatedMapAbstraction
debuginfo	util/graph.h	/^	  bool debuginfo;$/;"	m	class:graph_object
decreaseColorMap	util/mapOverlay.h	/^	void decreaseColorMap() { colorMap--; }$/;"	f	class:MapOverlay
decreaseDisplayALevel	simulation/unitGroup.h	/^	virtual void decreaseDisplayALevel(void) {  }$/;"	f	class:unitGroup
decreaseKey	util/heap.cpp	/^void heap::decreaseKey(graph_object *val)$/;"	f	class:heap
decreaseKey	util/heap2.h	/^void heap2<OBJ, HashKey, EqKey, CmpKey>::decreaseKey(OBJ val)$/;"	f	class:heap2
deform	driver/TextBox.h	/^	bool deform, scrolling;$/;"	m	class:TextBox
degree	util/path.cpp	/^unsigned path::degree()$/;"	f	class:path
deleteFontGL	driver/MAC/mac_main.cpp	/^void deleteFontGL(GLuint fontList)$/;"	f
desc	driver/common.h	/^	const char *desc;$/;"	m	class:commandLineCallbackData
desc	driver/common.h	/^	const char *desc;$/;"	m	class:keyboardCallbackData
destroy	driver/TextBox.cpp	/^void TextBox::destroy()$/;"	f	class:TextBox
deviceDepth	driver/MAC/macGlCheck.h	/^  short deviceDepth; \/\/ pixel depth in bits$/;"	m	struct:__anon15
deviceHeight	driver/MAC/macGlCheck.h	/^  long deviceHeight; \/\/ pixel width$/;"	m	struct:__anon15
deviceOriginX	driver/MAC/macGlCheck.h	/^  long deviceOriginX; \/\/ left location of device (relative to main device)$/;"	m	struct:__anon15
deviceOriginY	driver/MAC/macGlCheck.h	/^  long deviceOriginY; \/\/ upper location of device (relative to main device)$/;"	m	struct:__anon15
deviceRefresh	driver/MAC/macGlCheck.h	/^  short deviceRefresh; \/\/ integer refresh rate in Hz$/;"	m	struct:__anon15
deviceTextureRAM	driver/MAC/macGlCheck.h	/^  long deviceTextureRAM; \/\/ uses current mode (geometry, pixel depth, etc.)$/;"	m	struct:__anon15
deviceVRAM	driver/MAC/macGlCheck.h	/^  long deviceVRAM; \/\/ video memory in bytes$/;"	m	struct:__anon15
deviceWidth	driver/MAC/macGlCheck.h	/^  long deviceWidth; \/\/ pixel width$/;"	m	struct:__anon15
dials	driver/MAC/HID Support/HID_Utilities.h	/^    long dials;								\/\/ number of dials (calculated, not reported by device)$/;"	m	struct:recDevice
dials	driver/MAC/HID Support/HID_Utilities_External.h	/^    long dials;								\/\/ number of dials (calculated, not reported by device)$/;"	m	struct:recDevice
disableTravelLimit	simulation/unitRaceSimulation.h	/^	void disableTravelLimit() { useTravelLimit = false; }$/;"	f	class:unitRaceSimulation
disallowDiagonalCrossingMoves	simulation/unitSimulation.h	/^	bool disallowDiagonalCrossingMoves;$/;"	m	class:unitSimulation
disjunctiveTrialEnd	simulation/unitRaceSimulation.h	/^	bool disjunctiveTrialEnd;$/;"	m	class:unitRaceSimulation
displayID	driver/MAC/macGlCheck.h	/^  unsigned long displayID; \/\/ QD display ID$/;"	m	struct:__anon15
displayList	util/mapOverlay.h	/^  GLuint displayList;$/;"	m	class:MapOverlay
displayLists	abstraction/loadedCliqueAbstraction.h	/^  std::vector<GLuint> displayLists;$/;"	m	class:loadedCliqueAbstraction
displayLists	abstraction/mapCliqueAbstraction.h	/^  std::vector<GLuint> displayLists;$/;"	m	class:mapCliqueAbstraction
displayUnits	simulation/unitSimulation.h	/^	std::vector<unitInfo *> displayUnits;$/;"	m	class:unitSimulation
disposeGL	driver/MAC/mac_main.cpp	/^OSStatus disposeGL(pRecContext pContextInfo)$/;"	f
distBucketDelta	simulation/constants.h	/^const int distBucketDelta = 10;	\/\/ bucket size$/;"	v
distBucketFirst	simulation/constants.h	/^const int distBucketFirst = 10;	\/\/ first bucket: (distBucketFirst-delta,distBucketFirst]$/;"	v
distBucketLast	simulation/constants.h	/^const int distBucketLast = 100;	\/\/ last bucket: (distBucketLast-delta,distBucketLast]$/;"	v
distNumBuckets	simulation/constants.h	/^const int distNumBuckets = (distBucketLast - distBucketFirst) \/ distBucketDelta + 1;$/;"	v
distance	abstraction/graphAbstraction.cpp	/^double graphAbstraction::distance(path *p)$/;"	f	class:graphAbstraction
distance	aha/AnnotatedClusterAbstraction.cpp	/^double AnnotatedClusterAbstraction::distance(path* p)$/;"	f	class:AnnotatedClusterAbstraction
distance	shared/scenarioLoader.h	/^  double distance;$/;"	m	class:Experiment
distance	tests/ExperimentManager.h	/^			double distance; \/\/ actual distance between the start and goal$/;"	m	class:ExpMgrUtil::TestExperiment
distanceShouldCalculateTheWeightOfTheShortestPathBetweenTwoNodes	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::distanceShouldCalculateTheWeightOfTheShortestPathBetweenTwoNodes()$/;"	f	class:AnnotatedClusterAbstractionTest
doIteration	util/GenericIDAStar.cpp	/^double GenericIDAStar::doIteration(SearchEnvironment *env,$/;"	f	class:GenericIDAStar
doKeyboardCallbacks	driver/common.cpp	/^bool doKeyboardCallbacks(pRecContext pContextInfo, unsigned char keyHit, tKeyboardModifier mod)$/;"	f
doKeyboardCommand	driver/common.cpp	/^bool doKeyboardCommand(pRecContext pContextInfo, unsigned char keyHit, bool shift, bool cntrl, bool alt)$/;"	f
doNormal	util/map.cpp	/^void Map::doNormal(tSplit split, halfTile *t, int \/*x*\/, int \/*y*\/)$/;"	f	class:Map
doPathDraw	shared/aStar3.h	/^	bool doPathDraw;$/;"	m	class:aStarOld
doPostTimestepCalc	simulation/unitSimulation.cpp	/^void unitSimulation::doPostTimestepCalc()$/;"	f	class:unitSimulation
doPreTimestepCalc	simulation/unitRaceSimulation.cpp	/^void unitRaceSimulation::doPreTimestepCalc()$/;"	f	class:unitRaceSimulation
doPreTimestepCalc	simulation/unitSimulation.cpp	/^void unitSimulation::doPreTimestepCalc()$/;"	f	class:unitSimulation
doRandomPath	shared/searchAlgorithm.cpp	/^void doRandomPath(graphAbstraction *aMap, searchAlgorithm *sa, bool repeat)$/;"	f
doRefinement	shared/craStar.cpp	/^path *craStar::doRefinement(graphAbstraction *aMap, path* absPath, std::vector<node*> &fromChain, std::vector<node*> &toChain)$/;"	f	class:craStar
doSingleSearchStep	util/GenericAStar.cpp	/^bool GenericAStar::doSingleSearchStep(std::vector<uint32_t> &thePath)$/;"	f	class:GenericAStar
doTimestepCalc	simulation/unitRaceSimulation.cpp	/^void unitRaceSimulation::doTimestepCalc()$/;"	f	class:unitRaceSimulation
doTimestepCalc	simulation/unitSimulation.cpp	/^void unitSimulation::doTimestepCalc()$/;"	f	class:unitSimulation
doVertexColor	util/map.cpp	/^void Map::doVertexColor(tTerrain type, int vHeight, bool darken)$/;"	f	class:Map
done	shared/searchUnit.h	/^	virtual bool done() { return onTarget; }$/;"	f	class:searchUnit
done	shared/sharedAMapGroup.cpp	/^bool sharedAMapGroup::done()$/;"	f	class:sharedAMapGroup
done	simulation/unit.h	/^	virtual bool done() { return true; }$/;"	f	class:unit
done	simulation/unitGroup.cpp	/^bool unitGroup::done()$/;"	f	class:unitGroup
done	simulation/unitRaceSimulation.h	/^	virtual bool done() { return allRacesDone; }$/;"	f	class:unitRaceSimulation
done	simulation/unitSimulation.cpp	/^bool unitSimulation::done()$/;"	f	class:unitSimulation
draw	driver/TextBox.cpp	/^void TextBox::draw()$/;"	f	class:TextBox
drawBlockedSquare	simulation/unitSimulation.cpp	/^void unitSimulation::drawBlockedSquare(int x, int y)$/;"	f	class:unitSimulation
drawBox	util/glUtil.cpp	/^void drawBox(GLfloat xx, GLfloat yy, GLfloat zz, GLfloat rad)$/;"	f
drawCStringGL	driver/MAC/mac_main.cpp	/^void drawCStringGL(char * cstrOut, GLuint fontList)$/;"	f
drawCStringGL	driver/main.cpp	/^void drawCStringGL (char * cstrOut, GLuint fontList)$/;"	f
drawCV	aha/AnnotatedMapAbstraction.h	/^		bool drawCV; $/;"	m	class:AnnotatedMapAbstraction
drawCaps	driver/MAC/drawInfo.h	/^static void drawCaps (pRecContext pContextInfo)$/;"	f
drawCaps	driver/common.h	/^	bool drawCaps;$/;"	m	struct:recContext
drawChar	driver/TextBox.cpp	/^void TextBox::drawChar(char c, point3d where, double height)$/;"	f	class:TextBox
drawClearance	aha/AnnotatedClusterAbstraction.h	/^		bool drawClearance;$/;"	m	class:AnnotatedClusterAbstraction
drawClearanceInfo	aha/AnnotatedMapAbstraction.cpp	/^void AnnotatedMapAbstraction::drawClearanceInfo()$/;"	f	class:AnnotatedMapAbstraction
drawClusters	aha/AnnotatedClusterAbstraction.h	/^		bool drawClusters;$/;"	m	class:AnnotatedClusterAbstraction
drawGL	driver/MAC/mac_main.cpp	/^void drawGL(pRecContext pContextInfo, bool swap)$/;"	f
drawGL	driver/main.cpp	/^void drawGL (pRecContext pContextInfo)$/;"	f
drawGraph	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::drawGraph(graph *g)$/;"	f	class:loadedCliqueAbstraction
drawGraph	abstraction/mapAbstraction.cpp	/^void mapAbstraction::drawGraph(graph *g)$/;"	f	class:mapAbstraction
drawHelp	driver/common.h	/^	bool drawHelp;$/;"	m	struct:recContext
drawInfo	driver/MAC/mac_main.cpp	/^static void drawInfo(pRecContext pContextInfo)$/;"	f	file:
drawInfo	driver/main.cpp	/^static void drawInfo (pRecContext \/*pContextInfo*\/)$/;"	f	file:
drawLand	util/map.h	/^  bool drawLand;$/;"	m	class:Map
drawLandQuickly	util/map.cpp	/^void Map::drawLandQuickly()$/;"	f	class:Map
drawLevelConnections	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::drawLevelConnections(node *n)$/;"	f	class:loadedCliqueAbstraction
drawLevelConnections	abstraction/mapAbstraction.cpp	/^void mapAbstraction::drawLevelConnections(node *n)$/;"	f	class:mapAbstraction
drawLine	driver/TextBox.cpp	/^void TextBox::drawLine(point3d where, int startx, int starty, int offsetx, int offsety, double scale)$/;"	f	class:TextBox
drawPath	shared/aStar3.h	/^	void drawPath(bool _doPathDraw) { doPathDraw = _doPathDraw; }$/;"	f	class:aStarOld
drawPyramid	util/glUtil.cpp	/^void drawPyramid(GLfloat x, GLfloat y, GLfloat z, GLfloat height, GLfloat width)$/;"	f
drawSphere	simulation/unit.cpp	/^void unit::drawSphere(GLdouble _x, GLdouble _y, GLdouble _z, GLdouble tRadius)$/;"	f	class:unit
drawTile	util/map.cpp	/^void Map::drawTile(Tile *t, int x, int y, tDisplay how)$/;"	f	class:Map
drawTriangle	simulation/unit.cpp	/^void unit::drawTriangle(GLdouble _x, GLdouble _y, GLdouble _z, GLdouble tRadius)$/;"	f	class:unit
drawing	driver/common.h	/^	bool drawing;$/;"	m	struct:recContext
duration	driver/MAC/mac_main.cpp	/^	double duration;$/;"	m	class:movieFrame	file:
duration	driver/TextBox.h	/^	double duration;$/;"	m	class:TextBox
e	aha/AnnotatedAStar.h	/^		edge* e;$/;"	m	class:AnnotatedAStar
e	shared/aStar.h	/^		edge *e;$/;"	m	class:AStar3Util::SearchNode
e	tests/AnnotatedHierarchicalAStarTest.h	/^		edge *e;$/;"	m	class:AnnotatedHierarchicalAStarTest
e	tests/EdgeTest.h	/^		edge* e;$/;"	m	class:EdgeTest
e	tests/TestNode.h	/^	edge* e;$/;"	m	class:TestNode
e1	tests/AnnotatedClusterAbstractionTest.h	/^		edge *e1, *e2, *intra1, *intra2;$/;"	m	class:AnnotatedClusterAbstractionTest
e1_capability	tests/AnnotatedClusterTest.h	/^		int e1_capability, e1_clearance;$/;"	m	class:AnnotatedClusterTest
e1_clearance	tests/AnnotatedClusterTest.h	/^		int e1_capability, e1_clearance;$/;"	m	class:AnnotatedClusterTest
e1_n1	tests/AnnotatedClusterTest.h	/^		node *e1_n1, *e1_n2;$/;"	m	class:AnnotatedClusterTest
e1_n2	tests/AnnotatedClusterTest.h	/^		node *e1_n1, *e1_n2;$/;"	m	class:AnnotatedClusterTest
e2	tests/AnnotatedClusterAbstractionTest.h	/^		edge *e1, *e2, *intra1, *intra2;$/;"	m	class:AnnotatedClusterAbstractionTest
e2_capability	tests/AnnotatedClusterTest.h	/^		int e2_capability, e2_clearance;$/;"	m	class:AnnotatedClusterTest
e2_clearance	tests/AnnotatedClusterTest.h	/^		int e2_capability, e2_clearance;$/;"	m	class:AnnotatedClusterTest
e2_n1	tests/AnnotatedClusterTest.h	/^		node *e2_n2hardobst, *e2_n1;$/;"	m	class:AnnotatedClusterTest
e2_n2hardobst	tests/AnnotatedClusterTest.h	/^		node *e2_n2hardobst, *e2_n1;$/;"	m	class:AnnotatedClusterTest
e3_capability	tests/AnnotatedClusterTest.h	/^		int e3_capability, e3_clearance;$/;"	m	class:AnnotatedClusterTest
e3_clearance	tests/AnnotatedClusterTest.h	/^		int e3_capability, e3_clearance;$/;"	m	class:AnnotatedClusterTest
e3_n1	tests/AnnotatedClusterTest.h	/^		node *e3_n1, *e3_n2;$/;"	m	class:AnnotatedClusterTest
e3_n2	tests/AnnotatedClusterTest.h	/^		node *e3_n1, *e3_n2;$/;"	m	class:AnnotatedClusterTest
e4_capability	tests/AnnotatedClusterTest.h	/^		int e4_capability, e4_clearance;$/;"	m	class:AnnotatedClusterTest
e4_clearance	tests/AnnotatedClusterTest.h	/^		int e4_capability, e4_clearance;$/;"	m	class:AnnotatedClusterTest
e4_n1	tests/AnnotatedClusterTest.h	/^		node *e4_n1, *e4_n2;$/;"	m	class:AnnotatedClusterTest
e4_n2	tests/AnnotatedClusterTest.h	/^		node *e4_n1, *e4_n2;$/;"	m	class:AnnotatedClusterTest
edge	util/graph.cpp	/^edge::edge(unsigned int f, unsigned int t, double w)$/;"	f	class:edge
edge	util/graph.h	/^class edge : public graph_object {$/;"	c
edgeInVector	abstraction/width.cpp	/^bool edgeInVector(edge* e, vector<edge*> edges)$/;"	f
edgeIterNext	util/graph.cpp	/^edge *graph::edgeIterNext(edge_iterator &edge_iter) const$/;"	f	class:graph
edgeIterNext	util/graph.cpp	/^edge *node::edgeIterNext(edge_iterator &iter) const$/;"	f	class:node
edgeIterNextIncoming	util/graph.cpp	/^edge *node::edgeIterNextIncoming(edge_iterator &iterIncoming) const$/;"	f	class:node
edgeIterNextOutgoing	util/graph.cpp	/^edge *node::edgeIterNextOutgoing(edge_iterator &iterOutgoing) const$/;"	f	class:node
edgeNum	util/graph.h	/^	unsigned int edgeNum;\/\/, label[MAXLABELS];$/;"	m	class:edge
edge_iterator	util/graph.h	/^typedef std::vector<edge *>::const_iterator edge_iterator;$/;"	t
edgewidth	abstraction/edgewidth.h	/^  float edgewidth[81] = {$/;"	v
edgewidth	util/map.cpp	/^  float edgewidth[81] = {$/;"	v
elapsedTime	driver/TextBox.h	/^	double elapsedTime;$/;"	m	class:TextBox
elapsedTime	util/timer.h	/^	double elapsedTime;$/;"	m	class:Timer
eligibleNodes	shared/aStar.h	/^	AStar3Util::Corridor eligibleNodes;$/;"	m	class:aStar
eligibleNodes	util/GenericAStar.h	/^	GenericAStarUtil::Corridor eligibleNodes;$/;"	m	class:GenericAStar
empty	util/heap.cpp	/^bool heap::empty()$/;"	f	class:heap
empty	util/heap2.h	/^bool heap2<OBJ, HashKey, EqKey, CmpKey>::empty()$/;"	f	class:heap2
emptyCorridor	shared/corridorAStar.h	/^	std::vector<node *> emptyCorridor;$/;"	m	class:corridorAStar
enablePrintOutput	util/statCollection.h	/^	void enablePrintOutput(bool pO) { printOutput = pO; }$/;"	f	class:statCollection
end	shared/spreadExecSearchAlgorithm.h	/^	node *start, *end;$/;"	m	class:spreadExecSearchAlgorithm
endChain	shared/spreadPRAStar.h	/^	std::vector<node *> startChain, endChain;$/;"	m	class:spreadPRAStar
endTimer	util/timer.cpp	/^double Timer::endTimer()$/;"	f	class:Timer
endpoint1	aha/AnnotatedCluster.h	/^		node* endpoint1, *endpoint2;$/;"	m	class:EntranceException
endpoint2	aha/AnnotatedCluster.h	/^		node* endpoint1, *endpoint2;$/;"	m	class:EntranceException
enhancedAbstractPathing	shared/praStar2.h	/^	bool enhancedAbstractPathing;$/;"	m	class:praStar2
entrances	abstraction/clusterAbstraction.h	/^  std::vector<Entrance> entrances;$/;"	m	class:clusterAbstraction
env	util/GenericAStar.h	/^	SearchEnvironment *env;$/;"	m	class:GenericAStar
equals	util/bitVector.cpp	/^bool bitVector::equals(bitVector *bv)$/;"	f	class:bitVector
errmsg	aha/AnnotatedCluster.h	/^		const char* errmsg;$/;"	m	class:ValidateTransitionEndpointsException
evaluate	aha/AnnotatedAStar.cpp	/^bool AnnotatedAStar::evaluate(node* current, node* target)$/;"	f	class:AnnotatedAStar
evaluate	aha/AnnotatedHierarchicalAStar.cpp	/^bool AnnotatedHierarchicalAStar::evaluate(node* n, node* target) $/;"	f	class:AnnotatedHierarchicalAStar
evaluate	tests/AnnotatedAStarMock.cpp	/^bool AnnotatedAStarMock::evaluate(node* n, node* target)$/;"	f	class:AnnotatedAStarMock
evaluateMoveEastLST	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::evaluateMoveEastLST()$/;"	f	class:AnnotatedAStarTest
evaluateMoveNorthEastLST	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::evaluateMoveNorthEastLST()$/;"	f	class:AnnotatedAStarTest
evaluateMoveNorthLST	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::evaluateMoveNorthLST()$/;"	f	class:AnnotatedAStarTest
evaluateMoveNorthWestLST	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::evaluateMoveNorthWestLST()$/;"	f	class:AnnotatedAStarTest
evaluateMoveSouthEastLST	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::evaluateMoveSouthEastLST()$/;"	f	class:AnnotatedAStarTest
evaluateMoveSouthLST	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::evaluateMoveSouthLST()$/;"	f	class:AnnotatedAStarTest
evaluateMoveSouthWestLST	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::evaluateMoveSouthWestLST()$/;"	f	class:AnnotatedAStarTest
evaluateMoveToHardObstacle	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::evaluateMoveToHardObstacle()$/;"	f	class:AnnotatedAStarTest
evaluateMoveToNonAdjacentLocation	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::evaluateMoveToNonAdjacentLocation()$/;"	f	class:AnnotatedAStarTest
evaluateMoveToSoftObstacle	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::evaluateMoveToSoftObstacle()$/;"	f	class:AnnotatedAStarTest
evaluateMoveWestLST	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::evaluateMoveWestLST()$/;"	f	class:AnnotatedAStarTest
evaluateShouldReturnFalseIfEdgeBeingTraversedIsNull	tests/AnnotatedHierarchicalAStarTest.cpp	/^void AnnotatedHierarchicalAStarTest::evaluateShouldReturnFalseIfEdgeBeingTraversedIsNull()$/;"	f	class:AnnotatedHierarchicalAStarTest
evaluateShouldReturnFalseIfEdgeDoesNotConnectParameterNodes	tests/AnnotatedHierarchicalAStarTest.cpp	/^void AnnotatedHierarchicalAStarTest::evaluateShouldReturnFalseIfEdgeDoesNotConnectParameterNodes()$/;"	f	class:AnnotatedHierarchicalAStarTest
evaluateShouldReturnFalseIfEitherNodeParameterIsNull	tests/AnnotatedHierarchicalAStarTest.cpp	/^void AnnotatedHierarchicalAStarTest::evaluateShouldReturnFalseIfEitherNodeParameterIsNull()$/;"	f	class:AnnotatedHierarchicalAStarTest
evaluateShouldReturnFalseIfTheEdgeIsNotTraversable	tests/AnnotatedHierarchicalAStarTest.cpp	/^void AnnotatedHierarchicalAStarTest::evaluateShouldReturnFalseIfTheEdgeIsNotTraversable()$/;"	f	class:AnnotatedHierarchicalAStarTest
evaluteShouldReturnTrueIfTheEdgeConnectingTwoParameterNodesIsTraversable	tests/AnnotatedHierarchicalAStarTest.cpp	/^void AnnotatedHierarchicalAStarTest::evaluteShouldReturnTrueIfTheEdgeConnectingTwoParameterNodesIsTraversable()$/;"	f	class:AnnotatedHierarchicalAStarTest
exceptionThrownHelper	tests/AnnotatedClusterTest.h	/^		exceptionThrownHelper() {}$/;"	f	class:exceptionThrownHelper
exceptionThrownHelper	tests/AnnotatedClusterTest.h	/^class exceptionThrownHelper$/;"	c
excludeFilters	util/statCollection.h	/^	std::vector<const char *> excludeFilters;$/;"	m	class:statCollection
expandSearchRadius	shared/craStar.h	/^	bool expandSearchRadius;$/;"	m	class:craStar
expandSearchRadius	shared/praStar.h	/^	bool expandSearchRadius;$/;"	m	class:praStar
expandSearchRadius	shared/praStar2.h	/^	bool expandSearchRadius;$/;"	m	class:praStar2
expandSearchRadius	shared/spreadPRAStar.h	/^	bool expandSearchRadius;$/;"	m	class:spreadPRAStar
experiments	aha/ScenarioManager.h	/^		std::vector<Experiment*> experiments;		$/;"	m	class:AbstractScenarioManager
experiments	shared/scenarioLoader.h	/^  std::vector<Experiment> experiments;$/;"	m	class:ScenarioLoader
explored	shared/sharedAMapGroup.cpp	/^bool sharedAMapGroup::explored(int x, int y)$/;"	f	class:sharedAMapGroup
explored	shared/sharedAMapGroup.cpp	/^bool sharedAMapGroup::explored(unsigned int _node)$/;"	f	class:sharedAMapGroup
expmgr	tests/AnnotatedAStarTest.h	/^		ExperimentManager* expmgr;$/;"	m	class:AnnotatedAStarTest
expmgr	tests/AnnotatedClusterAbstractionTest.h	/^		ExperimentManager* expmgr;$/;"	m	class:AnnotatedClusterAbstractionTest
expmgr	tests/AnnotatedMapAbstractionTest.h	/^		ExperimentManager* expmgr;$/;"	m	class:AnnotatedMapAbstractionTest
expmgr	tests/ScenarioManagerTest.h	/^		ExperimentManager* expmgr;$/;"	m	class:ScenarioManagerTest
expnum	apps/sample/sample.cpp	/^int expnum=0;$/;"	v
exportMovie	driver/MAC/mac_main.cpp	/^void exportMovie() \/\/startRecordingMovie(pRecContext pContextInfo, WindowRef win)$/;"	f
extractBestPath	shared/aStar3.cpp	/^path *aStarOld::extractBestPath(graph *g, unsigned int current)$/;"	f	class:aStarOld
extractBestPath	shared/corridorAStar.cpp	/^path *corridorAStar::extractBestPath(graph *g, unsigned int current)$/;"	f	class:corridorAStar
extractGroupIntoNewNode	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::extractGroupIntoNewNode(node *parent, int group)$/;"	f	class:loadedCliqueAbstraction
extractGroupIntoNewNode	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::extractGroupIntoNewNode(node *parent, int group)$/;"	f	class:mapCliqueAbstraction
extractPathToStart	shared/aStar.cpp	/^path *aStar::extractPathToStart(graph *_g, node *goalNode)$/;"	f	class:aStar
extractPathToStart	util/GenericAStar.cpp	/^void GenericAStar::extractPathToStart(uint32_t goalNode,$/;"	f	class:GenericAStar
fABGR	driver/MAC/macGlCheck.h	/^  bool fABGR; \/\/ GL_EXT_abgr$/;"	m	struct:__anon15
fAccel	driver/common.h	/^	GLfloat fAccel [3];$/;"	m	struct:recContext
fArrayRevComps4Byte	driver/MAC/macGlCheck.h	/^  bool fArrayRevComps4Byte; \/\/ GL_ATI_array_rev_comps_in_4_bytes$/;"	m	struct:__anon15
fBGRA	driver/MAC/macGlCheck.h	/^  bool fBGRA; \/\/ GL_EXT_bgra or 1.2+$/;"	m	struct:__anon15
fBlendColor	driver/MAC/macGlCheck.h	/^  bool fBlendColor; \/\/ GL_EXT_blend_color or GL_ARB_imaging$/;"	m	struct:__anon15
fBlendEqSep	driver/MAC/macGlCheck.h	/^  bool fBlendEqSep; \/\/ GL_ATI_blend_equation_separate$/;"	m	struct:__anon15
fBlendFuncSep	driver/MAC/macGlCheck.h	/^  bool fBlendFuncSep; \/\/ GL_EXT_blend_func_separate or 1.4+$/;"	m	struct:__anon15
fBlendMinMax	driver/MAC/macGlCheck.h	/^  bool fBlendMinMax; \/\/ GL_EXT_blend_minmax or GL_ARB_imaging$/;"	m	struct:__anon15
fBlendSquare	driver/MAC/macGlCheck.h	/^  bool fBlendSquare; \/\/ GL_NV_blend_square or 1.4+$/;"	m	struct:__anon15
fBlendSub	driver/MAC/macGlCheck.h	/^  bool fBlendSub; \/\/ GL_EXT_blend_subtract or GL_ARB_imaging$/;"	m	struct:__anon15
fBlendWeightMinMax	driver/MAC/macGlCheck.h	/^  bool fBlendWeightMinMax; \/\/ GL_ATI_blend_weighted_minmax$/;"	m	struct:__anon15
fCVA	driver/MAC/macGlCheck.h	/^  bool fCVA; \/\/ GL_EXT_compiled_vertex_array$/;"	m	struct:__anon15
fClientStorage	driver/MAC/macGlCheck.h	/^  bool fClientStorage; \/\/ GL_APPLE_client_storage$/;"	m	struct:__anon15
fClipVolHint	driver/MAC/macGlCheck.h	/^  bool fClipVolHint; \/\/ GL_EXT_clip_volume_hint$/;"	m	struct:__anon15
fColorMatrix	driver/MAC/macGlCheck.h	/^  bool fColorMatrix; \/\/ GL_SGI_color_matrix$/;"	m	struct:__anon15
fColorSubtable	driver/MAC/macGlCheck.h	/^  bool fColorSubtable; \/\/ GL_EXT_color_subtable or GL_ARB_imaging$/;"	m	struct:__anon15
fColorTable	driver/MAC/macGlCheck.h	/^  bool fColorTable; \/\/ GL_SGI_color_table or GL_ARB_imaging$/;"	m	struct:__anon15
fCombine3	driver/MAC/macGlCheck.h	/^  bool fCombine3; \/\/ GL_ATI_texture_env_combine3$/;"	m	struct:__anon15
fConvBorderModes	driver/MAC/macGlCheck.h	/^  bool fConvBorderModes; \/\/ GL_HP_convolution_border_modes or GL_ARB_imaging$/;"	m	struct:__anon15
fConvolution	driver/MAC/macGlCheck.h	/^  bool fConvolution; \/\/ GL_EXT_convolution or GL_ARB_imaging$/;"	m	struct:__anon15
fCost	shared/aStar.h	/^		double fCost;$/;"	m	class:AStar3Util::SearchNode
fCost	util/GenericAStar.h	/^		double fCost;$/;"	m	class:GenericAStarUtil::SearchNode
fDepthClamp	driver/MAC/macGlCheck.h	/^  bool fDepthClamp; \/\/ GL_NV_depth_clamp$/;"	m	struct:__anon15
fDepthTex	driver/MAC/macGlCheck.h	/^  bool fDepthTex; \/\/ GL_ARB_depth_texture or 1.4+$/;"	m	struct:__anon15
fDrawRangeElements	driver/MAC/macGlCheck.h	/^  bool fDrawRangeElements; \/\/ GL_EXT_draw_range_elements$/;"	m	struct:__anon15
fElementArray	driver/MAC/macGlCheck.h	/^  bool fElementArray; \/\/ GL_APPLE_element_array$/;"	m	struct:__anon15
fFence	driver/MAC/macGlCheck.h	/^  bool fFence; \/\/ GL_APPLE_fence$/;"	m	struct:__anon15
fFloatPixels	driver/MAC/macGlCheck.h	/^  bool fFloatPixels; \/\/ GL_APPLE_float_pixels$/;"	m	struct:__anon15
fFlushRenderer	driver/MAC/macGlCheck.h	/^  bool fFlushRenderer; \/\/ GL_APPLE_flush_render$/;"	m	struct:__anon15
fFogCoord	driver/MAC/macGlCheck.h	/^  bool fFogCoord; \/\/ GL_EXT_fog_coord$/;"	m	struct:__anon15
fFogDist	driver/MAC/macGlCheck.h	/^  bool fFogDist; \/\/ GL_NV_fog_distance$/;"	m	struct:__anon15
fFragmentProg	driver/MAC/macGlCheck.h	/^  bool fFragmentProg; \/\/ GL_ARB_fragment_program$/;"	m	struct:__anon15
fGenMipmap	driver/MAC/macGlCheck.h	/^  bool fGenMipmap; \/\/ GL_SGIS_generate_mipmap or 1.4+$/;"	m	struct:__anon15
fHistogram	driver/MAC/macGlCheck.h	/^  bool fHistogram; \/\/ GL_EXT_histogram or GL_ARB_imaging$/;"	m	struct:__anon15
fImaging	driver/MAC/macGlCheck.h	/^  bool fImaging; \/\/ GL_ARB_imaging  (not required in 1.2+)$/;"	m	struct:__anon15
fLightMaxExp	driver/MAC/macGlCheck.h	/^  bool fLightMaxExp; \/\/ GL_NV_light_max_exponent$/;"	m	struct:__anon15
fMultiDrawArrays	driver/MAC/macGlCheck.h	/^  bool fMultiDrawArrays; \/\/ GL_EXT_multi_draw_arrays or 1.4+$/;"	m	struct:__anon15
fMultisample	driver/MAC/macGlCheck.h	/^  bool fMultisample; \/\/ GL_ARB_multisample or 1.3+ (Anti-aliasing)$/;"	m	struct:__anon15
fMultisampleFilterHint	driver/MAC/macGlCheck.h	/^  bool fMultisampleFilterHint; \/\/ GL_NV_multisample_filter_hint$/;"	m	struct:__anon15
fMultitexture	driver/MAC/macGlCheck.h	/^  bool fMultitexture; \/\/ GL_ARB_multitexture or 1.3+$/;"	m	struct:__anon15
fPNtriangles	driver/MAC/macGlCheck.h	/^  bool fPNtriangles; \/\/ GL_ATI_pn_triangles or GL_ATIX_pn_triangles$/;"	m	struct:__anon15
fPackedPixels	driver/MAC/macGlCheck.h	/^  bool fPackedPixels; \/\/ GL_APPLE_packed_pixels or 1.2+$/;"	m	struct:__anon15
fPaletteTex	driver/MAC/macGlCheck.h	/^  bool fPaletteTex; \/\/ GL_EXT_paletted_texture$/;"	m	struct:__anon15
fPixelBuffer	driver/MAC/macGlCheck.h	/^  bool fPixelBuffer; \/\/ GL_APPLE_pixel_buffer$/;"	m	struct:__anon15
fPointCull	driver/MAC/macGlCheck.h	/^  bool fPointCull; \/\/ GL_ATI_point_cull_mode$/;"	m	struct:__anon15
fPointParam	driver/MAC/macGlCheck.h	/^  bool fPointParam; \/\/ GL_ARB_point_parameters or 1.4+$/;"	m	struct:__anon15
fPointSprite	driver/MAC/macGlCheck.h	/^  bool fPointSprite; \/\/ GL_NV_point_sprite$/;"	m	struct:__anon15
fRasterPosClip	driver/MAC/macGlCheck.h	/^  bool fRasterPosClip; \/\/ GL_IBM_rasterpos_clip$/;"	m	struct:__anon15
fRegCombiners	driver/MAC/macGlCheck.h	/^  bool fRegCombiners; \/\/ GL_NV_register_combiners$/;"	m	struct:__anon15
fRegCombiners2	driver/MAC/macGlCheck.h	/^  bool fRegCombiners2; \/\/ GL_NV_register_combiners2$/;"	m	struct:__anon15
fRescaleNorm	driver/MAC/macGlCheck.h	/^  bool fRescaleNorm; \/\/ GL_EXT_rescale_normal or 1.2+$/;"	m	struct:__anon15
fRot	driver/common.h	/^	GLfloat fRot [3];$/;"	m	struct:recContext
fSecColor	driver/MAC/macGlCheck.h	/^  bool fSecColor; \/\/ GL_EXT_secondary_color or 1.4+$/;"	m	struct:__anon15
fSepStencil	driver/MAC/macGlCheck.h	/^  bool fSepStencil; \/\/ GL_ATI_separate_stencil$/;"	m	struct:__anon15
fShadow	driver/MAC/macGlCheck.h	/^  bool fShadow; \/\/ GL_ARB_shadow or 1.4+$/;"	m	struct:__anon15
fShadowAmbient	driver/MAC/macGlCheck.h	/^  bool fShadowAmbient; \/\/ GL_ARB_shadow_ambient$/;"	m	struct:__anon15
fShadowFunc	driver/MAC/macGlCheck.h	/^  bool fShadowFunc; \/\/ GL_EXT_shadow_funcs$/;"	m	struct:__anon15
fShareTexPalette	driver/MAC/macGlCheck.h	/^  bool fShareTexPalette; \/\/ GL_EXT_shared_texture_palette$/;"	m	struct:__anon15
fSpecularVector	driver/MAC/macGlCheck.h	/^  bool fSpecularVector; \/\/ GL_APPLE_specular_vector$/;"	m	struct:__anon15
fStencil2Side	driver/MAC/macGlCheck.h	/^  bool fStencil2Side; \/\/ GL_EXT_stencil_two_side$/;"	m	struct:__anon15
fStencilWrap	driver/MAC/macGlCheck.h	/^  bool fStencilWrap; \/\/ GL_EXT_stencil_wrap or 1.4+$/;"	m	struct:__anon15
fTex3D	driver/MAC/macGlCheck.h	/^  bool fTex3D; \/\/ GL_EXT_texture3D or 1.2+$/;"	m	struct:__anon15
fTexBorderClamp	driver/MAC/macGlCheck.h	/^  bool fTexBorderClamp; \/\/ GL_ARB_texture_border_clamp or 1.3+$/;"	m	struct:__anon15
fTexCompress	driver/MAC/macGlCheck.h	/^  bool fTexCompress; \/\/ GL_ARB_texture_compression or 1.3+$/;"	m	struct:__anon15
fTexCompressS3TC	driver/MAC/macGlCheck.h	/^  bool fTexCompressS3TC; \/\/ GL_EXT_texture_compression_s3tc$/;"	m	struct:__anon15
fTexCubeMap	driver/MAC/macGlCheck.h	/^  bool fTexCubeMap; \/\/ GL_ARB_texture_cube_map or 1.3+$/;"	m	struct:__anon15
fTexEdgeClamp	driver/MAC/macGlCheck.h	/^  bool fTexEdgeClamp; \/\/ GL_SGIS_texture_edge_clamp or 1.2+$/;"	m	struct:__anon15
fTexEnvAdd	driver/MAC/macGlCheck.h	/^  bool fTexEnvAdd; \/\/ GL_ARB_texture_env_add, GL_EXT_texture_env_add or 1.3+$/;"	m	struct:__anon15
fTexEnvCombine	driver/MAC/macGlCheck.h	/^  bool fTexEnvCombine; \/\/ GL_ARB_texture_env_combine or 1.3+$/;"	m	struct:__anon15
fTexEnvCombine4	driver/MAC/macGlCheck.h	/^  bool fTexEnvCombine4; \/\/ GL_NV_texture_env_combine4$/;"	m	struct:__anon15
fTexEnvCrossbar	driver/MAC/macGlCheck.h	/^  bool fTexEnvCrossbar; \/\/ GL_ARB_texture_env_crossbar or 1.4+$/;"	m	struct:__anon15
fTexEnvDot3	driver/MAC/macGlCheck.h	/^  bool fTexEnvDot3; \/\/ GL_ARB_texture_env_dot3 or 1.3+$/;"	m	struct:__anon15
fTexFilterAniso	driver/MAC/macGlCheck.h	/^  bool fTexFilterAniso; \/\/ GL_EXT_texture_filter_anisotropic$/;"	m	struct:__anon15
fTexGenReflect	driver/MAC/macGlCheck.h	/^  bool fTexGenReflect; \/\/ GL_NV_texgen_reflection$/;"	m	struct:__anon15
fTexLOD	driver/MAC/macGlCheck.h	/^  bool fTexLOD; \/\/ GL_SGIS_texture_lod or 1.2+$/;"	m	struct:__anon15
fTexLODBias	driver/MAC/macGlCheck.h	/^  bool fTexLODBias; \/\/ GL_EXT_texture_lod_bias or 1.4+$/;"	m	struct:__anon15
fTexMirrorOnce	driver/MAC/macGlCheck.h	/^  bool fTexMirrorOnce; \/\/ GL_ATI_texture_mirror_once$/;"	m	struct:__anon15
fTexMirrorRepeat	driver/MAC/macGlCheck.h	/^  bool fTexMirrorRepeat; \/\/ GL_ARB_texture_mirrored_repeat or 1.4+$/;"	m	struct:__anon15
fTexRect	driver/MAC/macGlCheck.h	/^  bool fTexRect; \/\/ GL_EXT_texture_rectangle$/;"	m	struct:__anon15
fTexShader	driver/MAC/macGlCheck.h	/^  bool fTexShader; \/\/ GL_NV_texture_shader$/;"	m	struct:__anon15
fTexShader2	driver/MAC/macGlCheck.h	/^  bool fTexShader2; \/\/ GL_NV_texture_shader2$/;"	m	struct:__anon15
fTexShader3	driver/MAC/macGlCheck.h	/^  bool fTexShader3; \/\/ GL_NV_texture_shader3$/;"	m	struct:__anon15
fTextFragShader	driver/MAC/macGlCheck.h	/^  bool fTextFragShader; \/\/ GL_ATI_text_fragment_shader$/;"	m	struct:__anon15
fTextureRange	driver/MAC/macGlCheck.h	/^  bool fTextureRange; \/\/ GL_APPLE_texture_range (AGP texturing)$/;"	m	struct:__anon15
fTransformHint	driver/MAC/macGlCheck.h	/^  bool fTransformHint; \/\/ GL_APPLE_transform_hint $/;"	m	struct:__anon15
fTransposeMatrix	driver/MAC/macGlCheck.h	/^  bool fTransposeMatrix; \/\/ GL_ARB_transpose_matrix or 1.3+$/;"	m	struct:__anon15
fVAO	driver/MAC/macGlCheck.h	/^  bool fVAO; \/\/ GL_APPLE_vertex_array_object$/;"	m	struct:__anon15
fVAR	driver/MAC/macGlCheck.h	/^  bool fVAR; \/\/ GL_APPLE_vertex_array_range$/;"	m	struct:__anon15
fVPEvals	driver/MAC/macGlCheck.h	/^  bool fVPEvals; \/\/ GL_APPLE_vertex_program_evaluators$/;"	m	struct:__anon15
fVel	driver/common.h	/^	GLfloat fVel [3];$/;"	m	struct:recContext
fVertexBlend	driver/MAC/macGlCheck.h	/^  bool fVertexBlend; \/\/ GL_ARB_vertex_blend$/;"	m	struct:__anon15
fVertexProg	driver/MAC/macGlCheck.h	/^  bool fVertexProg; \/\/ GL_ARB_vertex_program$/;"	m	struct:__anon15
fWindowPos	driver/MAC/macGlCheck.h	/^  bool fWindowPos; \/\/ GL_ARB_window_pos or 1.4+$/;"	m	struct:__anon15
fYCbCr	driver/MAC/macGlCheck.h	/^  bool fYCbCr; \/\/ GL_APPLE_ycbcr_422 (YUV texturing)$/;"	m	struct:__anon15
failmessage	tests/AnnotatedClusterTest.h	/^		std::string failmessage;$/;"	m	class:exceptionThrownHelper
features	driver/MAC/HID Support/HID_Utilities.h	/^	long features;							\/\/ number of elements of type kIOHIDElementTypeFeature$/;"	m	struct:recDevice
features	driver/MAC/HID Support/HID_Utilities_External.h	/^	long features;							\/\/ number of elements of type kIOHIDElementTypeFeature$/;"	m	struct:recDevice
fequal	util/fpUtil.h	/^inline bool fequal(double a, double b)$/;"	f
fgreater	util/fpUtil.h	/^inline bool fgreater(double a, double b) { return (a > b + TOLERANCE); }$/;"	f
filever	tests/ScenarioManagerTest.h	/^		float filever;$/;"	m	class:ScenarioManagerTest
find	util/heap2.h	/^OBJ heap2<OBJ, HashKey, EqKey, CmpKey>::find(OBJ val)$/;"	f	class:heap2
findAbstractPath	shared/hpaStar.cpp	/^path* hpaStar::findAbstractPath(node* from, node* to)$/;"	f	class:hpaStar
findAndMarkDominatedTransition	aha/AnnotatedClusterAbstraction.cpp	/^void AnnotatedClusterAbstraction::findAndMarkDominatedTransition(edge* first, edge* second)$/;"	f	class:AnnotatedClusterAbstraction
findAndMarkDominatedTransitionShouldMarkADominatedEdgeGivenTwoInterEdgesWhereOneDominatesTheOtherBut__TO__and__FROM__AttributesOfEndpointsIsSwapped	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::findAndMarkDominatedTransitionShouldMarkADominatedEdgeGivenTwoInterEdgesWhereOneDominatesTheOtherBut__TO__and__FROM__AttributesOfEndpointsIsSwapped()$/;"	f	class:AnnotatedClusterAbstractionTest
findAndMarkDominatedTransitionShouldMarkADominatedEdgeGivenTwoInterEdgesWithIntersectingCapabilitySets	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::findAndMarkDominatedTransitionShouldMarkADominatedEdgeGivenTwoInterEdgesWithIntersectingCapabilitySets()$/;"	f	class:AnnotatedClusterAbstractionTest
findAndMarkDominatedTransitionShouldMarkADominatedEdgeGivenTwoInterEdgesWithTheSameCapabilityButDifferentClearance	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::findAndMarkDominatedTransitionShouldMarkADominatedEdgeGivenTwoInterEdgesWithTheSameCapabilityButDifferentClearance()$/;"	f	class:AnnotatedClusterAbstractionTest
findAndMarkDominatedTransitionShouldNotMarkAnyEdgesDominantEdgeGivenTwoInterEdgesWithIntersectingCapabilityButNoCorridorSizeDominance	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::findAndMarkDominatedTransitionShouldNotMarkAnyEdgesDominantEdgeGivenTwoInterEdgesWithIntersectingCapabilityButNoCorridorSizeDominance()$/;"	f	class:AnnotatedClusterAbstractionTest
findAndMarkDominatedTransitionShouldNotMarkAnyEdgesGivenAPairofEdgesWithSomeSharedEndpointsWhichDoNotConnectTheSameSetOfClusters	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::findAndMarkDominatedTransitionShouldNotMarkAnyEdgesGivenAPairofEdgesWithSomeSharedEndpointsWhichDoNotConnectTheSameSetOfClusters()$/;"	f	class:AnnotatedClusterAbstractionTest
findAndMarkDominatedTransitionShouldNotMarkAnyEdgesGivenAPairofEdgesWithUniqueEndpointsWhichDoNotConnectTheSameSetOfClusters	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::findAndMarkDominatedTransitionShouldNotMarkAnyEdgesGivenAPairofEdgesWithUniqueEndpointsWhichDoNotConnectTheSameSetOfClusters()$/;"	f	class:AnnotatedClusterAbstractionTest
findAndMarkDominatedTransitionShouldNotMarkAnyEdgesGivenOneOrTwoInteredgesWhichReferenceInvalidNodeIDsAsTheirEndpoints	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::findAndMarkDominatedTransitionShouldNotMarkAnyEdgesGivenOneOrTwoInteredgesWhichReferenceInvalidNodeIDsAsTheirEndpoints()$/;"	f	class:AnnotatedClusterAbstractionTest
findAndMarkDominatedTransitionShouldNotMarkAnyEdgesGivenTwoInteEdgesEitherOfWhichOrBothAreNull	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::findAndMarkDominatedTransitionShouldNotMarkAnyEdgesGivenTwoInteEdgesEitherOfWhichOrBothAreNull()$/;"	f	class:AnnotatedClusterAbstractionTest
findAndMarkDominatedTransitionShouldNotMarkAnyEdgesIfBothParameterEdgesAreIntraEdgesThatBelongToSameCluster	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::findAndMarkDominatedTransitionShouldNotMarkAnyEdgesIfBothParameterEdgesAreIntraEdgesThatBelongToSameCluster()$/;"	f	class:AnnotatedClusterAbstractionTest
findAndMarkDominatedTransitionShouldNotMarkAnyEdgesIfEitherParameterIsAnIntraEdge	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::findAndMarkDominatedTransitionShouldNotMarkAnyEdgesIfEitherParameterIsAnIntraEdge()$/;"	f	class:AnnotatedClusterAbstractionTest
findAndMarkDominatedTransitionShouldNotMarkAnyEdgesIfNoCircuitExistsBetweenEndpointsOfTwoTransitionsWhereOneDomiantesTheOther	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::findAndMarkDominatedTransitionShouldNotMarkAnyEdgesIfNoCircuitExistsBetweenEndpointsOfTwoTransitionsWhereOneDomiantesTheOther()$/;"	f	class:AnnotatedClusterAbstractionTest
findAndMarkDominatedTransitionShouldNotMarkAnyEdgesIfTheIntraEdgesInTheCircuitAreNotTraversableByTheCapabilityOfTheDominatedTransition	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::findAndMarkDominatedTransitionShouldNotMarkAnyEdgesIfTheIntraEdgesInTheCircuitAreNotTraversableByTheCapabilityOfTheDominatedTransition()$/;"	f	class:AnnotatedClusterAbstractionTest
findAndMarkDominatedTransitionShouldNotMarkAnyEdgesIfTheIntraEdgesInTheCircuitDoNotHaveSufficentClearance	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::findAndMarkDominatedTransitionShouldNotMarkAnyEdgesIfTheIntraEdgesInTheCircuitDoNotHaveSufficentClearance()$/;"	f	class:AnnotatedClusterAbstractionTest
findAndMarkDominatedTransitionShouldNotUnmarkAnyEdgesWhichAreAlreadyMarked	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::findAndMarkDominatedTransitionShouldNotUnmarkAnyEdgesWhichAreAlreadyMarked()$/;"	f	class:AnnotatedClusterAbstractionTest
findAnnotatedEdge	util/graph.cpp	/^edge* node::findAnnotatedEdge(node* to, int capability, int clearance, double weight)$/;"	f	class:node
findAnnotatedEdgeShouldReturnAnExistingEdgeIfOneExistsWhichIsIdenticalToWhatParametersAskFor	tests/TestNode.cpp	/^void TestNode::findAnnotatedEdgeShouldReturnAnExistingEdgeIfOneExistsWhichIsIdenticalToWhatParametersAskFor()$/;"	f	class:TestNode
findAnnotatedEdgeShouldReturnAnExistingEdgeIfOneExistsWhichIsShorterButOtherwiseIdenticalToWhatParametersAskFor	tests/TestNode.cpp	/^void TestNode::findAnnotatedEdgeShouldReturnAnExistingEdgeIfOneExistsWhichIsShorterButOtherwiseIdenticalToWhatParametersAskFor()$/;"	f	class:TestNode
findAnnotatedEdgeShouldReturnAnExistingEdgeIfOneExistsWhichIsWiderAndShorterThanWhatParametersAskFor	tests/TestNode.cpp	/^void TestNode::findAnnotatedEdgeShouldReturnAnExistingEdgeIfOneExistsWhichIsWiderAndShorterThanWhatParametersAskFor()$/;"	f	class:TestNode
findAnnotatedEdgeShouldReturnAnExistingEdgeIfOneExistsWhichIsWiderButOtherwiseIdenticalToWhatParametersAskFor	tests/TestNode.cpp	/^void TestNode::findAnnotatedEdgeShouldReturnAnExistingEdgeIfOneExistsWhichIsWiderButOtherwiseIdenticalToWhatParametersAskFor()$/;"	f	class:TestNode
findAnnotatedEdgeShouldReturnTheShortestEdgeIfSeveralCandidateEdgesExistThatMatchWhatParametersAskedFor	tests/TestNode.cpp	/^void TestNode::findAnnotatedEdgeShouldReturnTheShortestEdgeIfSeveralCandidateEdgesExistThatMatchWhatParametersAskedFor()$/;"	f	class:TestNode
findAnnotatedEdgeShouldReturnZeroWhenEndpointParametersAreNull	tests/TestNode.cpp	/^void TestNode::findAnnotatedEdgeShouldReturnZeroWhenEndpointParametersAreNull()$/;"	f	class:TestNode
findAnnotatedEdgeShouldReturnZeroWhenExistingEdgeIsLongerAndMoreNarrowThanWhatParametersAskedFor	tests/TestNode.cpp	/^void TestNode::findAnnotatedEdgeShouldReturnZeroWhenExistingEdgeIsLongerAndMoreNarrowThanWhatParametersAskedFor()$/;"	f	class:TestNode
findAnnotatedEdgeShouldReturnZeroWhenExistingEdgeIsLongerAndWiderThanWhatParametersAskedFor	tests/TestNode.cpp	/^void TestNode::findAnnotatedEdgeShouldReturnZeroWhenExistingEdgeIsLongerAndWiderThanWhatParametersAskedFor()$/;"	f	class:TestNode
findAnnotatedEdgeShouldReturnZeroWhenExistingEdgeIsLongerButOtherwiseIdenticalToWhatParametersAskFor	tests/TestNode.cpp	/^void TestNode::findAnnotatedEdgeShouldReturnZeroWhenExistingEdgeIsLongerButOtherwiseIdenticalToWhatParametersAskFor()$/;"	f	class:TestNode
findAnnotatedEdgeShouldReturnZeroWhenExistingEdgeIsOfTheSameLengthButMoreNarrowThanWhatParametersAskFor	tests/TestNode.cpp	/^void TestNode::findAnnotatedEdgeShouldReturnZeroWhenExistingEdgeIsOfTheSameLengthButMoreNarrowThanWhatParametersAskFor()$/;"	f	class:TestNode
findAnnotatedEdgeShouldReturnZeroWhenExistingEdgeIsShorterAndMoreNarrowThanWhatParametersAskFor	tests/TestNode.cpp	/^void TestNode::findAnnotatedEdgeShouldReturnZeroWhenExistingEdgeIsShorterAndMoreNarrowThanWhatParametersAskFor()$/;"	f	class:TestNode
findAnnotatedEdgeShouldReturnZeroWhenNoEdgeExistsBetweenParameterEndpoints	tests/TestNode.cpp	/^void TestNode::findAnnotatedEdgeShouldReturnZeroWhenNoEdgeExistsBetweenParameterEndpoints()$/;"	f	class:TestNode
findDirectedEdge	util/graph.cpp	/^edge *graph::findDirectedEdge(unsigned int from, unsigned int to)$/;"	f	class:graph
findEdge	util/graph.cpp	/^edge *graph::findEdge(unsigned int from, unsigned int to)$/;"	f	class:graph
findEdgeParent	abstraction/loadedCliqueAbstraction.cpp	/^edge *loadedCliqueAbstraction::findEdgeParent(edge *e, unsigned int absLevel)$/;"	f	class:loadedCliqueAbstraction
findEdgeParent	abstraction/mapCliqueAbstraction.cpp	/^edge *mapCliqueAbstraction::findEdgeParent(edge *e, unsigned int absLevel)$/;"	f	class:mapCliqueAbstraction
findGoalNode	shared/craStar.cpp	/^void craStar::findGoalNode(graphAbstraction* aMap, node* n, std::vector<node *> &toChain)$/;"	f	class:craStar
findLocalMaximaForHorizontalEntrance	aha/AnnotatedCluster.cpp	/^int AnnotatedCluster::findLocalMaximaForHorizontalEntrance(int y, int startX, int endX, int curCapability, AnnotatedClusterAbstraction* aca)$/;"	f	class:AnnotatedCluster
findLocalMaximaForVerticalEntrance	aha/AnnotatedCluster.cpp	/^int AnnotatedCluster::findLocalMaximaForVerticalEntrance(int x, int startY, int endY, int curCapability, AnnotatedClusterAbstraction* aca)$/;"	f	class:AnnotatedCluster
findLocalMinimaForHorizontalEntrance	aha/AnnotatedCluster.cpp	/^int AnnotatedCluster::findLocalMinimaForHorizontalEntrance(int y, int startX, int curCapability, AnnotatedClusterAbstraction* aca)$/;"	f	class:AnnotatedCluster
findLocalMinimaForVerticalEntrance	aha/AnnotatedCluster.cpp	/^int AnnotatedCluster::findLocalMinimaForVerticalEntrance(int x, int startY, int curCapability, AnnotatedClusterAbstraction* aca)$/;"	f	class:AnnotatedCluster
findMapPath	shared/hpaStar.cpp	/^path* hpaStar::findMapPath(path* abPath,node* from,node* to)$/;"	f	class:hpaStar
findMax	abstraction/width.cpp	/^float findMax(node* n)$/;"	f
findMaxAbstracted	abstraction/width.cpp	/^float findMaxAbstracted(node* x, graph* g)$/;"	f
findMin	abstraction/width.cpp	/^float findMin(node* n)$/;"	f
findMinAbstractedNode	abstraction/width.cpp	/^float findMinAbstractedNode(node* x, graph* g)$/;"	f
findMinMax	shared/craStar.cpp	/^void craStar::findMinMax(path* p)$/;"	f	class:craStar
findMinMax	shared/hpaStar.cpp	/^void hpaStar::findMinMax(path* p)$/;"	f	class:hpaStar
findNeighborCliques	abstraction/loadedCliqueAbstraction.cpp	/^node *loadedCliqueAbstraction::findNeighborCliques(node *child)$/;"	f	class:loadedCliqueAbstraction
findNeighborCliques	abstraction/loadedCliqueAbstraction.cpp	/^node *loadedCliqueAbstraction::findNeighborCliques(node *parent, int group)$/;"	f	class:loadedCliqueAbstraction
findNeighborCliques	abstraction/mapCliqueAbstraction.cpp	/^node *mapCliqueAbstraction::findNeighborCliques(node *child)$/;"	f	class:mapCliqueAbstraction
findNeighborCliques	abstraction/mapCliqueAbstraction.cpp	/^node *mapCliqueAbstraction::findNeighborCliques(node *parent, int group)$/;"	f	class:mapCliqueAbstraction
findNextStat	util/statCollection.cpp	/^int statCollection::findNextStat(const char *category, const char *owner, int startIndex) const$/;"	f	class:statCollection
findNextStat	util/statCollection.cpp	/^int statCollection::findNextStat(const char *what, bool findCategory, int startIndex) const$/;"	f	class:statCollection
findNodeAt	abstraction/width.cpp	/^node* findNodeAt(int x, int y, graph* g) $/;"	f
findNodeParent	abstraction/loadedCliqueAbstraction.cpp	/^node *loadedCliqueAbstraction::findNodeParent(node *n)$/;"	f	class:loadedCliqueAbstraction
findNodeParent	abstraction/mapCliqueAbstraction.cpp	/^node *mapCliqueAbstraction::findNodeParent(node *n)$/;"	f	class:mapCliqueAbstraction
findPrevStat	util/statCollection.cpp	/^int statCollection::findPrevStat(const char *category, const char *owner, int startIndex) const$/;"	f	class:statCollection
findPrevStat	util/statCollection.cpp	/^int statCollection::findPrevStat(const char *what, bool findCategory, int startIndex) const$/;"	f	class:statCollection
findShortestPathBetweenTwoEndpoints	aha/AnnotatedCluster.cpp	/^void AnnotatedCluster::findShortestPathBetweenTwoEndpoints(node* n1, node* n2, int capability, int size, AnnotatedClusterAbstraction* aca)$/;"	f	class:AnnotatedCluster
findUnit	simulation/unitSimulation.cpp	/^unit *unitSimulation::findUnit(int x, int y)$/;"	f	class:unitSimulation
findUnit	simulation/unitSimulation.cpp	/^unitInfo *unitSimulation::findUnit(unit *u)$/;"	f	class:unitSimulation
findUnitDisplayTime	simulation/unitSimulation.cpp	/^bool unitSimulation::findUnitDisplayTime(unitInfo *ui)$/;"	f	class:unitSimulation
fixedPlanLevel	shared/praStar.h	/^	int fixedPlanLevel;$/;"	m	class:praStar
fixedPlanLevel	shared/praStar2.h	/^  int fixedPlanLevel;$/;"	m	class:praStar2
fless	util/fpUtil.h	/^inline bool fless(double a, double b) { return (a < b - TOLERANCE); }$/;"	f
floatStored	util/statCollection.h	/^enum storedType { floatStored, longStored };$/;"	e	enum:storedType
fpUtil_H	util/fpUtil.h	/^#define fpUtil_H$/;"	d
fps	driver/main.cpp	/^double fps = 30.0;$/;"	v
frameCallback	apps/sample/sample.cpp	/^void frameCallback(unitSimulation *us)$/;"	f
frames	driver/MAC/mac_main.cpp	/^std::vector<movieFrame *> frames;$/;"	v
from	tests/TestNode.h	/^	node *from, *to;$/;"	m	class:TestNode
from	util/graph.h	/^	unsigned int from, to;$/;"	m	class:edge
fromClusterId	tests/AnnotatedClusterTest.h	/^		int fromx, fromy, tox, toy, capability, clearance, fromClusterId, toClusterId;$/;"	m	class:TestEntrance
fromnum	shared/hpaStar.h	/^	node* fromnum;$/;"	m	class:hpaStar
fromx	tests/AnnotatedClusterTest.h	/^		int fromx, fromy, tox, toy, capability, clearance, fromClusterId, toClusterId;$/;"	m	class:TestEntrance
fromy	tests/AnnotatedClusterTest.h	/^		int fromx, fromy, tox, toy, capability, clearance, fromClusterId, toClusterId;$/;"	m	class:TestEntrance
fullScreenCapable	driver/MAC/macGlCheck.h	/^  bool fullScreenCapable; \/\/ does device support full screen$/;"	m	struct:__anon15
fval	util/graph.h	/^typedef union { double fval; long lval; } labelValue;$/;"	m	union:__anon23
fval	util/statCollection.h	/^typedef union { double fval; long lval; } statValue;$/;"	m	union:__anon26
g	shared/aStar.h	/^	graph *g;$/;"	m	class:aStar
g	simulation/unit.h	/^	GLfloat r, g, b;$/;"	m	class:unit
g	tests/AnnotatedMapAbstractionTest.h	/^		graph *g;$/;"	m	class:AnnotatedMapAbstractionTest
g	tests/TestNode.h	/^	graph* g;$/;"	m	class:TestNode
g	util/SearchEnvironment.h	/^	graph *g;$/;"	m	class:GraphSearchEnvironment
g	util/glUtil.h	/^	GLfloat r,g,b;$/;"	m	class:recColor
gActionArray	driver/MAC/HID Support/HIDSupport.cpp	/^static actionRec gActionArray [kNumActions]; \/\/ array of action records for mapping and values$/;"	v	file:
gConfigEDMUPP	driver/MAC/mac_main.cpp	/^DMExtendedNotificationUPP gConfigEDMUPP = NULL;$/;"	v
gCost	shared/aStar.h	/^		double gCost;$/;"	m	class:AStar3Util::SearchNode
gCost	util/GenericAStar.h	/^		double gCost;$/;"	m	class:GenericAStarUtil::SearchNode
gCurrButton	driver/main.cpp	/^int gCurrButton = -1;$/;"	v
gCurrentGetDevice	driver/MAC/HID Support/HID_Utilities.cpp	/^pRecDevice gCurrentGetDevice = NULL;$/;"	v
gDefaultMap	driver/common.cpp	/^char gDefaultMap[1024] = "";$/;"	v
gDisplayCaps	driver/MAC/mac_main.cpp	/^GLCaps * gDisplayCaps = NULL; \/\/ array of GLCaps$/;"	v
gDolly	driver/MAC/mac_main.cpp	/^GLboolean gDolly = GL_FALSE;$/;"	v
gDolly	driver/main.cpp	/^GLboolean gDolly = GL_FALSE;$/;"	v
gDollyPanStartPoint	driver/MAC/mac_main.cpp	/^GLint gDollyPanStartPoint[2] = {0, 0};$/;"	v
gDollyPanStartPoint	driver/main.cpp	/^GLint gDollyPanStartPoint[2] = {0, 0};$/;"	v
gEdgeProb	abstraction/mapAbstraction.cpp	/^static const int gEdgeProb = 100;$/;"	v	file:
gEndPtTrackball	driver/trackball.cpp	/^float gEndPtTrackball[3];$/;"	v
gErrorMessage	driver/MAC/mac_main.cpp	/^char gErrorMessage[256] = ""; \/\/ buffer for error message output$/;"	v
gErrorTime	driver/MAC/mac_main.cpp	/^float gErrorTime = 0.0;$/;"	v
gEvtHandler	driver/MAC/mac_main.cpp	/^EventHandlerUPP gEvtHandler;			\/\/ main event handler$/;"	v
gHIDTimer	driver/MAC/HID Support/HIDSupport.cpp	/^EventLoopTimerRef gHIDTimer = NULL; \/\/ input timer$/;"	v
gNumDevices	driver/MAC/HID Support/HID_Utilities.cpp	/^unsigned long gNumDevices = 0;$/;"	v
gNumDisplays	driver/MAC/mac_main.cpp	/^CGDisplayCount gNumDisplays = 0;$/;"	v
gOrigin	driver/common.cpp	/^const recVec gOrigin = { 0.0, 0.0, 0.0 };$/;"	v
gPan	driver/MAC/mac_main.cpp	/^GLboolean gPan = GL_FALSE;$/;"	v
gPan	driver/main.cpp	/^GLboolean gPan = GL_FALSE;$/;"	v
gRadiusTrackball	driver/trackball.cpp	/^float gRadiusTrackball;$/;"	v
gStartPtTrackball	driver/trackball.cpp	/^float gStartPtTrackball[3];$/;"	v
gStartTime	driver/MAC/mac_main.cpp	/^AbsoluteTime gStartTime;$/;"	v
gStraightEdgeProb	abstraction/mapAbstraction.cpp	/^static const int gStraightEdgeProb = 100;$/;"	v	file:
gTrackBallRotation	driver/MAC/mac_main.cpp	/^GLfloat gTrackBallRotation [4] = {0.0f, 0.0f, 0.0f, 0.0f};$/;"	v
gTrackBallRotation	driver/main.cpp	/^GLfloat gTrackBallRotation [4] = {0.0f, 0.0f, 0.0f, 0.0f};$/;"	v
gTrackball	driver/MAC/mac_main.cpp	/^GLboolean gTrackball = GL_FALSE;$/;"	v
gTrackball	driver/main.cpp	/^GLboolean gTrackball = GL_FALSE;$/;"	v
gTrackingContextInfo	driver/MAC/mac_main.cpp	/^pRecContext gTrackingContextInfo = NULL;$/;"	v
gTrackingContextInfo	driver/main.cpp	/^pRecContext gTrackingContextInfo = NULL;$/;"	v
gWinEvtHandler	driver/MAC/mac_main.cpp	/^EventHandlerUPP gWinEvtHandler;			\/\/ window event handler$/;"	v
gXCenterTrackball	driver/trackball.cpp	/^long gXCenterTrackball = 0, gYCenterTrackball = 0;$/;"	v
gYCenterTrackball	driver/trackball.cpp	/^long gXCenterTrackball = 0, gYCenterTrackball = 0;$/;"	v
ga	abstraction/AbstractionSearchEnvironment.h	/^		graphAbstraction *ga;$/;"	m	class:AbstractionSearchEnvironment
gcost	abstraction/AbstractionSearchEnvironment.cpp	/^double AbstractionSearchEnvironment::gcost(uint32_t node1, uint32_t node2)$/;"	f	class:AbstractionSearchEnvironment
gcost	abstraction/clusterAbstraction.cpp	/^	double gcost(uint32_t node1, uint32_t node2)$/;"	f	class:ClusterSearchEnvironment
gcost	util/SearchEnvironment.cpp	/^double GraphSearchEnvironment::gcost(uint32_t node1, uint32_t node2)$/;"	f	class:GraphSearchEnvironment
gcost	util/SearchEnvironment.cpp	/^double MapSearchEnvironment::gcost(uint32_t node1, uint32_t node2)$/;"	f	class:MapSearchEnvironment
generateExperiments	aha/ScenarioManager.cpp	/^void AHAScenarioManager::generateExperiments(AbstractAnnotatedMapAbstraction* absMap, int numscenarios, int minsize) throw(TooManyTriesException)$/;"	f	class:AHAScenarioManager
generateExperiments	tests/ExperimentManager.cpp	/^void ExperimentManager::generateExperiments()$/;"	f	class:ExperimentManager
generateExperimentsProducesCorrectNumberOfExperiments	tests/ScenarioManagerTest.cpp	/^void ScenarioManagerTest::generateExperimentsProducesCorrectNumberOfExperiments()$/;"	f	class:ScenarioManagerTest
generateExperimentsProducesExperimentsWithDifferentCapabilityTypes	tests/ScenarioManagerTest.cpp	/^void ScenarioManagerTest::generateExperimentsProducesExperimentsWithDifferentCapabilityTypes()$/;"	f	class:ScenarioManagerTest
generatePaths	shared/pathGeneration.cpp	/^void generatePaths(char *_map, int mapSizeX, int mapSizeY, int numBuckets, int bucketSize, int pathsPerBucket)$/;"	f
generateSingleExperiment	aha/ScenarioManager.cpp	/^AHAExperiment* AHAScenarioManager::generateSingleExperiment(AbstractAnnotatedMapAbstraction* absMap, int capability, int size)$/;"	f	class:AHAScenarioManager
generateSingleExperimentReturnsAValidExperimentForTheGivenParameters	tests/ScenarioManagerTest.cpp	/^void ScenarioManagerTest::generateSingleExperimentReturnsAValidExperimentForTheGivenParameters()$/;"	f	class:ScenarioManagerTest
generateSingleExperimentReturnsNullIfNoPairOfStartAndGoalNodesCouldBeLocatedForTheGivenParameters	tests/ScenarioManagerTest.cpp	/^void ScenarioManagerTest::generateSingleExperimentReturnsNullIfNoPairOfStartAndGoalNodesCouldBeLocatedForTheGivenParameters()$/;"	f	class:ScenarioManagerTest
generated	aha/ScenarioManager.h	/^		int generated, target;$/;"	m	class:TooManyTriesException
get	util/bitVector.cpp	/^bool bitVector::get(int index) const$/;"	f	class:bitVector
getAbstractGraph	abstraction/graphAbstraction.h	/^	inline graph* getAbstractGraph(node *which) { return abstractions[which->getLabelL(kAbstractionLevel)]; }$/;"	f	class:graphAbstraction
getAbstractGraph	abstraction/graphAbstraction.h	/^  graph* getAbstractGraph(int level) { return abstractions[level]; }$/;"	f	class:graphAbstraction
getAbstractPath	aha/AnnotatedHierarchicalAStar.h	/^		virtual path* getAbstractPath(graphAbstraction* aMap, node* from, node* to) $/;"	f	class:AnnotatedHierarchicalAStar
getAbstractPath	shared/praStar.cpp	/^path *praStar::getAbstractPath(graph *g, unsigned int source, unsigned int destParent,$/;"	f	class:praStar
getAbstractPathLengths	shared/praStar.h	/^	void getAbstractPathLengths(std::vector<int> &len) { len = lengths; }$/;"	f	class:praStar
getAbstractPathShouldFindTheShortestPathBetweenTwoAbstractNodesGivenACapabilityAndAClearanceAndAnAnnotatedClusterAbstractionParameter	tests/AnnotatedHierarchicalAStarTest.cpp	/^void AnnotatedHierarchicalAStarTest::getAbstractPathShouldFindTheShortestPathBetweenTwoAbstractNodesGivenACapabilityAndAClearanceAndAnAnnotatedClusterAbstractionParameter()$/;"	f	class:AnnotatedHierarchicalAStarTest
getAbstractionLevel	abstraction/graphAbstraction.h	/^	inline long getAbstractionLevel(node *which) { return which->getLabelL(kAbstractionLevel); }$/;"	f	class:graphAbstraction
getAgentsize	aha/ScenarioManager.h	/^		int getAgentsize() { return agentsize; }$/;"	f	class:AHAExperiment
getAlgorithm	shared/searchUnit.h	/^	virtual searchAlgorithm* getAlgorithm() { return algorithm; }$/;"	f	class:searchUnit
getBestPath	shared/corridorAStar.cpp	/^path *corridorAStar::getBestPath(graphAbstraction *aMap, node *afrom, node *ato, node *from, node *, reservationProvider *rp)$/;"	f	class:corridorAStar
getBestPath	shared/corridorAStar.cpp	/^path *corridorAStar::getBestPath(graphAbstraction *aMap, node *from, node *to, node *hGoal, reservationProvider *rp)$/;"	f	class:corridorAStar
getBitmap	driver/TextBox.cpp	/^uint32_t TextBox::getBitmap(char c)$/;"	f	class:TextBox
getBucket	shared/scenarioLoader.h	/^  int getBucket(){return bucket;}$/;"	f	class:Experiment
getCPUSpeed	util/timer.cpp	/^float Timer::getCPUSpeed()$/;"	f	class:Timer
getCachedMove	shared/searchUnit.cpp	/^bool searchUnit::getCachedMove(tDirection &dir)$/;"	f	class:searchUnit
getCachedPath	abstraction/clusterAbstraction.cpp	/^path* clusterAbstraction::getCachedPath(edge* e) $/;"	f	class:clusterAbstraction
getCapability	aha/AnnotatedAStar.h	/^		int getCapability() { return capability; }$/;"	f	class:AbstractAnnotatedAStar
getCapability	aha/ScenarioManager.h	/^		int getCapability() { return capability; }$/;"	f	class:AHAExperiment
getCapability	tests/AnnotatedClusterTest.h	/^		int getCapability() { return capability; }$/;"	f	class:TestEntrance
getCapability	util/graph.h	/^	int getCapability() { return capability; }$/;"	f	class:edge
getCenter1Col	abstraction/clusterAbstraction.h	/^  int getCenter1Col() { return m_center1Col; }$/;"	f	class:Entrance
getCenter1Row	abstraction/clusterAbstraction.h	/^  int getCenter1Row() { return m_center1Row; }$/;"	f	class:Entrance
getChildGroups	abstraction/loadedCliqueAbstraction.cpp	/^int loadedCliqueAbstraction::getChildGroups(node *which)$/;"	f	class:loadedCliqueAbstraction
getChildGroups	abstraction/mapCliqueAbstraction.cpp	/^int mapCliqueAbstraction::getChildGroups(node *which)$/;"	f	class:mapCliqueAbstraction
getClearance	aha/AnnotatedAStar.h	/^		int getClearance() { return clearance;}$/;"	f	class:AbstractAnnotatedAStar
getClearance	tests/AnnotatedClusterTest.cpp	/^int TestEntrance::getClearance(int agentcapability)$/;"	f	class:TestEntrance
getClearance	util/graph.cpp	/^int edge::getClearance(int agentcapability)$/;"	f	class:edge
getClearance	util/graph.cpp	/^int node::getClearance(int terrain)$/;"	f	class:node
getClearanceShouldReturnZeroGivenACapabilityThatDoesNotMatchTheStoredCapability	tests/EdgeTest.cpp	/^void EdgeTest::getClearanceShouldReturnZeroGivenACapabilityThatDoesNotMatchTheStoredCapability()$/;"	f	class:EdgeTest
getClearanceShouldReturnZeroGivenACapabilityThatIsASubsetOfTheStoredCapability	tests/EdgeTest.cpp	/^void EdgeTest::getClearanceShouldReturnZeroGivenACapabilityThatIsASubsetOfTheStoredCapability()$/;"	f	class:EdgeTest
getClosedListIter	util/GenericAStar.cpp	/^closedList_iterator GenericAStar::getClosedListIter() const$/;"	f	class:GenericAStar
getCluster	abstraction/clusterAbstraction.cpp	/^Cluster& clusterAbstraction::getCluster(int id)$/;"	f	class:clusterAbstraction
getCluster	aha/AnnotatedClusterAbstraction.cpp	/^AnnotatedCluster* AnnotatedClusterAbstraction::getCluster(int cid)$/;"	f	class:AnnotatedClusterAbstraction
getCluster	tests/AnnotatedClusterAbstractionMock.h	/^		virtual AnnotatedCluster* getCluster(int cid) $/;"	f	class:AnnotatedClusterAbstractionMock
getCluster1Id	abstraction/clusterAbstraction.h	/^  int getCluster1Id() { return m_cluster1Id; }$/;"	f	class:Entrance
getCluster2Id	abstraction/clusterAbstraction.h	/^  int getCluster2Id() { return m_cluster2Id; } $/;"	f	class:Entrance
getClusterId	abstraction/clusterAbstraction.cpp	/^int clusterAbstraction::getClusterId(int row, int col) const$/;"	f	class:clusterAbstraction
getClusterId	abstraction/clusterAbstraction.h	/^	int getClusterId() { return m_id; }$/;"	f	class:Cluster
getClusterIdFromCoord	abstraction/clusterAbstraction.cpp	/^int clusterAbstraction::getClusterIdFromCoord(int row, int col) const$/;"	f	class:clusterAbstraction
getClusterIdFromNode	abstraction/clusterAbstraction.cpp	/^int clusterAbstraction::getClusterIdFromNode(node* n)$/;"	f	class:clusterAbstraction
getClusterMocker	tests/AnnotatedClusterAbstractionMock.h	/^		MOCKPP_NS::ChainableMockMethod<AnnotatedCluster*, int> getClusterMocker;$/;"	m	class:AnnotatedClusterAbstractionMock
getClusterShouldReturnRequestedClusterGivenAValidClusterId	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::getClusterShouldReturnRequestedClusterGivenAValidClusterId()$/;"	f	class:AnnotatedClusterAbstractionTest
getClusterShouldReturnZeroWhenIdParameterIsGreaterThanNumberOfClusters	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::getClusterShouldReturnZeroWhenIdParameterIsGreaterThanNumberOfClusters()$/;"	f	class:AnnotatedClusterAbstractionTest
getClusterShouldReturnZeroWhenIdParameterIsLessThanZero	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::getClusterShouldReturnZeroWhenIdParameterIsLessThanZero()$/;"	f	class:AnnotatedClusterAbstractionTest
getClusterSize	abstraction/clusterAbstraction.h	/^	int getClusterSize() { return clusterSize; };  $/;"	f	class:clusterAbstraction
getClusterSize	aha/AnnotatedClusterAbstraction.h	/^		virtual int getClusterSize() { return clustersize; } $/;"	f	class:AnnotatedClusterAbstraction
getClusterSizeShouldReturnSameValueAsConstructorParameter	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::getClusterSizeShouldReturnSameValueAsConstructorParameter()$/;"	f	class:AnnotatedClusterAbstractionTest
getClusterTerrain	aha/AnnotatedCluster.h	/^		AnnotatedCluster* getClusterTerrain() { return ac; }$/;"	f	class:AnnotatedClusterException
getCol	abstraction/clusterAbstraction.h	/^  int getCol() {return m_col;}$/;"	f	class:Entrance
getColor	simulation/unit.h	/^	void getColor(GLfloat& _r, GLfloat& _g, GLfloat& _b) { _r=r; _g=g; _b=b; }$/;"	f	class:unit
getColor	util/glUtil.cpp	/^recColor getColor(GLfloat v, GLfloat vmin, GLfloat vmax, int type)$/;"	f
getColorMap	util/mapOverlay.h	/^	int getColorMap() { return colorMap; }$/;"	f	class:MapOverlay
getCoordinateScale	util/map.cpp	/^double Map::getCoordinateScale()$/;"	f	class:Map
getCornerHeight	util/map.cpp	/^long Map::getCornerHeight(long x, long y, tCorner which, tEdge edge) const$/;"	f	class:Map
getCornerHeight	util/map.cpp	/^long Map::getCornerHeight(long x, long y, tCorner which, tSplitSide split) const$/;"	f	class:Map
getCurrRound	simulation/unitRaceSimulation.h	/^	int getCurrRound() { return currRound; }$/;"	f	class:unitRaceSimulation
getCurrentCaps	driver/MAC/mac_main.cpp	/^static void getCurrentCaps(void)$/;"	f	file:
getCurrentContext	driver/MAC/mac_main.cpp	/^pRecContext getCurrentContext()$/;"	f
getCurrentContext	driver/main.cpp	/^pRecContext getCurrentContext()$/;"	f
getDebugInfo	aha/AnnotatedMapAbstraction.h	/^		bool getDebugInfo() { return this->debuginfo; }$/;"	f	class:AbstractAnnotatedMapAbstraction
getDebugInfo	util/graph.h	/^  bool getDebugInfo() { return debuginfo; }$/;"	f	class:graph_object
getDefaultEdgeWeight	shared/aStar3.h	/^	double getDefaultEdgeWeight() { return wh; }$/;"	f	class:aStarOld
getDirection	aha/AnnotatedAStar.cpp	/^tDirection AnnotatedAStar::getDirection(node* current, node* target)$/;"	f	class:AnnotatedAStar
getDisplayMapNumber	simulation/unitSimulation.h	/^	int getDisplayMapNumber() { return which_map; }$/;"	f	class:unitSimulation
getDisplayTime	simulation/unitSimulation.h	/^	double getDisplayTime() { return viewTime; }$/;"	f	class:unitSimulation
getDistance	shared/scenarioLoader.h	/^  double getDistance(){return distance;}$/;"	f	class:Experiment
getDrawClearance	aha/AnnotatedClusterAbstraction.h	/^		bool getDrawClearance() { return drawClearance; }$/;"	f	class:AnnotatedClusterAbstraction
getDrawClusters	aha/AnnotatedClusterAbstraction.h	/^		bool getDrawClusters() { return drawClusters; }$/;"	f	class:AnnotatedClusterAbstraction
getDrawLand	util/map.h	/^  bool getDrawLand() { return drawLand; }$/;"	f	class:Map
getEdge	util/graph.cpp	/^edge *node::getEdge(unsigned int which)$/;"	f	class:node
getEdgeIter	util/graph.cpp	/^edge_iterator graph::getEdgeIter() const$/;"	f	class:graph
getEdgeIter	util/graph.cpp	/^edge_iterator node::getEdgeIter() const$/;"	f	class:node
getEdgeNum	util/graph.h	/^	int getEdgeNum() const { return edgeNum; } $/;"	f	class:edge
getEdgeWidthX	util/map.cpp	/^float Map::getEdgeWidthX(int x, int y)$/;"	f	class:Map
getEdgeWidthY	util/map.cpp	/^float Map::getEdgeWidthY(int x, int y)$/;"	f	class:Map
getElapsedTime	driver/MAC/mac_main.cpp	/^static float getElapsedTime(void)$/;"	f	file:
getElapsedTime	util/timer.h	/^	double getElapsedTime(){return elapsedTime;}$/;"	f	class:Timer
getExceptionErrorMessage	aha/AnnotatedCluster.cpp	/^const char* ClusterFullException::getExceptionErrorMessage() const$/;"	f	class:ClusterFullException
getExceptionErrorMessage	aha/AnnotatedCluster.cpp	/^const char* NodeIsAlreadyAssignedToClusterException::getExceptionErrorMessage() const$/;"	f	class:NodeIsAlreadyAssignedToClusterException
getExceptionErrorMessage	aha/AnnotatedCluster.cpp	/^const char* NodeIsHardObstacleException::getExceptionErrorMessage() const$/;"	f	class:NodeIsHardObstacleException
getExceptionErrorMessage	aha/AnnotatedCluster.cpp	/^const char* NodeIsNullException::getExceptionErrorMessage() const$/;"	f	class:NodeIsNullException
getExperiment	tests/ExperimentManager.cpp	/^TestExperiment* ExperimentManager::getExperiment(ExperimentKey expkey)$/;"	f	class:ExperimentManager
getFrom	util/graph.h	/^	unsigned int getFrom() { return from; }$/;"	f	class:edge
getFromClusterId	tests/AnnotatedClusterTest.h	/^		int getFromClusterId() { return fromClusterId; }$/;"	f	class:TestEntrance
getFromX	tests/AnnotatedClusterTest.h	/^		int getFromX() { return fromx; }$/;"	f	class:TestEntrance
getFromY	tests/AnnotatedClusterTest.h	/^		int getFromY() { return fromy; }$/;"	f	class:TestEntrance
getGoalNode	tests/ExperimentManager.cpp	/^node* ExpMgrUtil::TestExperiment::getGoalNode()$/;"	f	class:ExpMgrUtil::TestExperiment
getGoalX	shared/scenarioLoader.h	/^  int getGoalX(){return goalx;}$/;"	f	class:Experiment
getGoalY	shared/scenarioLoader.h	/^  int getGoalY(){return goaly;}$/;"	f	class:Experiment
getGraphAbstraction	shared/aStar3.h	/^	graphAbstraction* getGraphAbstraction() { return map; }$/;"	f	class:aStarOld
getGroupID	simulation/unitGroup.h	/^	int getGroupID() { return id; }$/;"	f	class:unitGroup
getGroupSize	abstraction/loadedCliqueAbstraction.cpp	/^int loadedCliqueAbstraction::getGroupSize(node *parent, int group)$/;"	f	class:loadedCliqueAbstraction
getGroupSize	abstraction/mapCliqueAbstraction.cpp	/^int mapCliqueAbstraction::getGroupSize(node *parent, int group)$/;"	f	class:mapCliqueAbstraction
getHOrig	abstraction/clusterAbstraction.h	/^	int getHOrig() const { return m_horizOrigin; }$/;"	f	class:Cluster
getHeight	abstraction/clusterAbstraction.h	/^	int getHeight() const { return m_height; }$/;"	f	class:Cluster
getHeight	util/map.cpp	/^long Map::getHeight(long x, long y, tSplitSide split)$/;"	f	class:Map
getHome	driver/common.cpp	/^char* getHome() { return HOGHOME; }$/;"	f
getIncomingEdgeIter	util/graph.cpp	/^edge_iterator node::getIncomingEdgeIter() const$/;"	f	class:node
getInsertNodesExpanded	aha/AnnotatedHierarchicalAStar.h	/^		long getInsertNodesExpanded() { return insertNodesExpanded; }$/;"	f	class:AnnotatedHierarchicalAStar
getInsertNodesTouched	aha/AnnotatedHierarchicalAStar.h	/^		long getInsertNodesTouched() { return insertNodesTouched; }$/;"	f	class:AnnotatedHierarchicalAStar
getInsertPeakMemory	aha/AnnotatedHierarchicalAStar.h	/^		long getInsertPeakMemory() { return insertPeakMemory; }$/;"	f	class:AnnotatedHierarchicalAStar
getInsertSearchTime	aha/AnnotatedHierarchicalAStar.h	/^		double getInsertSearchTime() { return insertSearchTime; }$/;"	f	class:AnnotatedHierarchicalAStar
getIthNodeNum	abstraction/clusterAbstraction.h	/^	int getIthNodeNum(int i) const { return nodes[i];}$/;"	f	class:Cluster
getKey	util/graph.h	/^  double getKey() { return label[keyLabel].fval; }$/;"	f	class:node
getKey	util/graph.h	/^  virtual double getKey() { return 0; }$/;"	f	class:graph_object
getLabelF	util/graph.h	/^	inline double getLabelF(unsigned int index) const { if (index < label.size()) return label[index].fval; return MAXINT; }$/;"	f	class:edge
getLabelF	util/graph.h	/^  inline double getLabelF(unsigned int index) {$/;"	f	class:node
getLabelL	util/graph.h	/^	inline long getLabelL(unsigned int index) const { if (index < label.size()) return label[index].lval; return MAXINT; }$/;"	f	class:edge
getLabelL	util/graph.h	/^  inline long getLabelL(unsigned int index) {$/;"	f	class:node
getLastStat	util/statCollection.cpp	/^statValue *statCollection::getLastStat(const char *category, const char *owner)$/;"	f	class:statCollection
getLocation	driver/TextBox.cpp	/^point3d TextBox::getLocation()$/;"	f	class:TextBox
getLocation	simulation/unit.cpp	/^void unit::getLocation(int &_x, int &_y)$/;"	f	class:unit
getLockstepTime	simulation/unitSimulation.h	/^	bool getLockstepTime() { return lockstepTime; }$/;"	f	class:unitSimulation
getLowLevelNode	abstraction/clusterAbstraction.cpp	/^node* clusterAbstraction::getLowLevelNode(node* abstract) $/;"	f	class:clusterAbstraction
getMap	abstraction/mapAbstraction.h	/^	Map* getMap() { return m; }$/;"	f	class:mapAbstraction
getMap	shared/sharedAMapGroup.cpp	/^Map *sharedAMapGroup::getMap()$/;"	f	class:sharedAMapGroup
getMap	simulation/unitSimulation.h	/^	Map *getMap() { return map; }$/;"	f	class:unitSimulation
getMap	util/mapOverlay.h	/^	Map *getMap() { return m; }$/;"	f	class:MapOverlay
getMapAbstraction	shared/sharedAMapGroup.cpp	/^mapAbstraction *sharedAMapGroup::getMapAbstraction()$/;"	f	class:sharedAMapGroup
getMapAbstraction	simulation/unitGroup.cpp	/^mapAbstraction *unitGroup::getMapAbstraction()$/;"	f	class:unitGroup
getMapAbstraction	simulation/unitSimulation.cpp	/^mapAbstraction *unitSimulation::getMapAbstraction()$/;"	f	class:unitSimulation
getMapAbstraction	simulation/unitSimulation.cpp	/^mapAbstraction *unitSimulation::getMapAbstraction(int _which)$/;"	f	class:unitSimulation
getMapAbstractionDisplay	simulation/unitSimulation.cpp	/^mapAbstraction *unitSimulation::getMapAbstractionDisplay()$/;"	f	class:unitSimulation
getMapGraph	abstraction/mapAbstraction.cpp	/^graph *getMapGraph(Map *m)$/;"	f
getMapHeight	util/map.h	/^  inline long getMapHeight() const { return height; }$/;"	f	class:Map
getMapName	shared/scenarioLoader.h	/^	const char *getMapName() { return map.c_str(); }$/;"	f	class:Experiment
getMapName	shared/scenarioLoader.h	/^  void getMapName(char* mymap){strcpy(mymap,map.c_str());}$/;"	f	class:Experiment
getMapName	util/map.cpp	/^const char *Map::getMapName()$/;"	f	class:Map
getMapWidth	util/map.h	/^  inline long getMapWidth() const { return width; }$/;"	f	class:Map
getMarked	util/graph.h	/^	bool getMarked() { return mark; }$/;"	f	class:edge
getMarkedEdge	util/graph.h	/^  edge *getMarkedEdge() { return markedEdge; }$/;"	f	class:node
getMaxValue	util/mapOverlay.h	/^	double getMaxValue() { return maxVal; }$/;"	f	class:MapOverlay
getMemoryUsage	shared/aStar.cpp	/^int aStar::getMemoryUsage()$/;"	f	class:aStar
getMemoryUsage	util/GenericAStar.cpp	/^int GenericAStar::getMemoryUsage()$/;"	f	class:GenericAStar
getMinValue	util/mapOverlay.h	/^	double getMinValue() { return minVal; }$/;"	f	class:MapOverlay
getModifierText	driver/common.cpp	/^const char *getModifierText(tKeyboardModifier t)$/;"	f
getMoveStochasticity	simulation/unitSimulation.h	/^	double getMoveStochasticity() { return stochasticity; }$/;"	f	class:unitSimulation
getName	aha/AnnotatedAStar.h	/^		virtual const char* getName() { return "AAStar"; }$/;"	f	class:AnnotatedAStar
getName	aha/AnnotatedHierarchicalAStar.h	/^		virtual const char* getName() { return "AHAStar"; }$/;"	f	class:AnnotatedHierarchicalAStar
getName	shared/aStar.cpp	/^const char *aStar::getName()$/;"	f	class:aStar
getName	shared/aStar3.h	/^	virtual const char *getName() { return aStarName; }$/;"	f	class:aStarOld
getName	shared/corridorAStar.h	/^	virtual const char *getName() { return "corridorAStar"; }$/;"	f	class:corridorAStar
getName	shared/craStar.h	/^	virtual const char *getName()$/;"	f	class:craStar
getName	shared/hpaStar.h	/^	virtual const char *getName() { return algName; } $/;"	f	class:hpaStar
getName	shared/patrolUnit.h	/^	virtual const char *getName() { return "patrolUnit"; }$/;"	f	class:patrolUnit
getName	shared/praStar.h	/^	virtual const char *getName() { return algName; } $/;"	f	class:praStar
getName	shared/praStar2.h	/^	virtual const char *getName()$/;"	f	class:praStar2
getName	shared/praStarUnit.h	/^	const char *getName() { sprintf(name, "c%s", algorithm->getName()); return name; }$/;"	f	class:praStarUnit
getName	shared/rewardUnit.h	/^	virtual const char *getName() { return "rewardUnit"; }$/;"	f	class:rewardSeekingUnit
getName	shared/rewardUnit.h	/^	virtual const char *getName() { return "rewardUnit"; }$/;"	f	class:rewardUnit
getName	shared/searchUnit.h	/^	virtual const char *getName() { return algorithm->getName(); }$/;"	f	class:searchUnit
getName	shared/spreadExecSearchAlgorithm.h	/^	virtual const char *getName() { return "unnamed"; }$/;"	f	class:spreadExecSearchAlgorithm
getName	simulation/unit.h	/^	virtual const char *getName() { return "basicUnit"; }$/;"	f	class:unit
getName	simulation/unit.h	/^	virtual const char *getName() { return "billiardBallUnit"; }$/;"	f	class:billiardBallUnit
getName	simulation/unit.h	/^	virtual const char *getName() { return "randomUnit"; }$/;"	f	class:randomUnit
getName	simulation/unit.h	/^	virtual const char *getName() { return "randomerUnit"; }$/;"	f	class:randomerUnit
getName	simulation/unitGroup.h	/^	virtual const char *getName() { return "UnitGroupx"; }$/;"	f	class:unitGroup
getName	tests/AnnotatedAStarMock.h	/^		virtual const char* getName() { return "AnnotatedAStarMock"; }$/;"	f	class:AnnotatedAStarMock
getName	util/GenericAStar.cpp	/^const char *GenericAStar::getName()$/;"	f	class:GenericAStar
getName	util/graph.h	/^  const char *getName() const { return name; }$/;"	f	class:node
getNeighborIter	util/graph.cpp	/^neighbor_iterator node::getNeighborIter() const$/;"	f	class:node
getNeighbors	abstraction/AbstractionSearchEnvironment.cpp	/^void AbstractionSearchEnvironment::getNeighbors(uint32_t nodeID, std::vector<uint32_t> &neighbors)$/;"	f	class:AbstractionSearchEnvironment
getNeighbors	abstraction/clusterAbstraction.cpp	/^	void getNeighbors(uint32_t nodeID, std::vector<uint32_t> &neighbors)$/;"	f	class:ClusterSearchEnvironment
getNeighbors	util/SearchEnvironment.cpp	/^void GraphSearchEnvironment::getNeighbors(uint32_t nodeID, std::vector<uint32_t> &neighbors)$/;"	f	class:GraphSearchEnvironment
getNeighbors	util/SearchEnvironment.cpp	/^void MapSearchEnvironment::getNeighbors(uint32_t nodeID, std::vector<uint32_t> &neighbors)$/;"	f	class:MapSearchEnvironment
getNewTileCount	shared/sharedAMapGroup.h	/^	virtual int getNewTileCount() { return newTileCountPerTrial; }$/;"	f	class:sharedAMapGroup
getNewTileCountPerStep	shared/sharedAMapGroup.h	/^        int getNewTileCountPerStep() { return newTileCount; }$/;"	f	class:sharedAMapGroup
getNextNode	shared/aStar.cpp	/^node *aStar::getNextNode()$/;"	f	class:aStar
getNextNode	shared/craStar.cpp	/^node* craStar::getNextNode(graphAbstraction *aMap, node* currentLow, path* returnPath, path* apath, graph* g, int abstractLevel)$/;"	f	class:craStar
getNextNode	shared/craStar.cpp	/^node* craStar::getNextNode(mapAbstraction *m,int x, int y, int dir)$/;"	f	class:craStar
getNextNode	shared/hpaStar.cpp	/^node* hpaStar::getNextNode(int x, int y, int dir)$/;"	f	class:hpaStar
getNextNode	util/GenericAStar.cpp	/^uint32_t GenericAStar::getNextNode()$/;"	f	class:GenericAStar
getNode	aha/AnnotatedCluster.h	/^		node* getNode() { return problemNode; }$/;"	f	class:AnnotatedClusterException
getNode	tests/AnnotatedAStarTest.cpp	/^node* AnnotatedAStarTest::getNode(int x, int y, int nodeterrain)$/;"	f	class:AnnotatedAStarTest
getNode	util/graph.cpp	/^node *graph::getNode(unsigned int num)$/;"	f	class:graph
getNodeFromMap	abstraction/mapAbstraction.h	/^	node *getNodeFromMap(int x, int y, tCorner c = kNone) { return abstractions[0]->getNode(m->getNodeNum(x, y, c)); }$/;"	f	class:mapAbstraction
getNodeInGroup	abstraction/loadedCliqueAbstraction.cpp	/^node *loadedCliqueAbstraction::getNodeInGroup(node *parent, int group)$/;"	f	class:loadedCliqueAbstraction
getNodeInGroup	abstraction/mapCliqueAbstraction.cpp	/^node *mapCliqueAbstraction::getNodeInGroup(node *parent, int group)$/;"	f	class:mapCliqueAbstraction
getNodeIter	util/graph.cpp	/^node_iterator graph::getNodeIter() const$/;"	f	class:graph
getNodeLoc	abstraction/loadedCliqueAbstraction.cpp	/^recVec loadedCliqueAbstraction::getNodeLoc(node *n)$/;"	f	class:loadedCliqueAbstraction
getNodeLoc	abstraction/mapAbstraction.cpp	/^recVec mapAbstraction::getNodeLoc(node *n)$/;"	f	class:mapAbstraction
getNodeNum	util/map.cpp	/^int Map::getNodeNum(int x, int y, tCorner corner)$/;"	f	class:Map
getNodesExpanded	aha/AnnotatedClusterAbstraction.h	/^		int getNodesExpanded() { return nodesExpanded; }$/;"	f	class:AnnotatedClusterAbstraction
getNodesExpanded	shared/aStar.h	/^	long getNodesExpanded() { return nodesExpanded; }$/;"	f	class:aStar
getNodesExpanded	shared/searchAlgorithm.h	/^	long getNodesExpanded() { return nodesExpanded; }$/;"	f	class:searchAlgorithm
getNodesExpanded	util/GenericAStar.h	/^	long getNodesExpanded() { return nodesExpanded; }$/;"	f	class:GenericAStar
getNodesExpanded	util/GenericIDAStar.h	/^	long getNodesExpanded() { return nodesExpanded; }$/;"	f	class:GenericIDAStar
getNodesTouched	aha/AnnotatedClusterAbstraction.h	/^		int getNodesTouched() { return nodesTouched; }$/;"	f	class:AnnotatedClusterAbstraction
getNodesTouched	shared/aStar.h	/^	long getNodesTouched() { return nodesTouched; }$/;"	f	class:aStar
getNodesTouched	shared/searchAlgorithm.h	/^	long getNodesTouched() { return nodesTouched; }$/;"	f	class:searchAlgorithm
getNodesTouched	util/GenericAStar.h	/^	long getNodesTouched() { return nodesTouched; }$/;"	f	class:GenericAStar
getNodesTouched	util/GenericIDAStar.h	/^	long getNodesTouched() { return nodesTouched; }$/;"	f	class:GenericIDAStar
getNthChild	abstraction/graphAbstraction.h	/^	inline node *getNthChild(node *which, int n) { return abstractions[getAbstractionLevel(which)-1]->getNode(which->getLabelL(kFirstData+n)); }$/;"	f	class:graphAbstraction
getNthExperiment	aha/ScenarioManager.h	/^		Experiment* getNthExperiment(int which) { if(which < (int)experiments.size()) return experiments[which]; return 0; }$/;"	f	class:AbstractScenarioManager
getNthExperiment	shared/scenarioLoader.h	/^  Experiment getNthExperiment(int which){return experiments[which];}$/;"	f	class:ScenarioLoader
getNthParent	abstraction/graphAbstraction.cpp	/^node *graphAbstraction::getNthParent(node *which, int n)$/;"	f	class:graphAbstraction
getNum	util/graph.h	/^  unsigned int getNum() const { return nodeNum; }$/;"	f	class:node
getNumAbstractGraphs	abstraction/graphAbstraction.h	/^  unsigned int getNumAbstractGraphs() { return abstractions.size(); }$/;"	f	class:graphAbstraction
getNumChildren	abstraction/graphAbstraction.h	/^	inline long getNumChildren(node *which) { return which->getLabelL(kNumAbstractedNodes); }$/;"	f	class:graphAbstraction
getNumClusters	aha/AnnotatedClusterAbstraction.h	/^		virtual int getNumClusters() { return clusters.size(); } $/;"	f	class:AnnotatedClusterAbstraction
getNumEdges	util/graph.h	/^  inline int getNumEdges() { return _edges.size(); }$/;"	f	class:graph
getNumEdges	util/graph.h	/^  int getNumEdges() { return getNumOutgoingEdges()+getNumIncomingEdges(); }$/;"	f	class:node
getNumExperiments	aha/ScenarioManager.h	/^		int getNumExperiments() { return experiments.size(); }$/;"	f	class:AbstractScenarioManager
getNumExperiments	shared/scenarioLoader.h	/^  int getNumExperiments(){return experiments.size();}$/;"	f	class:ScenarioLoader
getNumExternalEdges	abstraction/graphAbstraction.cpp	/^int graphAbstraction::getNumExternalEdges(node *n, node *p)$/;"	f	class:graphAbstraction
getNumIncomingEdges	util/graph.cpp	/^int node::getNumIncomingEdges()$/;"	f	class:node
getNumLevelsUsed	shared/praStar2.h	/^  int getNumLevelsUsed() { return numLevels; }$/;"	f	class:praStar2
getNumNodes	abstraction/clusterAbstraction.h	/^	int getNumNodes() const { return nodes.size(); }$/;"	f	class:Cluster
getNumNodes	util/graph.h	/^  inline int getNumNodes() { return _nodes.size(); }$/;"	f	class:graph
getNumOutgoingEdges	util/graph.cpp	/^int node::getNumOutgoingEdges()$/;"	f	class:node
getNumSetBits	util/bitVector.cpp	/^int bitVector::getNumSetBits()$/;"	f	class:bitVector
getNumStats	util/statCollection.cpp	/^int statCollection::getNumStats() const$/;"	f	class:statCollection
getNumThinkSteps	shared/spreadPRAStar.cpp	/^int spreadPRAStar::getNumThinkSteps()$/;"	f	class:spreadPRAStar
getNumUnits	simulation/unitSimulation.h	/^	int getNumUnits() { return units.size(); }$/;"	f	class:unitSimulation
getNumberOfAbstractionLevels	aha/AnnotatedClusterAbstraction.h	/^		virtual int getNumberOfAbstractionLevels() { return abstractions.size(); }$/;"	f	class:AnnotatedClusterAbstraction
getObjectType	simulation/unit.h	/^	tObjectType getObjectType() { return unitType; }$/;"	f	class:unit
getOpenGLCoord	util/map.cpp	/^void Map::getOpenGLCoord(int _x, int _y, GLdouble &x, GLdouble &y, GLdouble &z, GLdouble &radius) const$/;"	f	class:Map
getOpenGLLocation	simulation/unit.cpp	/^void unit::getOpenGLLocation(Map *map, GLdouble &_x, GLdouble &_y, GLdouble &_z, GLdouble &radius)$/;"	f	class:unit
getOrientation	abstraction/clusterAbstraction.h	/^  int getOrientation() {return m_orientation;}$/;"	f	class:Entrance
getOutgoingEdgeIter	util/graph.cpp	/^edge_iterator node::getOutgoingEdgeIter() const$/;"	f	class:node
getOverlayValue	util/mapOverlay.cpp	/^double MapOverlay::getOverlayValue(int x, int y)$/;"	f	class:MapOverlay
getParent	abstraction/graphAbstraction.h	/^	inline node *getParent(node *which) { return abstractions[getAbstractionLevel(which)+1]->getNode(which->getLabelL(kParent)); }$/;"	f	class:graphAbstraction
getParentCluster	util/graph.cpp	/^int node::getParentCluster()$/;"	f	class:node
getParentHierarchy	abstraction/graphAbstraction.cpp	/^void graphAbstraction::getParentHierarchy(node *from, node *to,$/;"	f	class:graphAbstraction
getParents	abstraction/clusterAbstraction.h	/^	std::vector<node*>&  getParents() { return parents; } $/;"	f	class:Cluster
getPartialPathLimit	shared/craStar.h	/^	int getPartialPathLimit() { return partialLimit; }$/;"	f	class:craStar
getPartialPathLimit	shared/hpaStar.h	/^	int getPartialPathLimit() { return partialLimit; }$/;"	f	class:hpaStar
getPartialPathLimit	shared/praStar.h	/^	int getPartialPathLimit() { return partialLimit; }$/;"	f	class:praStar
getPartialPathLimit	shared/praStar2.h	/^	int getPartialPathLimit() { return partialLimit; }$/;"	f	class:praStar2
getPath	aha/AnnotatedAStar.cpp	/^path* AnnotatedAStar::getPath(graphAbstraction *aMap, node *from, node* to, reservationProvider *rp)$/;"	f	class:AnnotatedAStar
getPath	aha/AnnotatedHierarchicalAStar.cpp	/^path* AnnotatedHierarchicalAStar::getPath(graphAbstraction* aMap, node* from, node* to, reservationProvider *rp)$/;"	f	class:AnnotatedHierarchicalAStar
getPath	shared/aStar.cpp	/^path *aStar::getPath(graphAbstraction *aMap, node *from, node *to, reservationProvider *)$/;"	f	class:aStar
getPath	shared/aStar2.cpp	/^path *aStar2::getPath(graphAbstraction *aMap, node *from, node *to, reservationProvider *)$/;"	f	class:aStar2
getPath	shared/aStar3.cpp	/^path *aStarOld::getPath(graphAbstraction *aMap, node *from, node *to, reservationProvider *rp)$/;"	f	class:aStarOld
getPath	shared/corridorAStar.cpp	/^path *corridorAStar::getPath(graphAbstraction *aMap, node *from, node *to, reservationProvider *rp)$/;"	f	class:corridorAStar
getPath	shared/craStar.cpp	/^path *craStar::getPath(graphAbstraction *aMap, node *from, node *to, reservationProvider *rp)$/;"	f	class:craStar
getPath	shared/hpaStar.cpp	/^path* hpaStar::getPath(graphAbstraction *aMap, node* from, node* to, reservationProvider *rp)$/;"	f	class:hpaStar
getPath	shared/praStar.cpp	/^path *praStar::getPath(graphAbstraction *aMap, node *from, node *to, reservationProvider *_rp)$/;"	f	class:praStar
getPath	shared/praStar2.cpp	/^path *praStar2::getPath(graphAbstraction *aMap, node *from, node *to, reservationProvider *rp)$/;"	f	class:praStar2
getPath	shared/spreadExecSearchAlgorithm.cpp	/^path *spreadExecSearchAlgorithm::getPath(graphAbstraction *_aMap, node *from, node *to, reservationProvider *_rp)$/;"	f	class:spreadExecSearchAlgorithm
getPath	shared/spreadPRAStar.cpp	/^path *spreadPRAStar::getPath(graphAbstraction *_aMap, node *from, node *to, reservationProvider *_rp)$/;"	f	class:spreadPRAStar
getPath	tests/AnnotatedAStarMock.cpp	/^path* AnnotatedAStarMock::getPath(graphAbstraction* aMap, node* start, node* goal, reservationProvider *rp)$/;"	f	class:AnnotatedAStarMock
getPath	util/GenericAStar.cpp	/^void GenericAStar::getPath(SearchEnvironment *_env, uint32_t from, uint32_t to,$/;"	f	class:GenericAStar
getPath	util/GenericIDAStar.cpp	/^void GenericIDAStar::getPath(SearchEnvironment *env, uint32_t from, uint32_t to,$/;"	f	class:GenericIDAStar
getPathCacheSize	aha/AnnotatedClusterAbstraction.h	/^		int getPathCacheSize() { return pathCache.size(); };$/;"	f	class:AnnotatedClusterAbstraction
getPathClearance	aha/AnnotatedCluster.cpp	/^void AnnotatedCluster::getPathClearance(path *p, int& capability, int& clearance)$/;"	f	class:AnnotatedCluster
getPathEachNodeInReturnedPathHasAnEdgeToItsPredecessor	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathEachNodeInReturnedPathHasAnEdgeToItsPredecessor()$/;"	f	class:AnnotatedAStarTest
getPathFailsToReturnASoltuionWhenNoneExistsWithinTheCorridorBounds	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathFailsToReturnASoltuionWhenNoneExistsWithinTheCorridorBounds()$/;"	f	class:AnnotatedAStarTest
getPathFromCache	aha/AnnotatedClusterAbstraction.cpp	/^path* AnnotatedClusterAbstraction::getPathFromCache(edge* e)$/;"	f	class:AnnotatedClusterAbstraction
getPathFromCache	tests/AnnotatedClusterAbstractionMock.h	/^		virtual path* getPathFromCache(edge* e) { return lastAdded; }$/;"	f	class:AnnotatedClusterAbstractionMock
getPathFromCacheShouldReturnAPathGivenAValidEdge	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::getPathFromCacheShouldReturnAPathGivenAValidEdge()$/;"	f	class:AnnotatedClusterAbstractionTest
getPathFromCacheShouldReturnZeroGivenAnEdgeThatHasNoCorrespondingPathInCache	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::getPathFromCacheShouldReturnZeroGivenAnEdgeThatHasNoCorrespondingPathInCache()$/;"	f	class:AnnotatedClusterAbstractionTest
getPathFromCacheShouldReturnZeroGivenAnInvalidEdge	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::getPathFromCacheShouldReturnZeroGivenAnInvalidEdge()$/;"	f	class:AnnotatedClusterAbstractionTest
getPathGoalClearanceTooSmall	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathGoalClearanceTooSmall()$/;"	f	class:AnnotatedAStarTest
getPathInitialisesFCostValueOfStartToHeuristicGoalDistance	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathInitialisesFCostValueOfStartToHeuristicGoalDistance()$/;"	f	class:AnnotatedAStarTest
getPathReturnNulWhenAgentSizeParamLessThanMin	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathReturnNulWhenAgentSizeParamLessThanMin()$/;"	f	class:AnnotatedAStarTest
getPathReturnNullOnInvalidCapabilityParam	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathReturnNullOnInvalidCapabilityParam()$/;"	f	class:AnnotatedAStarTest
getPathReturnNullWhenGoalHardObstacle	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathReturnNullWhenGoalHardObstacle()$/;"	f	class:AnnotatedAStarTest
getPathReturnNullWhenGoalSoftObstacle	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathReturnNullWhenGoalSoftObstacle()$/;"	f	class:AnnotatedAStarTest
getPathReturnNullWhenHardObstacleBlocksGoal	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathReturnNullWhenHardObstacleBlocksGoal()$/;"	f	class:AnnotatedAStarTest
getPathReturnNullWhenMapAbstractionParameterNull	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathReturnNullWhenMapAbstractionParameterNull()$/;"	f	class:AnnotatedAStarTest
getPathReturnNullWhenNonAnnotatedMapAbstractionParameter	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathReturnNullWhenNonAnnotatedMapAbstractionParameter()$/;"	f	class:AnnotatedAStarTest
getPathReturnNullWhenSoftObstacleBlocksGoal	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathReturnNullWhenSoftObstacleBlocksGoal()$/;"	f	class:AnnotatedAStarTest
getPathReturnNullWhenStartAndGoalNodesIdentical	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathReturnNullWhenStartAndGoalNodesIdentical()$/;"	f	class:AnnotatedAStarTest
getPathReturnNullWhenStartAndGoalSameLocation	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathReturnNullWhenStartAndGoalSameLocation()$/;"	f	class:AnnotatedAStarTest
getPathReturnNullWhenStartHardObstacle	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathReturnNullWhenStartHardObstacle()$/;"	f	class:AnnotatedAStarTest
getPathReturnNullWhenStartOrGoalNull	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathReturnNullWhenStartOrGoalNull()$/;"	f	class:AnnotatedAStarTest
getPathReturnNullWhenStartSoftObstacle	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathReturnNullWhenStartSoftObstacle()$/;"	f	class:AnnotatedAStarTest
getPathReturnsTheShortestPathWithinCorridorBounds	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathReturnsTheShortestPathWithinCorridorBounds()$/;"	f	class:AnnotatedAStarTest
getPathShouldAddInsertionEffortToPerformanceMetrics	tests/AnnotatedHierarchicalAStarTest.cpp	/^void AnnotatedHierarchicalAStarTest::getPathShouldAddInsertionEffortToPerformanceMetrics()$/;"	f	class:AnnotatedHierarchicalAStarTest
getPathShouldFindASolutionEvenWhenCacheReturnsAPathInReverseOrderToRequirements	tests/AnnotatedHierarchicalAStarTest.cpp	/^void AnnotatedHierarchicalAStarTest::getPathShouldFindASolutionEvenWhenCacheReturnsAPathInReverseOrderToRequirements()$/;"	f	class:AnnotatedHierarchicalAStarTest
getPathShouldFindASolutionWithoutInsertingIntoTheAbstractGraphIfBothStartAndGoalAreInTheSameCluster	tests/AnnotatedHierarchicalAStarTest.cpp	/^void AnnotatedHierarchicalAStarTest::getPathShouldFindASolutionWithoutInsertingIntoTheAbstractGraphIfBothStartAndGoalAreInTheSameCluster()$/;"	f	class:AnnotatedHierarchicalAStarTest
getPathShouldRemoveAllInsertedNodesAndEdgesFromTheAbstractPathAndPathCacheIfTheSearchFailsToFindASolution	tests/AnnotatedHierarchicalAStarTest.cpp	/^void AnnotatedHierarchicalAStarTest::getPathShouldRemoveAllInsertedNodesAndEdgesFromTheAbstractPathAndPathCacheIfTheSearchFailsToFindASolution()$/;"	f	class:AnnotatedHierarchicalAStarTest
getPathShouldRemoveAllInsertedNodesAndEdgesFromTheAbstractPathAndPathCacheIfTheSearchFindsASolution	tests/AnnotatedHierarchicalAStarTest.cpp	/^void AnnotatedHierarchicalAStarTest::getPathShouldRemoveAllInsertedNodesAndEdgesFromTheAbstractPathAndPathCacheIfTheSearchFindsASolution()$/;"	f	class:AnnotatedHierarchicalAStarTest
getPathShouldReturnTheShortestPathBetweenTwoLowLevelNodesGivenACapabilityAndClearanceAndAnnotatedClusterAbstractionParameter	tests/AnnotatedHierarchicalAStarTest.cpp	/^void AnnotatedHierarchicalAStarTest::getPathShouldReturnTheShortestPathBetweenTwoLowLevelNodesGivenACapabilityAndClearanceAndAnnotatedClusterAbstractionParameter()$/;"	f	class:AnnotatedHierarchicalAStarTest
getPathStartClearanceTooSmall	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathStartClearanceTooSmall()$/;"	f	class:AnnotatedAStarTest
getPathToNode	shared/aStar.cpp	/^path *aStar::getPathToNode(node *target)$/;"	f	class:aStar
getPathWhenSolutionExistsForGroundCapabilityLST	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::getPathWhenSolutionExistsForGroundCapabilityLST()$/;"	f	class:AnnotatedAStarTest
getPeakMemory	aha/AnnotatedAStar.h	/^		long getPeakMemory() { return peakmemory; }$/;"	f	class:AbstractAnnotatedAStar
getPeakMemory	aha/AnnotatedClusterAbstraction.h	/^		int getPeakMemory() { return peakMemory; }$/;"	f	class:AnnotatedClusterAbstraction
getPenalty	simulation/unitSimulation.h	/^	double getPenalty() { return penalty; }$/;"	f	class:unitSimulation
getPointFromCoordinate	util/map.cpp	/^void Map::getPointFromCoordinate(point3d loc, int &px, int &py) const$/;"	f	class:Map
getQuadrant	abstraction/mapQuadTreeAbstraction.cpp	/^int mapQuadTreeAbstraction::getQuadrant(node *which)$/;"	f	class:mapQuadTreeAbstraction
getQualityParam	aha/AnnotatedClusterAbstraction.h	/^		ACAUtil::GraphQualityParameter getQualityParam() { return quality; }$/;"	f	class:AnnotatedClusterAbstraction
getRandomEdge	util/graph.cpp	/^edge *graph::getRandomEdge()$/;"	f	class:graph
getRandomEdge	util/graph.cpp	/^edge *node::getRandomEdge()$/;"	f	class:node
getRandomIncomingEdge	util/graph.cpp	/^edge *node::getRandomIncomingEdge()$/;"	f	class:node
getRandomLocation	simulation/unitSimulation.cpp	/^void unitSimulation::getRandomLocation(int &x, int &y, tTerrain terrain)$/;"	f	class:unitSimulation
getRandomLocation	simulation/unitSimulation.cpp	/^void unitSimulation::getRandomLocation(int x1, int y1, int &x2, int &y2, tTerrain terrain)$/;"	f	class:unitSimulation
getRandomLocations	simulation/unitSimulation.cpp	/^void unitSimulation::getRandomLocations(int &x1, int &y1, int &x2, int &y2, tTerrain terrain)$/;"	f	class:unitSimulation
getRandomNode	util/graph.cpp	/^node *graph::getRandomNode()$/;"	f	class:graph
getRandomOutgoingEdge	util/graph.cpp	/^edge *node::getRandomOutgoingEdge()$/;"	f	class:node
getRandomTileFromNode	abstraction/mapAbstraction.cpp	/^void mapAbstraction::getRandomTileFromNode(node *n, int &x, int &y)$/;"	f	class:mapAbstraction
getReachableNodes	util/graph.cpp	/^vector<node*>* graph::getReachableNodes(node* start)$/;"	f	class:graph
getRealTime	simulation/unitSimulation.h	/^	bool getRealTime() { return realTime; }$/;"	f	class:unitSimulation
getRevision	util/map.h	/^  int getRevision() { return revision; }$/;"	f	class:Map
getRow	abstraction/clusterAbstraction.h	/^  int getRow() {return m_row;}$/;"	f	class:Entrance
getSaveFSSpec	driver/MAC/mac_main.cpp	/^OSStatus getSaveFSSpec(WindowRef parentWin, CFStringRef title, CFStringRef action, CFStringRef file, CFStringRef message, FSSpec &fileRef)$/;"	f
getScenarioName	shared/scenarioLoader.h	/^	const char *getScenarioName() { return scenName; }$/;"	f	class:ScenarioLoader
getSearchAlgorithm	aha/AnnotatedMapAbstraction.h	/^		virtual AbstractAnnotatedAStar* getSearchAlgorithm() { return searchalg; }$/;"	f	class:AbstractAnnotatedMapAbstraction
getSearchTime	aha/AnnotatedAStar.h	/^		double getSearchTime() { return searchtime; }$/;"	f	class:AbstractAnnotatedAStar
getSearchTime	aha/AnnotatedClusterAbstraction.h	/^		double getSearchTime() { return searchTime; }$/;"	f	class:AnnotatedClusterAbstraction
getSimulationPaused	simulation/unitSimulation.h	/^	bool getSimulationPaused() { return pause; }$/;"	f	class:unitSimulation
getSimulationTime	simulation/unitSimulation.h	/^	double getSimulationTime() { return currTime; }$/;"	f	class:unitSimulation
getSize	util/bitVector.h	/^  int getSize() { return true_size; }$/;"	f	class:bitVector
getSpeed	simulation/unit.h	/^	virtual double getSpeed() { return speed; }$/;"	f	class:unit
getSplit	util/map.cpp	/^tSplit Map::getSplit(long x, long y) const$/;"	f	class:Map
getStartNode	tests/ExperimentManager.cpp	/^node* ExpMgrUtil::TestExperiment::getStartNode()$/;"	f	class:ExpMgrUtil::TestExperiment
getStartX	shared/scenarioLoader.h	/^  int getStartX(){return startx;}$/;"	f	class:Experiment
getStartY	shared/scenarioLoader.h	/^  int getStartY(){return starty;}$/;"	f	class:Experiment
getStatNum	util/statCollection.cpp	/^const stat *statCollection::getStatNum(int which) const$/;"	f	class:statCollection
getStats	simulation/unitSimulation.h	/^	statCollection *getStats() { return &stats; }$/;"	f	class:unitSimulation
getTarget	shared/patrolUnit.cpp	/^unit *patrolUnit::getTarget()$/;"	f	class:patrolUnit
getTarget	simulation/unit.h	/^	unit *getTarget() { return target; }$/;"	f	class:unit
getTargetTolerance	simulation/unitRaceSimulation.h	/^	double getTargetTolerance() { return targetTolerance; }$/;"	f	class:unitRaceSimulation
getTerrainType	util/graph.cpp	/^int node::getTerrainType()$/;"	f	class:node
getTerrainType	util/map.cpp	/^long Map::getTerrainType(long x, long y, tEdge side) const$/;"	f	class:Map
getTerrainType	util/map.cpp	/^long Map::getTerrainType(long x, long y, tSplitSide split) const$/;"	f	class:Map
getTile	util/map.cpp	/^Tile &Map::getTile(long x, long y)$/;"	f	class:Map
getTileFromNode	abstraction/mapAbstraction.cpp	/^void mapAbstraction::getTileFromNode(node *n, int &x, int &y)$/;"	f	class:mapAbstraction
getTileSet	util/map.cpp	/^tTileset Map::getTileSet()$/;"	f	class:Map
getTileUnderLoc	abstraction/mapAbstraction.cpp	/^void mapAbstraction::getTileUnderLoc(int &x, int &y, const recVec &v)$/;"	f	class:mapAbstraction
getTimerUPP	driver/MAC/mac_main.cpp	/^static EventLoopTimerUPP getTimerUPP(void)$/;"	f	file:
getTo	util/graph.h	/^	unsigned int getTo() { return to; }$/;"	f	class:edge
getToClusterId	tests/AnnotatedClusterTest.h	/^		int getToClusterId() { return toClusterId; }$/;"	f	class:TestEntrance
getToX	tests/AnnotatedClusterTest.h	/^		int getToX() { return tox; }$/;"	f	class:TestEntrance
getToY	tests/AnnotatedClusterTest.h	/^		int getToY() { return toy; }$/;"	f	class:TestEntrance
getTopLevel	shared/praStar2.h	/^  int getTopLevel() { return topLevel; }$/;"	f	class:praStar2
getUniqueID	util/graph.h	/^  int getUniqueID() const { return uniqueID; }$/;"	f	class:graph_object
getUnit	simulation/unitGroup.cpp	/^unit *unitGroup::getUnit(unsigned int which)$/;"	f	class:unitGroup
getUnit	simulation/unitSimulation.cpp	/^unit *unitSimulation::getUnit(int which)$/;"	f	class:unitSimulation
getUnitGroup	simulation/unit.h	/^	unitGroup *getUnitGroup() { return group; }$/;"	f	class:unit
getUnitGroup	simulation/unitSimulation.cpp	/^unitGroup *unitSimulation::getUnitGroup(int which)$/;"	f	class:unitSimulation
getUnitID	simulation/unit.h	/^	int getUnitID() { return id; }$/;"	f	class:unit
getVOrig	abstraction/clusterAbstraction.h	/^	int getVOrig() const { return m_vertOrigin; }$/;"	f	class:Cluster
getVisibilityRadius	shared/sharedAMapGroup.cpp	/^int sharedAMapGroup::getVisibilityRadius()$/;"	f	class:sharedAMapGroup
getWeight	util/graph.h	/^	double getWeight() { return getLabelF(kEdgeWeight); }$/;"	f	class:edge
getWidth	abstraction/clusterAbstraction.h	/^	int getWidth() const { return m_width; } $/;"	f	class:Cluster
getWidth	util/graph.h	/^	double getWidth() { return getLabelF(kEdgeWidth); }$/;"	f	class:edge
getWidth	util/graph.h	/^  double getWidth() { return width; }$/;"	f	class:node
getXScale	shared/scenarioLoader.h	/^  int getXScale(){return scaleX;}$/;"	f	class:Experiment
getYScale	shared/scenarioLoader.h	/^  int getYScale(){return scaleY;}$/;"	f	class:Experiment
gfAddAsChild	driver/MAC/HID Support/HID_Utilities.cpp	/^Boolean gfAddAsChild = true;$/;"	v
glBegin	driver/STUB/GL/gl.cpp	/^void glBegin ( GLenum mode ) {};$/;"	f
glBindTexture	driver/STUB/GL/gl.cpp	/^void glBindTexture(GLenum target, GLuint texture) {};$/;"	f
glBlendFunc	driver/STUB/GL/gl.cpp	/^void glBlendFunc ( GLenum sfactor, GLenum dfactor ) {};$/;"	f
glCallList	driver/STUB/GL/gl.cpp	/^void glCallList ( GLuint list ) {};$/;"	f
glClear	driver/STUB/GL/gl.cpp	/^void glClear ( GLbitfield mask ) {};$/;"	f
glClearColor	driver/STUB/GL/gl.cpp	/^void glClearColor ( GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha ) {};$/;"	f
glColor3f	driver/STUB/GL/gl.cpp	/^void glColor3f ( GLfloat red, GLfloat green, GLfloat blue ) {};$/;"	f
glColor3fv	driver/STUB/GL/gl.cpp	/^void glColor3fv ( const GLfloat *v ) {}; $/;"	f
glColor4f	driver/STUB/GL/gl.cpp	/^void glColor4f ( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha ) {};$/;"	f
glColorMaterial	driver/STUB/GL/gl.cpp	/^void glColorMaterial ( GLenum face, GLenum mode ) {};$/;"	f
glCullFace	driver/STUB/GL/gl.cpp	/^void glCullFace(GLenum mode) {};$/;"	f
glDeleteLists	driver/STUB/GL/gl.cpp	/^void glDeleteLists ( GLuint list, GLsizei range ) {};$/;"	f
glDepthMask	driver/STUB/GL/gl.cpp	/^void glDepthMask(GLboolean b) {};$/;"	f
glDisable	driver/STUB/GL/gl.cpp	/^void glDisable ( GLenum cap ) {};$/;"	f
glEnable	driver/STUB/GL/gl.cpp	/^void glEnable ( GLenum cap ) {};$/;"	f
glEnd	driver/STUB/GL/gl.cpp	/^void glEnd () {};$/;"	f
glEndList	driver/STUB/GL/gl.cpp	/^void glEndList () {}; $/;"	f
glFrontFace	driver/STUB/GL/gl.cpp	/^void glFrontFace( GLenum mode ) {};$/;"	f
glFrustum	driver/STUB/GL/gl.cpp	/^void glFrustum ( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, $/;"	f
glGenLists	driver/STUB/GL/gl.cpp	/^GLuint glGenLists ( GLsizei range ) {return 0;};$/;"	f
glGenTextures	driver/STUB/GL/gl.cpp	/^void glGenTextures(GLsizei n, GLuint *texture) {};$/;"	f
glGetBooleanv	driver/STUB/GL/gl.cpp	/^void glGetBooleanv ( GLenum pname, GLboolean *params ) {};$/;"	f
glGetDoublev	driver/STUB/GL/gl.cpp	/^void glGetDoublev ( GLenum pname, GLdouble *params ) {};$/;"	f
glGetFloatv	driver/STUB/GL/gl.cpp	/^void glGetFloatv ( GLenum pname, GLfloat *params ) {};$/;"	f
glGetIntegerv	driver/STUB/GL/gl.cpp	/^void glGetIntegerv ( GLenum pname, GLint *params ) {};$/;"	f
glGetString	driver/STUB/GL/gl.cpp	/^const GLubyte* glGetString ( GLenum name ) { return 0; };$/;"	f
glIsEnabled	driver/STUB/GL/gl.cpp	/^GLboolean glIsEnabled ( GLenum cap ) {return false;};$/;"	f
glLightModeli	driver/STUB/GL/gl.cpp	/^void glLightModeli ( GLenum pname, GLint param ) {};$/;"	f
glLightfv	driver/STUB/GL/gl.cpp	/^void glLightfv ( GLenum light, GLenum pname, const GLfloat *params ) {};$/;"	f
glLineWidth	driver/STUB/GL/gl.cpp	/^void glLineWidth ( GLfloat width ) {};$/;"	f
glLoadIdentity	driver/STUB/GL/gl.cpp	/^void glLoadIdentity () {};$/;"	f
glMaterialfv	driver/STUB/GL/gl.cpp	/^void glMaterialfv ( GLenum face, GLenum pname, const GLfloat *params ) {};$/;"	f
glMatrixMode	driver/STUB/GL/gl.cpp	/^void glMatrixMode ( GLenum mode ) {};$/;"	f
glNewList	driver/STUB/GL/gl.cpp	/^void glNewList ( GLuint list, GLenum mode ) {};$/;"	f
glNormal3f	driver/STUB/GL/gl.cpp	/^void glNormal3f ( GLfloat nx, GLfloat ny, GLfloat nz ) {};$/;"	f
glNormal3fv	driver/STUB/GL/gl.cpp	/^void glNormal3fv(const GLfloat *v) {};$/;"	f
glPolygonMode	driver/STUB/GL/gl.cpp	/^void glPolygonMode ( GLenum face, GLenum mode ) {};$/;"	f
glPolygonOffset	driver/STUB/GL/gl.cpp	/^void glPolygonOffset ( GLfloat factor, GLfloat units ) {};$/;"	f
glPopMatrix	driver/STUB/GL/gl.cpp	/^void glPopMatrix () {};$/;"	f
glPushMatrix	driver/STUB/GL/gl.cpp	/^void glPushMatrix () {};$/;"	f
glRasterPos3d	driver/STUB/GL/gl.cpp	/^void glRasterPos3d ( GLdouble x, GLdouble y, GLdouble z ) {};$/;"	f
glReadPixels	driver/STUB/GL/gl.cpp	/^void glReadPixels ( GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels ) {};$/;"	f
glReportError	driver/MAC/mac_main.cpp	/^OSStatus glReportError(void)$/;"	f
glRotatef	driver/STUB/GL/gl.cpp	/^void glRotatef ( GLfloat angle, GLfloat x, GLfloat y, GLfloat z ) {};$/;"	f
glScalef	driver/STUB/GL/gl.cpp	/^void glScalef ( GLfloat x, GLfloat y, GLfloat z ) {};$/;"	f
glShadeModel	driver/STUB/GL/gl.cpp	/^void glShadeModel ( GLenum mode ) {};$/;"	f
glTexCoord2f	driver/STUB/GL/gl.cpp	/^void glTexCoord2f(GLfloat s, GLfloat t) {};$/;"	f
glTexParameteri	driver/STUB/GL/gl.cpp	/^void glTexParameteri(GLenum target, GLenum pname, GLint param) {};$/;"	f
glTranslated	driver/STUB/GL/gl.cpp	/^void glTranslated ( GLdouble x, GLdouble y, GLdouble z ) {};$/;"	f
glTranslatef	driver/STUB/GL/gl.cpp	/^void glTranslatef ( GLfloat x, GLfloat y, GLfloat z ) {};$/;"	f
glVersion	driver/MAC/macGlCheck.h	/^  unsigned short glVersion; \/\/ bcd gl version (ie. 1.4 is 0x0140)$/;"	m	struct:__anon15
glVertex2f	driver/STUB/GL/gl.cpp	/^void glVertex2f ( GLfloat x, GLfloat y ) {};$/;"	f
glVertex3d	driver/STUB/GL/gl.cpp	/^void glVertex3d ( GLdouble x, GLdouble y, GLdouble z ) {};$/;"	f
glVertex3f	driver/STUB/GL/gl.cpp	/^void glVertex3f ( GLfloat x, GLfloat y, GLfloat z ) {};$/;"	f
glViewport	driver/STUB/GL/gl.cpp	/^void glViewport ( GLint x, GLint y, GLsizei width, GLsizei height ) {};$/;"	f
gluBuild2DMipmaps	driver/STUB/GL/gl.cpp	/^GLint gluBuild2DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data) { return 0; };$/;"	f
gluLookAt	driver/STUB/GL/glut.cpp	/^void gluLookAt (GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, $/;"	f
gluUnProject	driver/STUB/GL/gl.cpp	/^int gluUnProject (GLdouble winx, GLdouble winy, GLdouble winz,$/;"	f
glutAddMenuEntry	driver/STUB/GL/glut.cpp	/^void glutAddMenuEntry (char *label, int value) {};$/;"	f
glutAddSubMenu	driver/STUB/GL/glut.cpp	/^void glutAddSubMenu (char *label, int submenu) {};$/;"	f
glutAttachMenu	driver/STUB/GL/glut.cpp	/^void glutAttachMenu (int button) {};$/;"	f
glutCreateMenu	driver/STUB/GL/glut.cpp	/^int glutCreateMenu (void (*) (int)) {return 0;};$/;"	f
glutCreateWindow	driver/STUB/GL/glut.cpp	/^int glutCreateWindow (char *title) {return 0;};$/;"	f
glutDisplayFunc	driver/STUB/GL/glut.cpp	/^void glutDisplayFunc (void (*) (void)) {};$/;"	f
glutGet	driver/STUB/GL/glut.cpp	/^int glutGet (GLenum type) {return 0;};$/;"	f
glutGetModifiers	driver/STUB/GL/glut.cpp	/^int glutGetModifiers (void) {return 0;};$/;"	f
glutIdleFunc	driver/STUB/GL/glut.cpp	/^int glutIdleFunc (void (*)(void)) {return 0;};$/;"	f
glutInit	driver/STUB/GL/glut.cpp	/^void glutInit (int *argcp, char **argv) {};$/;"	f
glutInitDisplayMode	driver/STUB/GL/glut.cpp	/^void glutInitDisplayMode (unsigned int mode) {};$/;"	f
glutInitWindowPosition	driver/STUB/GL/glut.cpp	/^void glutInitWindowPosition (int x, int y) {};$/;"	f
glutInitWindowSize	driver/STUB/GL/glut.cpp	/^void glutInitWindowSize (int width, int height) {};$/;"	f
glutKeyboardFunc	driver/STUB/GL/glut.cpp	/^void glutKeyboardFunc (void (*) (unsigned char key, int x, int y)) {};$/;"	f
glutMainLoop	driver/STUB/GL/glut.cpp	/^void glutMainLoop (void) { $/;"	f
glutMotionFunc	driver/STUB/GL/glut.cpp	/^void glutMotionFunc (void (*) (int x, int y)) {};$/;"	f
glutMouseFunc	driver/STUB/GL/glut.cpp	/^void glutMouseFunc (void (*) (int button, int state, int x, int y)) {};$/;"	f
glutReshapeFunc	driver/STUB/GL/glut.cpp	/^void glutReshapeFunc (void (*) (int width, int height)) {};$/;"	f
glutSwapBuffers	driver/STUB/GL/glut.cpp	/^void glutSwapBuffers (void) {};$/;"	f
gnode	tests/ExperimentManager.h	/^			node *snode, *gnode;$/;"	m	class:ExpMgrUtil::TestExperiment
goToLoc	shared/patrolUnit.cpp	/^double patrolUnit::goToLoc(mapAbstraction *aMap, int which)$/;"	f	class:patrolUnit
goToRewardLoc	shared/rewardUnit.cpp	/^double rewardSeekingUnit::goToRewardLoc(mapAbstraction *aMap, int which)$/;"	f	class:rewardSeekingUnit
goal	shared/aStar.h	/^	node *goal, *start;$/;"	m	class:aStar
goal	util/GenericAStar.h	/^	uint32_t goal, start;$/;"	m	class:GenericAStar
goalTest	util/SearchEnvironment.h	/^	virtual bool goalTest(uint32_t node, uint32_t goal) { return (node == goal); }$/;"	f	class:SearchEnvironment
goalid	aha/AnnotatedClusterAbstraction.h	/^		int startid, goalid;$/;"	m	class:AnnotatedClusterAbstraction
goalx	shared/scenarioLoader.h	/^  int startx, starty, goalx, goaly;$/;"	m	class:Experiment
goalx	tests/ExperimentManager.h	/^			int goalx;$/;"	m	class:ExpMgrUtil::TestExperiment
goaly	shared/scenarioLoader.h	/^  int startx, starty, goalx, goaly;$/;"	m	class:Experiment
goaly	tests/ExperimentManager.h	/^			int goaly;$/;"	m	class:ExpMgrUtil::TestExperiment
gogoGadgetNOGUIScenario	apps/sample/sample.cpp	/^void gogoGadgetNOGUIScenario(AnnotatedClusterAbstraction* aca)$/;"	f
gpDeviceList	driver/MAC/HID Support/HID_Utilities.cpp	/^pRecDevice gpDeviceList = NULL;$/;"	v
graph	util/graph.cpp	/^graph::graph()$/;"	f	class:graph
graph	util/graph.h	/^class graph : public graph_object {$/;"	c
graphAbstraction	abstraction/graphAbstraction.h	/^	graphAbstraction() :abstractions() {}$/;"	f	class:graphAbstraction
graphAbstraction	abstraction/graphAbstraction.h	/^class graphAbstraction {$/;"	c
graphAbstraction_H	abstraction/graphAbstraction.h	/^#define graphAbstraction_H$/;"	d
graph_object	util/graph.h	/^  graph_object():key(0) { debuginfo = false; 	uniqueID = uniqueIDCounter++; }$/;"	f	class:graph_object
graph_object	util/graph.h	/^class graph_object {$/;"	c
group	simulation/unit.h	/^	unitGroup *group;$/;"	m	class:unit
groupID	simulation/unitGroup.cpp	/^int unitGroup::groupID = 0;$/;"	m	class:unitGroup	file:
groupID	simulation/unitGroup.h	/^	static int groupID;$/;"	m	class:unitGroup
groups	abstraction/mapFlatAbstraction.h	/^		std::vector<int> groups;$/;"	m	class:mapFlatAbstraction
groupsValid	abstraction/mapFlatAbstraction.h	/^		bool groupsValid;$/;"	m	class:mapFlatAbstraction
gterrain	tests/ExperimentManager.h	/^			int gterrain;$/;"	m	class:ExpMgrUtil::TestExperiment
h	abstraction/loadedCliqueAbstraction.cpp	/^double loadedCliqueAbstraction::h(node *a, node *b)$/;"	f	class:loadedCliqueAbstraction
h	abstraction/mapAbstraction.cpp	/^double mapAbstraction::h(node *a, node *b)$/;"	f	class:mapAbstraction
h	aha/AnnotatedClusterAbstraction.cpp	/^double AnnotatedClusterAbstraction::h(node* a, node*b) throw(NodeIsNullException)$/;"	f	class:AnnotatedClusterAbstraction
h	util/timer.h	/^		struct { uint32_t l, h; } c4;$/;"	m	struct:Timer::CycleCounter::__anon27::__anon28
hGDevice	driver/MAC/macGlCheck.h	/^  GDHandle hGDevice; \/\/ graphics device handle$/;"	m	struct:__anon15
hShouldProduceIdenticalResultsToOverriddenMethodInMapAbstractionGivenTwoValidNodeParameters	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::hShouldProduceIdenticalResultsToOverriddenMethodInMapAbstractionGivenTwoValidNodeParameters()$/;"	f	class:AnnotatedClusterAbstractionTest
hShouldThrowExceptionGivenANullNodeParameter	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::hShouldThrowExceptionGivenANullNodeParameter()$/;"	f	class:AnnotatedClusterAbstractionTest
halfTile	util/map.cpp	/^halfTile::halfTile()$/;"	f	class:halfTile
halfTile	util/map.h	/^class halfTile {$/;"	c
handleConfigDMEvent	driver/MAC/mac_main.cpp	/^void handleConfigDMEvent(void *, short theMessage, void *)$/;"	f
handleJoystickMovement	driver/common.cpp	/^void handleJoystickMovement(pRecContext pContextInfo, double panX, double panY)$/;"	f
handleKeyInput	driver/MAC/mac_main.cpp	/^static OSStatus handleKeyInput (EventHandlerCallRef myHandler, EventRef event, Boolean keyDown, void* userData)$/;"	f	file:
handleMouseClick	driver/common.cpp	/^bool handleMouseClick(pRecContext pContextInfo, int x, int y, point3d where,$/;"	f
handleWindowDMEvent	driver/MAC/mac_main.cpp	/^void handleWindowDMEvent(void *userData, short theMessage, void *)$/;"	f
handleWindowMouseEvents	driver/MAC/mac_main.cpp	/^static OSStatus handleWindowMouseEvents (EventHandlerCallRef myHandler, EventRef event)$/;"	f	file:
handleWindowUpdate	driver/MAC/mac_main.cpp	/^static void handleWindowUpdate(WindowRef window)$/;"	f	file:
hasCenter	driver/MAC/HID Support/HID_Utilities_External.h	/^    unsigned char  hasCenter; 				\/\/ whether or not to use center for calibration$/;"	m	struct:recElement
hasCycle	abstraction/width.cpp	/^bool hasCycle(edge* e, vector<int> nodes)$/;"	f
hasMoreInterEdges	aha/AnnotatedClusterAbstraction.cpp	/^bool AnnotatedClusterAbstraction::hasMoreInterEdges(node* n, graph* absg)$/;"	f	class:AnnotatedClusterAbstraction
hats	driver/MAC/HID Support/HID_Utilities.h	/^    long hats;								\/\/ number of hat switches (calculated, not reported by device)$/;"	m	struct:recDevice
hats	driver/MAC/HID Support/HID_Utilities_External.h	/^    long hats;								\/\/ number of hat switches (calculated, not reported by device)$/;"	m	struct:recDevice
heap	util/heap.cpp	/^heap::heap(int s)$/;"	f	class:heap
heap	util/heap.h	/^class heap {$/;"	c
heap2	util/heap2.h	/^class heap2 {$/;"	c
heap2	util/heap2.h	/^heap2<OBJ, HashKey, EqKey, CmpKey>::heap2()$/;"	f	class:heap2
heapifyDown	util/heap.cpp	/^void heap::heapifyDown(int index)$/;"	f	class:heap
heapifyDown	util/heap2.h	/^void heap2<OBJ, HashKey, EqKey, CmpKey>::heapifyDown(unsigned int index)$/;"	f	class:heap2
heapifyUp	util/heap.cpp	/^void heap::heapifyUp(int index)$/;"	f	class:heap
heapifyUp	util/heap2.h	/^void heap2<OBJ, HashKey, EqKey, CmpKey>::heapifyUp(unsigned int index)$/;"	f	class:heap2
height	aha/AnnotatedCluster.h	/^		int width, height, xorigin, yorigin;$/;"	m	class:InvalidClusterDimensionsException
height	driver/MAC/mac_main.cpp	/^	int width, height;$/;"	m	class:movieFrame	file:
height	driver/main.h	/^   float height;$/;"	m	struct:CGSize
height	util/map.h	/^	int width, height;$/;"	m	class:Map
heuristic	abstraction/AbstractionSearchEnvironment.cpp	/^double AbstractionSearchEnvironment::heuristic(uint32_t node1, uint32_t node2)$/;"	f	class:AbstractionSearchEnvironment
heuristic	abstraction/clusterAbstraction.cpp	/^	double heuristic(uint32_t node1, uint32_t node2)$/;"	f	class:ClusterSearchEnvironment
heuristic	util/SearchEnvironment.cpp	/^double GraphSearchEnvironment::heuristic(uint32_t node1, uint32_t node2)$/;"	f	class:GraphSearchEnvironment
heuristic	util/SearchEnvironment.cpp	/^double MapSearchEnvironment::heuristic(uint32_t node1, uint32_t node2)$/;"	f	class:MapSearchEnvironment
highquality	apps/sample/sample.cpp	/^bool highquality=true;$/;"	v
historyIndex	simulation/unitSimulation.h	/^	unsigned int historyIndex;$/;"	m	class:unitInfo
hit	abstraction/mapCliqueAbstraction.h	/^	std::vector<int> hit;$/;"	m	class:mapCliqueAbstraction
hog_gui	apps/sample/sample.cpp	/^bool hog_gui=true;$/;"	v
hpaStar	shared/hpaStar.cpp	/^hpaStar::hpaStar()$/;"	f	class:hpaStar
hpaStar	shared/hpaStar.h	/^class hpaStar : public searchAlgorithm {$/;"	c
humanUnit	shared/humanUnit.cpp	/^humanUnit::humanUnit(int _x, int _y, unit *_target)$/;"	f	class:humanUnit
humanUnit	shared/humanUnit.h	/^class humanUnit : public unit {$/;"	c
id	simulation/unit.h	/^	int id;$/;"	m	class:unit
id	simulation/unitGroup.h	/^	int id;$/;"	m	class:unitGroup
ignoreOnTarget	simulation/unitSimulation.h	/^	bool ignoreOnTarget;$/;"	m	class:unitInfo
ignoreVal	util/mapOverlay.h	/^	double ignoreVal;$/;"	m	class:MapOverlay
image	driver/MAC/mac_main.cpp	/^	char *image;$/;"	m	class:movieFrame	file:
imaginary	tests/ComplexNumberTest.h	/^  double real, imaginary;$/;"	m	class:Complex
inCorridor	abstraction/clusterAbstraction.cpp	/^	bool inCorridor(uint32_t nodeID)$/;"	f	class:ClusterSearchEnvironment
includeFilters	util/statCollection.h	/^	std::vector<const char *> includeFilters;$/;"	m	class:statCollection
increaseColorMap	util/mapOverlay.h	/^	void increaseColorMap() { colorMap++; }$/;"	f	class:MapOverlay
increaseDisplayALevel	simulation/unitGroup.h	/^	virtual void increaseDisplayALevel(void) {  }$/;"	f	class:unitGroup
info	driver/common.h	/^	bool info;$/;"	m	struct:recContext
initialCenter	driver/MAC/HID Support/HID_Utilities_External.h	/^    long initialCenter; 					\/\/ center value at start up$/;"	m	struct:recElement
initialConditions	driver/common.cpp	/^void initialConditions(pRecContext pContextInfo)$/;"	f
initializeHandlers	apps/sample/sample.cpp	/^void initializeHandlers()$/;"	f
initializeSearch	util/GenericAStar.cpp	/^bool GenericAStar::initializeSearch(SearchEnvironment *_env, uint32_t from, uint32_t to,$/;"	f	class:GenericAStar
inputs	driver/MAC/HID Support/HID_Utilities.h	/^	long inputs;							\/\/ number of elements of type kIOHIDElementTypeInput_Misc or kIOHIDElementTypeInput_Button or kIOHIDElementTypeInput_Axis or kIOHIDElementTypeInput_ScanCodes$/;"	m	struct:recDevice
inputs	driver/MAC/HID Support/HID_Utilities_External.h	/^	long inputs;							\/\/ number of elements of type kIOHIDElementTypeInput_Misc or kIOHIDElementTypeInput_Button or kIOHIDElementTypeInput_Axis or kIOHIDElementTypeInput_ScanCodes$/;"	m	struct:recDevice
insertNode	abstraction/clusterAbstraction.cpp	/^node* clusterAbstraction::insertNode(node* n, int& expanded, int& touched)$/;"	f	class:clusterAbstraction
insertNodeIntoHierarchy	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::insertNodeIntoHierarchy(node *newNode)$/;"	f	class:loadedCliqueAbstraction
insertNodeIntoHierarchy	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::insertNodeIntoHierarchy(node *newNode)$/;"	f	class:mapCliqueAbstraction
insertNodesExpanded	aha/AnnotatedHierarchicalAStar.h	/^		long insertNodesExpanded;$/;"	m	class:AnnotatedHierarchicalAStar
insertNodesTouched	aha/AnnotatedHierarchicalAStar.h	/^		long insertNodesTouched;$/;"	m	class:AnnotatedHierarchicalAStar
insertPeakMemory	aha/AnnotatedHierarchicalAStar.h	/^		long insertPeakMemory;$/;"	m	class:AnnotatedHierarchicalAStar
insertSearchTime	aha/AnnotatedHierarchicalAStar.h	/^		double insertSearchTime;$/;"	m	class:AnnotatedHierarchicalAStar
insertStartAndGoalIntoAbstractGraphShouldAddToCacheAPathForEachNewlyCreatedEdge	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::insertStartAndGoalIntoAbstractGraphShouldAddToCacheAPathForEachNewlyCreatedEdge()$/;"	f	class:AnnotatedClusterAbstractionTest
insertStartAndGoalIntoAbstractGraphShouldRecordStatisticsToMeasureInsertionEffort	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::insertStartAndGoalIntoAbstractGraphShouldRecordStatisticsToMeasureInsertionEffort()$/;"	f	class:AnnotatedClusterAbstractionTest
insertStartAndGoalIntoAbstractGraphShouldSet_kAbstractionLevel_LabelOfNewNodesToPointToTheCorrectAbstractGraph	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::insertStartAndGoalIntoAbstractGraphShouldSet_kAbstractionLevel_LabelOfNewNodesToPointToTheCorrectAbstractGraph()$/;"	f	class:AnnotatedClusterAbstractionTest
insertStartAndGoalIntoAbstractGraphShouldSet_kParent_LabelOfOriginalNodeEqualToIdIfANewNodeIsAddedToAbstractGraph	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::insertStartAndGoalIntoAbstractGraphShouldSet_kParent_LabelOfOriginalNodeEqualToIdIfANewNodeIsAddedToAbstractGraph()$/;"	f	class:AnnotatedClusterAbstractionTest
insertStartAndGoalIntoAbstractGraphShouldThrowExceptionGivenNonTraversableGoalNodeParameters	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::insertStartAndGoalIntoAbstractGraphShouldThrowExceptionGivenNonTraversableGoalNodeParameters()$/;"	f	class:AnnotatedClusterAbstractionTest
insertStartAndGoalIntoAbstractGraphShouldThrowExceptionGivenNonTraversableStartNodeParameters	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::insertStartAndGoalIntoAbstractGraphShouldThrowExceptionGivenNonTraversableStartNodeParameters()$/;"	f	class:AnnotatedClusterAbstractionTest
insertStartAndGoalIntoAbstractGraphShouldThrowExceptionIfStartOrGoalNodeHasAbstractionLevelGreaterThanZero	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::insertStartAndGoalIntoAbstractGraphShouldThrowExceptionIfStartOrGoalNodeHasAbstractionLevelGreaterThanZero()$/;"	f	class:AnnotatedClusterAbstractionTest
insertStartAndGoalIntoAbstractGraphShouldThrowExceptionIfStartOrGoalNodeIsNull	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::insertStartAndGoalIntoAbstractGraphShouldThrowExceptionIfStartOrGoalNodeIsNull()$/;"	f	class:AnnotatedClusterAbstractionTest
insertStartAndGoalNodesIntoAbstractGraph	aha/AnnotatedClusterAbstraction.cpp	/^void AnnotatedClusterAbstraction::insertStartAndGoalNodesIntoAbstractGraph(node* start, node* goal) $/;"	f	class:AnnotatedClusterAbstraction
insertStartAndGoalNodesIntoAbstractGraphShouldAddTwoNewNodesIntoTheAbstractGraphAndParentClusters	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::insertStartAndGoalNodesIntoAbstractGraphShouldAddTwoNewNodesIntoTheAbstractGraphAndParentClusters()$/;"	f	class:AnnotatedClusterAbstractionTest
insertStartAndGoalNodesIntoAbstractGraphShouldConnectAnyNewNodesToAllOtherAbstractNodesInTheParentCluster	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::insertStartAndGoalNodesIntoAbstractGraphShouldConnectAnyNewNodesToAllOtherAbstractNodesInTheParentCluster()$/;"	f	class:AnnotatedClusterAbstractionTest
insertStartAndGoalNodesIntoAbstractGraphShouldNotCreateNewAbstractNodesIfASuitableNodeAlreadyExistsInTheAbstractGraph	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::insertStartAndGoalNodesIntoAbstractGraphShouldNotCreateNewAbstractNodesIfASuitableNodeAlreadyExistsInTheAbstractGraph()$/;"	f	class:AnnotatedClusterAbstractionTest
installCommandLineHandler	driver/common.cpp	/^void installCommandLineHandler(commandLineCallback CLC,$/;"	f
installJoystickHandler	driver/common.cpp	/^void installJoystickHandler(joystickCallback jC, void *userdata)$/;"	f
installKeyboardHandler	driver/common.cpp	/^void installKeyboardHandler(keyboardCallback kf, const char *title, const char *description,$/;"	f
installMouseClickHandler	driver/common.cpp	/^void installMouseClickHandler(mouseCallback mC)$/;"	f
interedge_weight	tests/AnnotatedClusterTest.h	/^		double interedge_weight;$/;"	m	class:AnnotatedClusterTest
interface	driver/MAC/HID Support/HID_Utilities.h	/^    IOHIDDeviceInterface ** interface;		\/\/ interface to device, NULL = no interface$/;"	m	struct:recDevice
interface	driver/MAC/HID Support/HID_Utilities_External.h	/^    void * interface;						\/\/ interface to device, NULL = no interface$/;"	m	struct:recDevice
internalHeuristic	shared/aStar.cpp	/^double aStar::internalHeuristic(node *from, node *to)$/;"	f	class:aStar
intra1	tests/AnnotatedClusterAbstractionTest.h	/^		edge *e1, *e2, *intra1, *intra2;$/;"	m	class:AnnotatedClusterAbstractionTest
intra2	tests/AnnotatedClusterAbstractionTest.h	/^		edge *e1, *e2, *intra1, *intra2;$/;"	m	class:AnnotatedClusterAbstractionTest
isIn	util/heap.cpp	/^bool heap::isIn(graph_object *val)$/;"	f	class:heap
isIn	util/heap2.h	/^bool heap2<OBJ, HashKey, EqKey, CmpKey>::isIn(OBJ val)$/;"	f	class:heap2
isInCorridor	aha/AnnotatedAStar.h	/^		bool isInCorridor(node* n) { if(n->getParentCluster() != cluster1 && n->getParentCluster() != cluster2) return false; return true; }$/;"	f	class:AbstractAnnotatedAStar
isLegalStone	util/map.cpp	/^bool Map::isLegalStone(char c)$/;"	f	class:Map
isUnitRacing	simulation/unitRaceSimulation.cpp	/^bool unitRaceSimulation::isUnitRacing(unitInfo *u)$/;"	f	class:unitRaceSimulation
jC	driver/common.h	/^	joystickCallback jC;$/;"	m	class:joystickCallbackData
joystickCallback	driver/common.h	/^typedef void (*joystickCallback)(unitSimulation *, double offsetX, double offsetY, void*);$/;"	t
joystickCallbackData	driver/common.h	/^	joystickCallbackData(joystickCallback _jC, void *_userData)$/;"	f	class:joystickCallbackData
joystickCallbackData	driver/common.h	/^class joystickCallbackData {$/;"	c
joystickCallbacks	driver/common.cpp	/^static std::vector<joystickCallbackData *> joystickCallbacks;$/;"	v	file:
kAbstractionLevel	simulation/constants.h	/^  kAbstractionLevel = 0, \/\/ this is a LONG label$/;"	e	enum:__anon20
kActionXAxis	driver/MAC/HID Support/HIDSupport.h	/^	kActionXAxis,$/;"	e	enum:__anon14
kActionYAxis	driver/MAC/HID Support/HIDSupport.h	/^	kActionYAxis,$/;"	e	enum:__anon14
kAltDown	driver/common.h	/^	kAltDown \/\/ option on the mac$/;"	e	enum:tKeyboardModifier
kAnimateMenuItem	driver/common.h	/^	kAnimateMenuItem = 5,$/;"	e	enum:__anon5
kAnimateState	driver/common.h	/^	kAnimateState = 0$/;"	e	enum:__anon5
kAnyModifier	driver/common.h	/^	kAnyModifier,$/;"	e	enum:tKeyboardModifier
kBackwardSplit	util/map.h	/^  kBackwardSplit=2     \/\/ ie like back slash$/;"	e	enum:tSplit
kBlight	util/map.h	/^  kBlight=0x20,$/;"	e	enum:tTerrain
kBottomEdge	util/map.h	/^  kBottomEdge$/;"	e	enum:tEdge
kBottomLeft	util/map.h	/^  kBottomLeft = 3,$/;"	e	enum:tCorner
kBottomRight	util/map.h	/^  kBottomRight = 4$/;"	e	enum:tCorner
kBuildGraph	abstraction/graphAbstraction.cpp	/^	kBuildGraph = 0x01,$/;"	e	enum:__anon2	file:
kBuildGraph	abstraction/loadedCliqueAbstraction.cpp	/^	kBuildGraph = 0x01,$/;"	e	enum:__anon3	file:
kBuildGraph	abstraction/mapCliqueAbstraction.cpp	/^	kBuildGraph = 0x01,$/;"	e	enum:__anon4	file:
kCloseMenuItem	driver/common.h	/^	kCloseMenuItem = 2,$/;"	e	enum:__anon5
kControlDown	driver/common.h	/^	kControlDown,$/;"	e	enum:tKeyboardModifier
kDefaultUserMax	driver/MAC/HID Support/HID_Utilities.h	/^    kDefaultUserMax = 255,$/;"	e	enum:__anon10
kDefaultUserMax	driver/MAC/HID Support/HID_Utilities_External.h	/^    kDefaultUserMax = 255$/;"	e	enum:__anon11
kDefaultUserMin	driver/MAC/HID Support/HID_Utilities.h	/^    kDefaultUserMin = 0,					\/\/ default user min and max used for scaling$/;"	e	enum:__anon10
kDefaultUserMin	driver/MAC/HID Support/HID_Utilities_External.h	/^    kDefaultUserMin = 0,					\/\/ default user min and max used for scaling$/;"	e	enum:__anon11
kDeg2Rad	driver/trackball.cpp	/^static const float kDeg2Rad = 3.1415927 \/ 180.;$/;"	v	file:
kDeviceQueueSize	driver/MAC/HID Support/HID_Queue_Utilities.h	/^    kDeviceQueueSize = 50	\/\/ this is wired kernel memory so should be set to as small as possible$/;"	e	enum:__anon9
kDeviceQueueSize	driver/MAC/HID Support/HID_Utilities_External.h	/^    kDeviceQueueSize = 50	\/\/ this is wired kernel memory so should be set to as small as possible$/;"	e	enum:__anon12
kDisplayOnly	simulation/constants.h	/^	kDisplayOnly, kIncidentalUnit, kWorldObject$/;"	e	enum:tObjectType
kE	simulation/constants.h	/^	kN=0x8, kS=0x4, kE=0x2, kW=0x1, kNW=kN|kW, kNE=kN|kE, $/;"	e	enum:tDirection
kEdgeCapacity	simulation/constants.h	/^  kEdgeCapacity=2$/;"	e	enum:__anon21
kEdgeWeight	util/graph.h	/^	kEdgeWeight = 0,$/;"	e	enum:__anon24
kEdgeWidth	util/graph.h	/^	kEdgeWidth = 1$/;"	e	enum:__anon24
kFSAAFast	driver/common.h	/^	kFSAAFast = 1,$/;"	e	enum:__anon6
kFSAANice	driver/common.h	/^	kFSAANice = 2,$/;"	e	enum:__anon6
kFSAAOff	driver/common.h	/^	kFSAAOff = 0,$/;"	e	enum:__anon6
kFall	util/map.h	/^	kFall,$/;"	e	enum:tTileset
kFallTile	util/map.h	/^	kFallTile,$/;"	e	enum:tTileset
kFast	util/map.h	/^	kFast$/;"	e	enum:tTileset
kFirstData	simulation/constants.h	/^  kFirstData = 9$/;"	e	enum:__anon20
kForwardSplit	util/map.h	/^  kForwardSplit=1, \/\/ ie like forward slash$/;"	e	enum:tSplit
kGrass	util/map.h	/^  kGrass=0x0F,$/;"	e	enum:tTerrain
kGround	util/map.h	/^  kGround=0x04,     \/\/ ground$/;"	e	enum:tTerrain
kHIDElementTypeAll	driver/MAC/HID Support/HID_Utilities.h	/^	kHIDElementTypeAll					= kHIDElementTypeIO | kHIDElementTypeCollection$/;"	e	enum:HIDElementTypeMask
kHIDElementTypeAll	driver/MAC/HID Support/HID_Utilities_External.h	/^	kHIDElementTypeAll					= kHIDElementTypeIO | kHIDElementTypeCollection$/;"	e	enum:HIDElementTypeMask
kHIDElementTypeCollection	driver/MAC/HID Support/HID_Utilities.h	/^	kHIDElementTypeCollection        	= 1 << 4,$/;"	e	enum:HIDElementTypeMask
kHIDElementTypeCollection	driver/MAC/HID Support/HID_Utilities_External.h	/^	kHIDElementTypeCollection        	= 1 << 4,$/;"	e	enum:HIDElementTypeMask
kHIDElementTypeFeature	driver/MAC/HID Support/HID_Utilities.h	/^	kHIDElementTypeFeature           	= 1 << 3,$/;"	e	enum:HIDElementTypeMask
kHIDElementTypeFeature	driver/MAC/HID Support/HID_Utilities_External.h	/^	kHIDElementTypeFeature           	= 1 << 3,$/;"	e	enum:HIDElementTypeMask
kHIDElementTypeIO	driver/MAC/HID Support/HID_Utilities.h	/^	kHIDElementTypeIO					= kHIDElementTypeInput | kHIDElementTypeOutput | kHIDElementTypeFeature,$/;"	e	enum:HIDElementTypeMask
kHIDElementTypeIO	driver/MAC/HID Support/HID_Utilities_External.h	/^	kHIDElementTypeIO					= kHIDElementTypeInput | kHIDElementTypeOutput | kHIDElementTypeFeature,$/;"	e	enum:HIDElementTypeMask
kHIDElementTypeInput	driver/MAC/HID Support/HID_Utilities.h	/^	kHIDElementTypeInput				= 1 << 1,$/;"	e	enum:HIDElementTypeMask
kHIDElementTypeInput	driver/MAC/HID Support/HID_Utilities_External.h	/^	kHIDElementTypeInput				= 1 << 1,$/;"	e	enum:HIDElementTypeMask
kHIDElementTypeOutput	driver/MAC/HID Support/HID_Utilities.h	/^	kHIDElementTypeOutput            	= 1 << 2,$/;"	e	enum:HIDElementTypeMask
kHIDElementTypeOutput	driver/MAC/HID Support/HID_Utilities_External.h	/^	kHIDElementTypeOutput            	= 1 << 2,$/;"	e	enum:HIDElementTypeMask
kHighQualityAbstraction	aha/AnnotatedClusterAbstraction.h	/^		kHighQualityAbstraction, \/\/ abstract graph includes all optimal paths for every capability between endpoints in each cluster$/;"	e	enum:ACAUtil::GraphQualityParameter
kIncidentalUnit	simulation/constants.h	/^	kDisplayOnly, kIncidentalUnit, kWorldObject$/;"	e	enum:tObjectType
kInfoMenuItem	driver/common.h	/^	kInfoMenuItem = 4,$/;"	e	enum:__anon5
kInfoState	driver/common.h	/^	kInfoState = 1,$/;"	e	enum:__anon5
kInternalEdge	util/map.h	/^  kInternalEdge,$/;"	e	enum:tEdge
kLeftButton	driver/common.h	/^	kLeftButton,$/;"	e	enum:tButtonType
kLeftEdge	util/map.h	/^  kLeftEdge,$/;"	e	enum:tEdge
kLeftSide	util/map.h	/^  kLeftSide = 2,$/;"	e	enum:tSplitSide
kLines	util/map.h	/^  kLines,$/;"	e	enum:tDisplay
kLowQualityAbstraction	aha/AnnotatedClusterAbstraction.h	/^		kLowQualityAbstraction \/\/ build large single capability corridors first and re-use as many as possible $/;"	e	enum:ACAUtil::GraphQualityParameter
kMacallyID	driver/MAC/HID Support/HID_Name_Lookup.h	/^#define kMacallyID /;"	d
kMainMenu	driver/common.h	/^	kMainMenu = 500,$/;"	e	enum:__anon5
kMiddleButton	driver/common.h	/^	kMiddleButton \/\/ option on the mac$/;"	e	enum:tButtonType
kMiscMessages	abstraction/graphAbstraction.cpp	/^	kMiscMessages = 0x04$/;"	e	enum:__anon2	file:
kMiscMessages	abstraction/loadedCliqueAbstraction.cpp	/^	kMiscMessages = 0x04$/;"	e	enum:__anon3	file:
kMiscMessages	abstraction/mapCliqueAbstraction.cpp	/^	kMiscMessages = 0x04$/;"	e	enum:__anon4	file:
kMouseDown	driver/common.h	/^	kMouseDown,$/;"	e	enum:tMouseEventType
kMouseDrag	driver/common.h	/^	kMouseDrag \/\/ option on the mac$/;"	e	enum:tMouseEventType
kMouseUp	driver/common.h	/^	kMouseUp,$/;"	e	enum:tMouseEventType
kN	simulation/constants.h	/^	kN=0x8, kS=0x4, kE=0x2, kW=0x1, kNW=kN|kW, kNE=kN|kE, $/;"	e	enum:tDirection
kNE	simulation/constants.h	/^	kN=0x8, kS=0x4, kE=0x2, kW=0x1, kNW=kN|kW, kNE=kN|kE, $/;"	e	enum:tDirection
kNW	simulation/constants.h	/^	kN=0x8, kS=0x4, kE=0x2, kW=0x1, kNW=kN|kW, kNE=kN|kE, $/;"	e	enum:tDirection
kNoExperiment	tests/ExperimentManager.h	/^		kNoExperiment,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kNoGraphNode	util/map.h	/^const int kNoGraphNode = -1;$/;"	v
kNoModifier	driver/common.h	/^	kNoModifier,$/;"	e	enum:tKeyboardModifier
kNoScaling	shared/scenarioLoader.h	/^static const int kNoScaling = -1;$/;"	v
kNoSplit	util/map.h	/^  kNoSplit=0,$/;"	e	enum:tSplit
kNoTarget	simulation/unitRaceSimulation.h	/^	kNoTarget, kOutOfTravel, kReachedTarget, kNotOnTarget$/;"	e	enum:tUnitOnTargetStatus
kNodeBlocked	simulation/constants.h	/^  kNodeBlocked = 8, \/\/ this is a LONG label$/;"	e	enum:__anon20
kNodeWidth	simulation/constants.h	/^  kNodeWidth = 3, \/\/ the maximum size object that can completely traverse this node; this is a LONG label$/;"	e	enum:__anon20
kNone	util/map.h	/^  kNone = 0,$/;"	e	enum:tCorner
kNotOnTarget	simulation/unitRaceSimulation.h	/^	kNoTarget, kOutOfTravel, kReachedTarget, kNotOnTarget$/;"	e	enum:tUnitOnTargetStatus
kNotPathableAgentSizeLessThanMin	tests/ExperimentManager.h	/^		kNotPathableAgentSizeLessThanMin,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kNotPathableGoalClearanceTooSmallLST	tests/ExperimentManager.h	/^		kNotPathableGoalClearanceTooSmallLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kNotPathableGoalIsHardObstacleLST	tests/ExperimentManager.h	/^		kNotPathableGoalIsHardObstacleLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kNotPathableGoalIsSoftObstacleLST	tests/ExperimentManager.h	/^		kNotPathableGoalIsSoftObstacleLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kNotPathableHardObstacleBlocksGoal	tests/ExperimentManager.h	/^		kNotPathableHardObstacleBlocksGoal,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kNotPathableInvalidCapability	tests/ExperimentManager.h	/^		kNotPathableInvalidCapability, $/;"	e	enum:ExpMgrUtil::ExperimentKey
kNotPathableMoveToHardObstacleLST	tests/ExperimentManager.h	/^		kNotPathableMoveToHardObstacleLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kNotPathableMoveToNonAdjacentLocationLST	tests/ExperimentManager.h	/^		kNotPathableMoveToNonAdjacentLocationLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kNotPathableMoveToSoftObstacleLST	tests/ExperimentManager.h	/^		kNotPathableMoveToSoftObstacleLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kNotPathableSoftObstacleBlocksGoal	tests/ExperimentManager.h	/^		kNotPathableSoftObstacleBlocksGoal,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kNotPathableStartAndGoalIdenticalLST	tests/ExperimentManager.h	/^		kNotPathableStartAndGoalIdenticalLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kNotPathableStartClearanceTooSmallLST	tests/ExperimentManager.h	/^		kNotPathableStartClearanceTooSmallLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kNotPathableStartIsHardObstacleLST	tests/ExperimentManager.h	/^		kNotPathableStartIsHardObstacleLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kNotPathableStartIsSoftObstacleLST	tests/ExperimentManager.h	/^		kNotPathableStartIsSoftObstacleLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kNotPathableWhenCorridorIsRestrictedToParentCluster	tests/ExperimentManager.h	/^		kNotPathableWhenCorridorIsRestrictedToParentCluster,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kNumAbstractedNodes	simulation/constants.h	/^  kNumAbstractedNodes = 1, \/\/ nodes that we abstract; this is a LONG label$/;"	e	enum:__anon20
kNumActions	driver/MAC/HID Support/HIDSupport.h	/^	kNumActions$/;"	e	enum:__anon14
kOctile	util/map.h	/^	kOctile,$/;"	e	enum:tMapType
kOctileCorner	util/map.h	/^	kOctileCorner,$/;"	e	enum:tMapType
kOneSecond	driver/MAC/mac_main.cpp	/^#define kOneSecond /;"	d	file:
kOutOfBounds	util/map.h	/^  kOutOfBounds =0x0, \/\/ not part of map$/;"	e	enum:tTerrain
kOutOfBounds2	util/map.h	/^  kOutOfBounds2=0x01, \/\/ not part of map - different color$/;"	e	enum:tTerrain
kOutOfTravel	simulation/unitRaceSimulation.h	/^	kNoTarget, kOutOfTravel, kReachedTarget, kNotOnTarget$/;"	e	enum:tUnitOnTargetStatus
kParent	simulation/constants.h	/^  kParent = 2, \/\/ node that abstracts us; this is a LONG label$/;"	e	enum:__anon20
kPathableMoveEastLST	tests/ExperimentManager.h	/^		kPathableMoveEastLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kPathableMoveNorthEastLST	tests/ExperimentManager.h	/^		kPathableMoveNorthEastLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kPathableMoveNorthLST	tests/ExperimentManager.h	/^		kPathableMoveNorthLST, $/;"	e	enum:ExpMgrUtil::ExperimentKey
kPathableMoveNorthWestLST	tests/ExperimentManager.h	/^		kPathableMoveNorthWestLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kPathableMoveSouthEastLST	tests/ExperimentManager.h	/^		kPathableMoveSouthEastLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kPathableMoveSouthLST	tests/ExperimentManager.h	/^		kPathableMoveSouthLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kPathableMoveSouthWestLST	tests/ExperimentManager.h	/^		kPathableMoveSouthWestLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kPathableMoveWestLST	tests/ExperimentManager.h	/^		kPathableMoveWestLST,$/;"	e	enum:ExpMgrUtil::ExperimentKey
kPathableToyProblemLST	tests/ExperimentManager.h	/^		kPathableToyProblemLST, $/;"	e	enum:ExpMgrUtil::ExperimentKey
kPathableWithinCorridor	tests/ExperimentManager.h	/^		kPathableWithinCorridor$/;"	e	enum:ExpMgrUtil::ExperimentKey
kPercentMove	driver/MAC/HID Support/HID_Config_Utilities.h	/^    kPercentMove = 10 \/\/ precent of overall range a element must move to register$/;"	e	enum:__anon8
kPercentMove	driver/MAC/HID Support/HID_Utilities_External.h	/^    kPercentMove = 10 \/\/ precent of overall range a element must move to register$/;"	e	enum:__anon13
kPoints	util/map.h	/^  kPoints$/;"	e	enum:tDisplay
kPolygons	util/map.h	/^  kPolygons,$/;"	e	enum:tDisplay
kQuiet	abstraction/graphAbstraction.cpp	/^	kQuiet = 0x00,$/;"	e	enum:__anon2	file:
kQuiet	abstraction/loadedCliqueAbstraction.cpp	/^	kQuiet = 0x00,$/;"	e	enum:__anon3	file:
kQuiet	abstraction/mapCliqueAbstraction.cpp	/^	kQuiet = 0x00,$/;"	e	enum:__anon4	file:
kRad2Deg	driver/trackball.cpp	/^static const float kRad2Deg = 180. \/ 3.1415927;$/;"	v	file:
kRaw	util/map.h	/^	kRaw$/;"	e	enum:tMapType
kReachedTarget	simulation/unitRaceSimulation.h	/^	kNoTarget, kOutOfTravel, kReachedTarget, kNotOnTarget$/;"	e	enum:tUnitOnTargetStatus
kRepairGraph	abstraction/graphAbstraction.cpp	/^	kRepairGraph = 0x02,$/;"	e	enum:__anon2	file:
kRepairGraph	abstraction/loadedCliqueAbstraction.cpp	/^	kRepairGraph = 0x02,$/;"	e	enum:__anon3	file:
kRepairGraph	abstraction/mapCliqueAbstraction.cpp	/^	kRepairGraph = 0x02,$/;"	e	enum:__anon4	file:
kRightButton	driver/common.h	/^	kRightButton,$/;"	e	enum:tButtonType
kRightEdge	util/map.h	/^  kRightEdge,$/;"	e	enum:tEdge
kRightSide	util/map.h	/^  kRightSide = 3$/;"	e	enum:tSplitSide
kS	simulation/constants.h	/^	kN=0x8, kS=0x4, kE=0x2, kW=0x1, kNW=kN|kW, kNE=kN|kE, $/;"	e	enum:tDirection
kSE	simulation/constants.h	/^	kSE=kS|kE, kSW=kS|kW, kStay=0, kTeleport=kSW|kNE$/;"	e	enum:tDirection
kSW	simulation/constants.h	/^	kSE=kS|kE, kSW=kS|kW, kStay=0, kTeleport=kSW|kNE$/;"	e	enum:tDirection
kSamples	driver/common.h	/^	kSamples = 4$/;"	e	enum:__anon6
kShiftDown	driver/common.h	/^	kShiftDown,$/;"	e	enum:tKeyboardModifier
kSokoban	util/map.h	/^	kSokoban,$/;"	e	enum:tMapType
kStay	simulation/constants.h	/^	kSE=kS|kE, kSW=kS|kW, kStay=0, kTeleport=kSW|kNE$/;"	e	enum:tDirection
kStayIndex	simulation/constants.h	/^const int kStayIndex = 8; \/\/ index of kStay$/;"	v
kSwamp	util/map.h	/^  kSwamp=0x08,$/;"	e	enum:tTerrain
kTeleport	simulation/constants.h	/^	kSE=kS|kE, kSW=kS|kW, kStay=0, kTeleport=kSW|kNE$/;"	e	enum:tDirection
kTemporaryLabel	simulation/constants.h	/^  kTemporaryLabel = 4, \/\/ for any temporary usage; this label can be LONG or FLOATING point$/;"	e	enum:__anon20
kTol	driver/trackball.cpp	/^static const float kTol = 0.001;$/;"	v	file:
kTopEdge	util/map.h	/^  kTopEdge,$/;"	e	enum:tEdge
kTopLeft	util/map.h	/^  kTopLeft = 1,$/;"	e	enum:tCorner
kTopRight	util/map.h	/^  kTopRight = 2,$/;"	e	enum:tCorner
kTrees	util/map.h	/^  kTrees=0x40,$/;"	e	enum:tTerrain
kUndefined	util/map.h	/^  kUndefined \/\/ mixed type due to split tile$/;"	e	enum:tTerrain
kUndefinedHeight	util/map.h	/^	kUndefinedHeight = -999$/;"	e	enum:__anon25
kUnitSimulationMap	simulation/unitSimulation.h	/^	kUnitSimulationMap = 0$/;"	e	enum:__anon22
kUnknownPosition	simulation/constants.h	/^const double kUnknownPosition = -50.0;$/;"	v
kUseMultiSample	driver/MAC/mac_main.cpp	/^#define kUseMultiSample /;"	d	file:
kVerboseErrors	driver/MAC/HID Support/HID_Error_Handler.cpp	/^	#define kVerboseErrors$/;"	d	file:
kW	simulation/constants.h	/^	kN=0x8, kS=0x4, kE=0x2, kW=0x1, kNW=kN|kW, kNE=kN|kE, $/;"	e	enum:tDirection
kWater	util/map.h	/^  kWater=0x02,     \/\/ water$/;"	e	enum:tTerrain
kWholeTile	util/map.h	/^  kWholeTile = 1,$/;"	e	enum:tSplitSide
kWinter	util/map.h	/^	kWinter,$/;"	e	enum:tTileset
kWinterTile	util/map.h	/^	kWinterTile,$/;"	e	enum:tTileset
kWorldObject	simulation/constants.h	/^	kDisplayOnly, kIncidentalUnit, kWorldObject$/;"	e	enum:tObjectType
kXCoordinate	simulation/constants.h	/^  kXCoordinate = 5, \/\/ cache for opengl drawing; this is a FLOATING POINT label$/;"	e	enum:__anon20
kYCoordinate	simulation/constants.h	/^  kYCoordinate = 6,	\/\/ this is a FLOATING POINT label$/;"	e	enum:__anon20
kZCoordinate	simulation/constants.h	/^  kZCoordinate = 7,	\/\/ this is a FLOATING POINT label$/;"	e	enum:__anon20
keepHistory	simulation/unitSimulation.h	/^	bool keepHistory; \/\/ keep action history$/;"	m	class:unitSimulation
key	tests/ExperimentManager.h	/^			ExperimentKey key;$/;"	m	class:ExpMgrUtil::TestExperiment
key	util/graph.h	/^  unsigned int key; \/\/ for use by a data structure to maintain a reverse-lookup$/;"	m	class:graph_object
keyLabel	util/graph.h	/^  int keyLabel;$/;"	m	class:node
keyPressed	driver/main.cpp	/^void keyPressed(unsigned char key, int x, int y)$/;"	f
keyboardCallback	driver/common.h	/^typedef void (*keyboardCallback)(unitSimulation *,tKeyboardModifier,char);$/;"	t
keyboardCallbackData	driver/common.h	/^	keyboardCallbackData(keyboardCallback kc, const char *_title, const char *_desc,$/;"	f	class:keyboardCallbackData
keyboardCallbackData	driver/common.h	/^class keyboardCallbackData {$/;"	c
keyboardCallbacks	driver/common.cpp	/^static keyboardCallbackData *keyboardCallbacks[256] = $/;"	v	file:
kiShock2ID	driver/MAC/HID Support/HID_Name_Lookup.h	/^	#define kiShock2ID /;"	d
kiShockID	driver/MAC/HID Support/HID_Name_Lookup.h	/^	#define kiShockID /;"	d
l	util/timer.h	/^		struct { uint32_t l, h; } c4;$/;"	m	struct:Timer::CycleCounter::__anon27::__anon28
label	util/graph.h	/^	std::vector<labelValue> label;$/;"	m	class:edge
label	util/graph.h	/^  std::vector<labelValue> label;$/;"	m	class:node
labelValue	util/graph.h	/^typedef union { double fval; long lval; } labelValue;$/;"	t	typeref:union:__anon23
land	util/map.h	/^  Tile **land;$/;"	m	class:Map
last	tests/ExperimentManager.h	/^		ExpMgrUtil::ExperimentKey last;$/;"	m	class:ExperimentManager
lastAdded	tests/AnnotatedClusterAbstractionMock.h	/^		path* lastAdded;$/;"	m	class:AnnotatedClusterAbstractionMock
lastIndex	simulation/unit.h	/^		int lastIndex;$/;"	m	class:rhrUnit
lastIndex	simulation/unit.h	/^	int lastIndex;$/;"	m	class:billiardBallUnit
lastIndex	simulation/unit.h	/^	int lastIndex;$/;"	m	class:randomUnit
lastMove	simulation/unitSimulation.h	/^	tDirection lastMove;$/;"	m	class:unitInfo
lastPath	shared/spreadPRAStar.h	/^	path *lastPath;$/;"	m	class:spreadPRAStar
length	util/path.cpp	/^unsigned path::length()$/;"	f	class:path
lengths	shared/praStar.h	/^	std::vector<int> lengths;$/;"	m	class:praStar
level	abstraction/AbstractionSearchEnvironment.h	/^	int level;$/;"	m	class:AbstractionSearchEnvironment
level	abstraction/clusterAbstraction.cpp	/^	int level;$/;"	m	class:ClusterSearchEnvironment	file:
levelDraw	abstraction/loadedCliqueAbstraction.h	/^		unsigned long levelDraw;$/;"	m	class:loadedCliqueAbstraction
levelDraw	abstraction/mapAbstraction.h	/^	unsigned long levelDraw;$/;"	m	class:mapAbstraction
lighting	driver/common.h	/^	long lighting;$/;"	m	struct:recContext
limitSearchToClusterCorridor	aha/AnnotatedAStar.h	/^		void limitSearchToClusterCorridor(bool value) { useCorridor=value; }$/;"	f	class:AbstractAnnotatedAStar
lineDistance	abstraction/MapLineAbstraction.h	/^	int lineDistance;$/;"	m	class:MapLineAbstraction
lines	driver/common.h	/^	bool lines;$/;"	m	struct:recContext
linkEntrancesAndClusters	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::linkEntrancesAndClusters()$/;"	f	class:clusterAbstraction
load	util/map.cpp	/^void Map::load(FILE *f)$/;"	f	class:Map
load	util/map.cpp	/^void Map::load(const char *filename)$/;"	f	class:Map
loadClearanceInfo	tests/AnnotatedMapAbstractionMock.cpp	/^void AnnotatedMapAbstractionMock::loadClearanceInfo(const string& filename, AnnotatedMapAbstraction* aMap)$/;"	f	class:AnnotatedMapAbstractionMock
loadClusterAnnotations	tests/AnnotatedClusterAbstractionMock.cpp	/^void AnnotatedClusterAbstractionMock::loadClusterAnnotations(const std::string& filename, AbstractAnnotatedMapAbstraction* aca)$/;"	f	class:AnnotatedClusterAbstractionMock
loadGraph	abstraction/loadedCliqueAbstraction.cpp	/^graph *loadedCliqueAbstraction::loadGraph(char *fname)$/;"	f	class:loadedCliqueAbstraction
loadHistory	simulation/unitSimulation.cpp	/^bool unitSimulation::loadHistory(char *fname)$/;"	f	class:unitSimulation
loadOctile	util/map.cpp	/^void Map::loadOctile(FILE *f, int high, int wide)$/;"	f	class:Map
loadOctileCorner	util/map.cpp	/^void Map::loadOctileCorner(FILE *f, int high, int wide)$/;"	f	class:Map
loadPath	driver/MAC/mac_main.cpp	/^void loadPath(char *path)$/;"	f
loadRaw	util/map.cpp	/^void Map::loadRaw(FILE *f, int high, int wide)$/;"	f	class:Map
loadScenarioFile	aha/ScenarioManager.cpp	/^void AHAScenarioManager::loadScenarioFile(const char* filelocation)$/;"	f	class:AHAScenarioManager
loadScenarioShouldCreateExperimentObjectsGivenAFileThatDescribesExperimentAttributes	tests/ScenarioManagerTest.cpp	/^void ScenarioManagerTest::loadScenarioShouldCreateExperimentObjectsGivenAFileThatDescribesExperimentAttributes()$/;"	f	class:ScenarioManagerTest
loadedCLIQUEABSTRACTION_H	abstraction/loadedCliqueAbstraction.h	/^#define loadedCLIQUEABSTRACTION_H$/;"	d
loadedCliqueAbstraction	abstraction/loadedCliqueAbstraction.cpp	/^loadedCliqueAbstraction::loadedCliqueAbstraction(char *fname)$/;"	f	class:loadedCliqueAbstraction
loadedCliqueAbstraction	abstraction/loadedCliqueAbstraction.h	/^class loadedCliqueAbstraction : public graphAbstraction {$/;"	c
locID	driver/MAC/HID Support/HID_Config_Utilities.h	/^    long locID;$/;"	m	struct:recSaveHID
locID	driver/MAC/HID Support/HID_Utilities.h	/^    long locID;								\/\/ long representing location in USB (or other I\/O) chain which device is pluged into, can identify specific device on machine$/;"	m	struct:recDevice
locID	driver/MAC/HID Support/HID_Utilities_External.h	/^    long locID;								\/\/ long representing location in USB (or other I\/O) chain which device is pluged into, can identify specific device on machine$/;"	m	struct:recDevice
locID	driver/MAC/HID Support/HID_Utilities_External.h	/^    long locID;$/;"	m	struct:recSaveHID
lockstepTime	simulation/unitSimulation.h	/^	bool lockstepTime;      \/\/ Finn\/Wes - individual unit times will be update exactly according to the amount specified to advanceTime$/;"	m	class:unitSimulation
logFinalStats	aha/AnnotatedAStar.cpp	/^void AnnotatedAStar::logFinalStats(statCollection *stats)$/;"	f	class:AnnotatedAStar
logFinalStats	aha/AnnotatedHierarchicalAStar.cpp	/^void AnnotatedHierarchicalAStar::logFinalStats(statCollection* stats)$/;"	f	class:AnnotatedHierarchicalAStar
logFinalStats	shared/patrolUnit.cpp	/^void patrolUnit::logFinalStats(statCollection *stats)$/;"	f	class:patrolUnit
logFinalStats	shared/searchAlgorithm.h	/^	virtual void logFinalStats(statCollection *) {}$/;"	f	class:searchAlgorithm
logFinalStats	shared/searchUnit.cpp	/^void searchUnit::logFinalStats(statCollection *stats)$/;"	f	class:searchUnit
logFinalStats	simulation/unit.h	/^	virtual void logFinalStats(statCollection *) {}$/;"	f	class:unit
logFinalStats	simulation/unitGroup.h	/^	virtual void logFinalStats(statCollection *) {}$/;"	f	class:unitGroup
logStats	shared/patrolUnit.cpp	/^void patrolUnit::logStats(statCollection *stats)$/;"	f	class:patrolUnit
logStats	shared/searchUnit.cpp	/^void searchUnit::logStats(statCollection *stats)$/;"	f	class:searchUnit
logStats	shared/sharedAMapGroup.cpp	/^void sharedAMapGroup::logStats(statCollection *stats)$/;"	f	class:sharedAMapGroup
logStats	simulation/unit.cpp	/^void unit::logStats(statCollection *)$/;"	f	class:unit
logStats	simulation/unitGroup.cpp	/^void unitGroup::logStats(statCollection *)$/;"	f	class:unitGroup
logStatsShouldRecordAllMetricsToStatsCollection	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::logStatsShouldRecordAllMetricsToStatsCollection()$/;"	f	class:AnnotatedAStarTest
logStatsShouldRecordAllMetricsToStatsCollection	tests/AnnotatedHierarchicalAStarTest.cpp	/^void AnnotatedHierarchicalAStarTest::logStatsShouldRecordAllMetricsToStatsCollection()$/;"	f	class:AnnotatedHierarchicalAStarTest
longStored	util/statCollection.h	/^enum storedType { floatStored, longStored };$/;"	e	enum:storedType
lookup	shared/craStar.h	/^	std::vector<node*> lookup;$/;"	m	class:craStar
lookup	shared/hpaStar.h	/^	std::vector<node*> lookup;$/;"	m	class:hpaStar
lookupCategory	util/statCollection.cpp	/^int statCollection::lookupCategory(const char *category) const$/;"	f	class:statCollection
lookupCategoryID	util/statCollection.cpp	/^const char *statCollection::lookupCategoryID(int id) const$/;"	f	class:statCollection
lookupOwner	util/statCollection.cpp	/^int statCollection::lookupOwner(const char *owner) const$/;"	f	class:statCollection
lookupOwnerID	util/statCollection.cpp	/^const char *statCollection::lookupOwnerID(int id) const$/;"	f	class:statCollection
lookupStat	util/statCollection.cpp	/^bool statCollection::lookupStat(const char *category, const char *owner, statValue &v) const$/;"	f	class:statCollection
lookupStat	util/statCollection.cpp	/^bool statCollection::lookupStat(unsigned int index, statValue &v) const$/;"	f	class:statCollection
lval	util/graph.h	/^typedef union { double fval; long lval; } labelValue;$/;"	m	union:__anon23
lval	util/statCollection.h	/^typedef union { double fval; long lval; } statValue;$/;"	m	union:__anon26
m	abstraction/mapAbstraction.h	/^	Map *m;$/;"	m	class:mapAbstraction
m	shared/hpaStar.h	/^	clusterAbstraction* m;$/;"	m	class:hpaStar
m	util/mapOverlay.h	/^	Map *m;$/;"	m	class:MapOverlay
mC	driver/common.h	/^	mouseCallback mC;$/;"	m	class:mouseCallbackData
m_10_1	tests/ComplexNumberTest.h	/^  Complex *m_10_1, *m_1_1, *m_11_2;$/;"	m	class:ComplexNumberTest
m_11_2	tests/ComplexNumberTest.h	/^  Complex *m_10_1, *m_1_1, *m_11_2;$/;"	m	class:ComplexNumberTest
m_1_1	tests/ComplexNumberTest.h	/^  Complex *m_10_1, *m_1_1, *m_11_2;$/;"	m	class:ComplexNumberTest
m_center1Col	abstraction/clusterAbstraction.h	/^  int m_center1Col; \/\/x-coordinate of entrance in top \/ left cluster$/;"	m	class:Entrance
m_center1Id	abstraction/clusterAbstraction.h	/^  int m_center1Id; \/\/node number of the entrance in the top \/ left cluster$/;"	m	class:Entrance
m_center1Row	abstraction/clusterAbstraction.h	/^  int m_center1Row; \/\/y-coordinate of entrance in top \/ left cluster$/;"	m	class:Entrance
m_center2Id	abstraction/clusterAbstraction.h	/^  int m_center2Id; \/\/node number of the entrance in the bottom \/ right cluster$/;"	m	class:Entrance
m_cluster1Id	abstraction/clusterAbstraction.h	/^  int m_cluster1Id; \/\/top \/ left cluster's id$/;"	m	class:Entrance
m_cluster2Id	abstraction/clusterAbstraction.h	/^  int m_cluster2Id; \/\/bottom \/ right cluster's id$/;"	m	class:Entrance
m_col	abstraction/clusterAbstraction.h	/^  int m_col; \/\/ abstract col of the uppermost adjacent cluster$/;"	m	class:Entrance
m_column	abstraction/clusterAbstraction.h	/^  int m_column; \/\/ abstract col of this cluster (e.g., 1 for the second clusters vertically)$/;"	m	class:Cluster
m_height	abstraction/clusterAbstraction.h	/^  int m_height; \/\/ high of this cluster$/;"	m	class:Cluster
m_horizOrigin	abstraction/clusterAbstraction.h	/^  int m_horizOrigin; \/\/ horizontal\/column origin$/;"	m	class:Cluster
m_id	abstraction/clusterAbstraction.h	/^  int m_id;$/;"	m	class:Cluster
m_length	abstraction/clusterAbstraction.h	/^  int m_length; \/\/ length of the entrance$/;"	m	class:Entrance
m_orientation	abstraction/clusterAbstraction.h	/^  Orientation m_orientation;$/;"	m	class:Entrance
m_row	abstraction/clusterAbstraction.h	/^  int m_row; \/\/ abstract row of the leftmost adjacent cluster$/;"	m	class:Entrance
m_row	abstraction/clusterAbstraction.h	/^  int m_row; \/\/ abstract row of this cluster (e.g., 1 for the second clusters horizontally)$/;"	m	class:Cluster
m_vertOrigin	abstraction/clusterAbstraction.h	/^  int m_vertOrigin; \/\/vertical \/ row origin$/;"	m	class:Cluster
m_width	abstraction/clusterAbstraction.h	/^  int m_width; \/\/ width of this cluster$/;"	m	class:Cluster
main	driver/MAC/mac_main.cpp	/^int main(int argc, char* argv[])$/;"	f
main	driver/main.cpp	/^int main(int argc, char** argv)$/;"	f
main	tests/RunTests.cpp	/^int main (int argc, char* argv[])$/;"	f
makeMaze	util/map.cpp	/^void makeMaze(Map *map, int pathSize)$/;"	f
makeMove	shared/humanUnit.cpp	/^tDirection humanUnit::makeMove(mapProvider *, reservationProvider *, simulationInfo *)$/;"	f	class:humanUnit
makeMove	shared/patrolUnit.cpp	/^tDirection patrolUnit::makeMove(mapProvider *mp, reservationProvider *, simulationInfo *)$/;"	f	class:patrolUnit
makeMove	shared/praStarUnit.cpp	/^tDirection praStarUnit::makeMove(mapProvider *mp, reservationProvider *rp, simulationInfo *simInfo)$/;"	f	class:praStarUnit
makeMove	shared/rewardUnit.cpp	/^tDirection rewardSeekingUnit::makeMove(mapProvider *mp, reservationProvider *, simulationInfo *)$/;"	f	class:rewardSeekingUnit
makeMove	shared/searchUnit.cpp	/^tDirection searchUnit::makeMove(mapProvider *mp, reservationProvider *rp, simulationInfo *simInfo)$/;"	f	class:searchUnit
makeMove	shared/sharedAMapGroup.cpp	/^tDirection sharedAMapGroup::makeMove(unit *u, mapProvider *, reservationProvider *rp, simulationInfo *simInfo)$/;"	f	class:sharedAMapGroup
makeMove	simulation/unit.cpp	/^tDirection billiardBallUnit::makeMove(mapProvider *, reservationProvider *, simulationInfo *)$/;"	f	class:billiardBallUnit
makeMove	simulation/unit.cpp	/^tDirection randomUnit::makeMove(mapProvider *, reservationProvider *, simulationInfo *)$/;"	f	class:randomUnit
makeMove	simulation/unit.cpp	/^tDirection rhrUnit::makeMove(mapProvider *, reservationProvider *, simulationInfo *)$/;"	f	class:rhrUnit
makeMove	simulation/unit.cpp	/^tDirection teleportUnit::makeMove(mapProvider *mp, reservationProvider *, simulationInfo *)$/;"	f	class:teleportUnit
makeMove	simulation/unit.cpp	/^tDirection unit::makeMove(mapProvider *, reservationProvider *, simulationInfo *)$/;"	f	class:unit
makeMove	simulation/unit.h	/^	tDirection makeMove(mapProvider *, reservationProvider *, simulationInfo *)$/;"	f	class:randomerUnit
makeMove	simulation/unitGroup.cpp	/^tDirection unitGroup::makeMove(unit *u, mapProvider *mp, reservationProvider *rp, simulationInfo *simInfo)$/;"	f	class:unitGroup
manufacturer	driver/MAC/HID Support/HID_Utilities.h	/^    Str255 manufacturer;					\/\/ name of manufacturer$/;"	m	struct:recDevice
manufacturer	driver/MAC/HID Support/HID_Utilities_External.h	/^    char manufacturer[256];					\/\/ name of manufacturer$/;"	m	struct:recDevice
map	shared/aStar3.h	/^	graphAbstraction *map;$/;"	m	class:aStarOld
map	shared/praStar.h	/^  graphAbstraction *map;$/;"	m	class:praStar
map	shared/scenarioLoader.h	/^  string map;$/;"	m	class:Experiment
map	shared/sharedAMapGroup.h	/^	Map *map;$/;"	m	class:sharedAMapGroup
map	simulation/unitSimulation.h	/^	Map *map;$/;"	m	class:unitSimulation
map	util/SearchEnvironment.h	/^	Map *map;$/;"	m	class:MapSearchEnvironment
mapAbstraction	abstraction/mapAbstraction.h	/^	mapAbstraction(Map *_m) :m(_m), levelDraw(0) {}$/;"	f	class:mapAbstraction
mapAbstraction	abstraction/mapAbstraction.h	/^class mapAbstraction : public graphAbstraction {$/;"	c
mapCliqueAbstraction	abstraction/mapCliqueAbstraction.cpp	/^mapCliqueAbstraction::mapCliqueAbstraction(Map *_m, bool uniform)$/;"	f	class:mapCliqueAbstraction
mapCliqueAbstraction	abstraction/mapCliqueAbstraction.h	/^class mapCliqueAbstraction : public mapAbstraction {$/;"	c
mapFlatAbstraction	abstraction/mapFlatAbstraction.cpp	/^mapFlatAbstraction::mapFlatAbstraction(Map *_m)$/;"	f	class:mapFlatAbstraction
mapFlatAbstraction	abstraction/mapFlatAbstraction.h	/^class mapFlatAbstraction : public mapAbstraction {$/;"	c
mapProvider	abstraction/mapProvider.h	/^class mapProvider {$/;"	c
mapQuadTreeAbstraction	abstraction/mapQuadTreeAbstraction.cpp	/^mapQuadTreeAbstraction::mapQuadTreeAbstraction(Map *_m, int _sectorSize)$/;"	f	class:mapQuadTreeAbstraction
mapQuadTreeAbstraction	abstraction/mapQuadTreeAbstraction.h	/^class mapQuadTreeAbstraction : public mapAbstraction {$/;"	c
mapType	util/map.h	/^	tMapType mapType;$/;"	m	class:Map
mapUpdated	simulation/unit.cpp	/^bool unit::mapUpdated(mapAbstraction *aMap)$/;"	f	class:unit
map_height	simulation/unitSimulation.h	/^	int map_width, map_height, map_revision;$/;"	m	class:unitSimulation
map_name	util/map.h	/^	char map_name[128];$/;"	m	class:Map
map_revision	simulation/unit.h	/^	int map_revision;$/;"	m	class:unit
map_revision	simulation/unitSimulation.h	/^	int map_width, map_height, map_revision;$/;"	m	class:unitSimulation
map_width	simulation/unitSimulation.h	/^	int map_width, map_height, map_revision;$/;"	m	class:unitSimulation
maplocation	tests/TestConstants.h	/^const string maplocation = HOGHOME+"maps\/local\/demo.map"; \/\/ testmap$/;"	v
mapname	tests/ExperimentManager.h	/^			std::string mapname;$/;"	m	class:ExpMgrUtil::TestExperiment
mark	util/graph.h	/^	bool mark;$/;"	m	class:edge
markEdge	util/graph.h	/^  void markEdge(edge *e) { markedEdge = e; }$/;"	f	class:node
markedEdge	util/graph.h	/^  edge *markedEdge;$/;"	m	class:node
max	driver/MAC/HID Support/HID_Utilities.h	/^    long max;								\/\/ reported max value possible$/;"	m	struct:recElement
max	driver/MAC/HID Support/HID_Utilities_External.h	/^    long max;								\/\/ reported max value possible$/;"	m	struct:recElement
max	shared/aStar.cpp	/^inline double max(double a, double b)$/;"	f
max	util/GenericAStar.cpp	/^inline double max(double a, double b)$/;"	f
max	util/statUtil.cpp	/^inline double max(double a, double b)$/;"	f
max3DTextureSize	driver/MAC/macGlCheck.h	/^  long max3DTextureSize; \/\/ maximum 3D texture size supported$/;"	m	struct:__anon15
maxCubeMapTextureSize	driver/MAC/macGlCheck.h	/^  long maxCubeMapTextureSize; \/\/ maximum cube map texture size supported$/;"	m	struct:__anon15
maxRectTextureSize	driver/MAC/macGlCheck.h	/^  long maxRectTextureSize; \/\/ maximum rectangular texture size supported$/;"	m	struct:__anon15
maxReport	driver/MAC/HID Support/HID_Config_Utilities.h	/^    long maxReport; 						\/\/ max returned value (calibrate call)$/;"	m	struct:recSaveHID
maxReport	driver/MAC/HID Support/HID_Utilities.h	/^    long maxReport; 						\/\/ max returned value (calibrate call)$/;"	m	struct:recElement
maxReport	driver/MAC/HID Support/HID_Utilities_External.h	/^	long maxReport;$/;"	m	struct:recSaveHID
maxReport	driver/MAC/HID Support/HID_Utilities_External.h	/^    long maxReport; 						\/\/ max returned value (calibrate call)$/;"	m	struct:recElement
maxRounds	simulation/unitRaceSimulation.h	/^	long maxRounds;$/;"	m	class:unitRaceSimulation
maxStatEntries	util/statUtil.cpp	/^double maxStatEntries(statCollection *stats, const char *category, const char *owner)$/;"	f
maxTextureSize	driver/MAC/macGlCheck.h	/^  long maxTextureSize; \/\/ maximum 1D and 2D texture size supported$/;"	m	struct:__anon15
maxVal	util/mapOverlay.h	/^	double maxVal, minVal;$/;"	m	class:MapOverlay
maxx	shared/craStar.h	/^	int maxx;$/;"	m	class:craStar
maxx	shared/hpaStar.h	/^	int maxx;$/;"	m	class:hpaStar
maxy	shared/craStar.h	/^	int maxy;$/;"	m	class:craStar
maxy	shared/hpaStar.h	/^	int maxy;$/;"	m	class:hpaStar
measureAbstractionValues	abstraction/graphAbstraction.cpp	/^void graphAbstraction::measureAbstractionValues(int level, double &n, double &n_dev, double &c, double &c_dev)$/;"	f	class:graphAbstraction
measureAverageNodeWidth	abstraction/graphAbstraction.cpp	/^double graphAbstraction::measureAverageNodeWidth(int level)$/;"	f	class:graphAbstraction
measureAverageRatio	util/statUtil.cpp	/^void measureAverageRatio(statCollection *stats)$/;"	f
measureExpectedNodeWidth	abstraction/graphAbstraction.cpp	/^double graphAbstraction::measureExpectedNodeWidth(node *n)$/;"	f	class:graphAbstraction
measureRepairHits	abstraction/graphAbstraction.h	/^	virtual int measureRepairHits() { return 0; }$/;"	f	class:graphAbstraction
measureRepairHits	abstraction/mapCliqueAbstraction.cpp	/^int mapCliqueAbstraction::measureRepairHits()$/;"	f	class:mapCliqueAbstraction
merge	util/bitVector.cpp	/^void bitVector::merge(bitVector *bv)$/;"	f	class:bitVector
mergeGroupIntoNeighbor	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::mergeGroupIntoNeighbor(node *parent, int group, node *neighbor)$/;"	f	class:loadedCliqueAbstraction
mergeGroupIntoNeighbor	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::mergeGroupIntoNeighbor(node *parent, int group, node *neighbor)$/;"	f	class:mapCliqueAbstraction
message	aha/AnnotatedCluster.h	/^		std::string* message;$/;"	m	class:EntranceException
message	driver/common.h	/^	char message[256]; \/\/ buffer for message output$/;"	m	struct:recContext
min	abstraction/clusterAbstraction.cpp	/^int clusterAbstraction::min(int i, int j)$/;"	f	class:clusterAbstraction
min	driver/MAC/HID Support/HID_Utilities.h	/^    long min;								\/\/ reported min value possible$/;"	m	struct:recElement
min	driver/MAC/HID Support/HID_Utilities_External.h	/^    long min;								\/\/ reported min value possible$/;"	m	struct:recElement
minReport	driver/MAC/HID Support/HID_Config_Utilities.h	/^    long minReport; 						\/\/ min returned value$/;"	m	struct:recSaveHID
minReport	driver/MAC/HID Support/HID_Utilities.h	/^    long minReport; 						\/\/ min returned value$/;"	m	struct:recElement
minReport	driver/MAC/HID Support/HID_Utilities_External.h	/^	long minReport;$/;"	m	struct:recSaveHID
minReport	driver/MAC/HID Support/HID_Utilities_External.h	/^    long minReport; 						\/\/ min returned value$/;"	m	struct:recElement
minSpanningTree	abstraction/width.cpp	/^float minSpanningTree(node* n, graph* g)$/;"	f
minVal	util/mapOverlay.h	/^	double maxVal, minVal;$/;"	m	class:MapOverlay
minx	shared/craStar.h	/^	int minx;$/;"	m	class:craStar
minx	shared/hpaStar.h	/^	int minx;$/;"	m	class:hpaStar
miny	shared/craStar.h	/^	int miny;$/;"	m	class:craStar
miny	shared/hpaStar.h	/^	int miny;$/;"	m	class:hpaStar
mod	driver/common.h	/^	tKeyboardModifier mod;$/;"	m	class:keyboardCallbackData
modeFSAA	driver/common.h	/^	long modeFSAA;$/;"	m	struct:recContext
modifiedNodeQ	abstraction/loadedCliqueAbstraction.h	/^  std::vector<node *> modifiedNodeQ;$/;"	m	class:loadedCliqueAbstraction
modifiedNodeQ	abstraction/mapCliqueAbstraction.h	/^  std::vector<node *> modifiedNodeQ;$/;"	m	class:mapCliqueAbstraction
mouseCallback	driver/common.h	/^typedef bool (*mouseCallback)(unitSimulation *, int x, int y, point3d loc, tButtonType, tMouseEventType);$/;"	t
mouseCallbackData	driver/common.h	/^	mouseCallbackData(mouseCallback _mC)$/;"	f	class:mouseCallbackData
mouseCallbackData	driver/common.h	/^class mouseCallbackData {$/;"	c
mouseCallbacks	driver/common.cpp	/^static std::vector<mouseCallbackData *> mouseCallbacks;$/;"	v	file:
mouseDolly	driver/MAC/mac_main.cpp	/^static void mouseDolly (HIPoint location, pRecContext pContextInfo)$/;"	f	file:
mouseDolly	driver/main.cpp	/^static void mouseDolly (int x, int y, pRecContext pContextInfo)$/;"	f	file:
mouseMovedButton	driver/main.cpp	/^void mouseMovedButton(int x, int y)$/;"	f
mousePan	driver/MAC/mac_main.cpp	/^static void mousePan (HIPoint location, pRecContext pContextInfo)$/;"	f	file:
mousePan	driver/main.cpp	/^static void mousePan (int x, int y, pRecContext pContextInfo)$/;"	f	file:
mousePressedButton	driver/main.cpp	/^void mousePressedButton(int button, int state, int x, int y)$/;"	f
mouseTracking	apps/sample/sample.cpp	/^bool mouseTracking;$/;"	v
moveDist	simulation/unitSimulation.h	/^	double thinkTime, moveDist;$/;"	m	class:unitInfo
moveQ	simulation/unitSimulation.h	/^	std::priority_queue<const unitInfo*, std::vector<unitInfo *>, unitInfoCompare> moveQ;$/;"	m	class:unitSimulation
moves	shared/patrolUnit.h	/^	std::vector<tDirection> moves;$/;"	m	class:patrolUnit
moves	shared/rewardUnit.h	/^	std::vector<tDirection> moves;$/;"	m	class:rewardSeekingUnit
moves	shared/searchUnit.h	/^	std::vector<tDirection> moves;$/;"	m	class:searchUnit
movieFrame	driver/MAC/mac_main.cpp	/^	movieFrame(char *im, int w, int h, double dur)$/;"	f	class:movieFrame
movieFrame	driver/MAC/mac_main.cpp	/^class movieFrame {$/;"	c	file:
movieMedia	driver/MAC/mac_main.cpp	/^Media movieMedia = NULL;$/;"	v
mprov	tests/CapabilityUnitTest.h	/^		mapProvider *mprov;$/;"	m	class:CapabilityUnitTest
msgTime	driver/common.h	/^	float msgTime; \/\/ message posting time for expiration$/;"	m	struct:recContext
myCLHandler	apps/sample/sample.cpp	/^int myCLHandler(char *argument[], int maxNumArgs)$/;"	f
myClickHandler	apps/sample/sample.cpp	/^bool myClickHandler(unitSimulation *unitSim, int, int, point3d loc, tButtonType button, tMouseEventType mType)$/;"	f
myClustersizeCLHandler	apps/sample/sample.cpp	/^int myClustersizeCLHandler(char *argument[], int maxNumArgs)$/;"	f
myColor	driver/TextBox.h	/^	recColor myColor;$/;"	m	class:TextBox
myDisplayHandler	apps/sample/sample.cpp	/^void myDisplayHandler(unitSimulation *unitSim, tKeyboardModifier mod, char key)$/;"	f
myExecuteScenarioCLHandler	apps/sample/sample.cpp	/^int myExecuteScenarioCLHandler(char *argument[], int maxNumArgs)$/;"	f
myGUICLHandler	apps/sample/sample.cpp	/^int myGUICLHandler(char *argument[], int maxNumArgs)$/;"	f
myPathfindingKeyHandler	apps/sample/sample.cpp	/^void myPathfindingKeyHandler(unitSimulation *unitSim, tKeyboardModifier mod, char)$/;"	f
myQualityCLHandler	apps/sample/sample.cpp	/^int myQualityCLHandler(char *argument[], int maxNumArgs)$/;"	f
myRandomUnitKeyHandler	apps/sample/sample.cpp	/^void myRandomUnitKeyHandler(unitSimulation *unitSim, tKeyboardModifier mod, char)$/;"	f
myScenarioGeneratorCLHandler	apps/sample/sample.cpp	/^int myScenarioGeneratorCLHandler(char *argument[], int maxNumArgs)$/;"	f
myTextBox	driver/main.cpp	/^TextBox *myTextBox = 0;$/;"	v
myUnits	simulation/unitGroup.h	/^	std::vector<unit *> myUnits;$/;"	m	class:unitGroup
myharness	tests/AnnotatedClusterMockFactory.h	/^		AnnotatedClusterAbstractionTest *myharness;$/;"	m	class:AnnotatedClusterMockFactory
n	tests/AnnotatedAStarTest.h	/^		node  *pos, *n;	$/;"	m	class:AnnotatedAStarTest
n	tests/AnnotatedHierarchicalAStarTest.h	/^		node  *p, *n;	$/;"	m	class:AnnotatedHierarchicalAStarTest
n	tests/TestNode.h	/^	node *n;$/;"	m	class:TestNode
n	util/path.h	/^  node *n;$/;"	m	class:path
n1	tests/AnnotatedClusterAbstractionTest.h	/^		node *n1, *n2, *n3, *n4;$/;"	m	class:AnnotatedClusterAbstractionTest
n2	tests/AnnotatedClusterAbstractionTest.h	/^		node *n1, *n2, *n3, *n4;$/;"	m	class:AnnotatedClusterAbstractionTest
n3	tests/AnnotatedClusterAbstractionTest.h	/^		node *n1, *n2, *n3, *n4;$/;"	m	class:AnnotatedClusterAbstractionTest
n4	tests/AnnotatedClusterAbstractionTest.h	/^		node *n1, *n2, *n3, *n4;$/;"	m	class:AnnotatedClusterAbstractionTest
name	driver/MAC/HID Support/HID_Utilities.h	/^    Str255 name;							\/\/ name of element (not used often)$/;"	m	struct:recElement
name	driver/MAC/HID Support/HID_Utilities_External.h	/^    char name[256];							\/\/ name of element (c string)$/;"	m	struct:recElement
name	shared/praStarUnit.h	/^char name[32];$/;"	m	class:praStarUnit
name	util/graph.h	/^  char name[30];$/;"	m	class:node
names	driver/common.h	/^	char * names;$/;"	m	struct:recContext
nclearance	tests/AnnotatedMapAbstractionTest.h	/^		int nclearance;$/;"	m	class:AnnotatedMapAbstractionTest
neighborAbstractGraph	abstraction/loadedCliqueAbstraction.cpp	/^graph *loadedCliqueAbstraction::neighborAbstractGraph(graph *g, int width)$/;"	f	class:loadedCliqueAbstraction
neighbor_iterator	util/graph.h	/^typedef unsigned int neighbor_iterator;$/;"	t
neighbors	util/GenericAStar.h	/^	std::vector<uint32_t> neighbors;$/;"	m	class:GenericAStar
newPaths	abstraction/clusterAbstraction.h	/^  std::vector<path*> newPaths;$/;"	m	class:clusterAbstraction
newTileCount	shared/sharedAMapGroup.h	/^	int newTileCount;$/;"	m	class:sharedAMapGroup
newTileCountPerTrial	shared/sharedAMapGroup.h	/^	int newTileCountPerTrial;$/;"	m	class:sharedAMapGroup
next	driver/common.h	/^	keyboardCallbackData *next;$/;"	m	class:keyboardCallbackData
next	util/path.h	/^  path *next;$/;"	m	class:path
nextBound	util/GenericIDAStar.h	/^	double nextBound;$/;"	m	class:GenericIDAStar
nextDir	shared/humanUnit.h	/^	tDirection nextDir;$/;"	m	class:humanUnit
nextExperiment	apps/sample/sample.cpp	/^AHAExperiment* nextExperiment;$/;"	v
nextExperiment	simulation/unitSimulation.h	/^	void (*nextExperiment) (unitSimulation*);$/;"	m	class:unitSimulation
nextInLookup	shared/craStar.cpp	/^bool craStar::nextInLookup(int last, int curr, std::vector<node*> lookupVal)$/;"	f	class:craStar
nextInLookup	shared/hpaStar.cpp	/^bool hpaStar::nextInLookup(int last, int curr, std::vector<node*> lookup)$/;"	f	class:hpaStar
nextPathNode	shared/craStar.cpp	/^path* craStar::nextPathNode(graphAbstraction *m,node* n, int dir)$/;"	f	class:craStar
nextPathNode	shared/hpaStar.cpp	/^path* hpaStar::nextPathNode(node* n, int dir)$/;"	f	class:hpaStar
nextTime	simulation/unitSimulation.h	/^	double nextTime;$/;"	m	class:unitInfo
nibRef	driver/MAC/mac_main.cpp	/^IBNibRef nibRef = NULL;$/;"	v
noOpenGLDraw	simulation/unitSimulation.h	/^	bool noOpenGLDraw;		\/\/ turns display on\/off$/;"	m	class:unitSimulation
node	util/graph.cpp	/^node::node(const char *n)$/;"	f	class:node
node	util/graph.h	/^class node : public graph_object {$/;"	c
node	util/map.h	/^  long node;$/;"	m	class:halfTile
nodeClearanceEqualsMinimumOfAllNeighboursPlusOne	tests/AnnotatedMapAbstractionTest.cpp	/^void AnnotatedMapAbstractionTest::nodeClearanceEqualsMinimumOfAllNeighboursPlusOne()$/;"	f	class:AnnotatedMapAbstractionTest
nodeClearanceIsZeroForCapabilityThatDoesNotIncludeTheNodeTerrainType	tests/AnnotatedMapAbstractionTest.cpp	/^void AnnotatedMapAbstractionTest::nodeClearanceIsZeroForCapabilityThatDoesNotIncludeTheNodeTerrainType()$/;"	f	class:AnnotatedMapAbstractionTest
nodeClearanceMinimumClearanceWhenTerrainIsValidButAllNeighboursHardObstacles	tests/AnnotatedMapAbstractionTest.cpp	/^void AnnotatedMapAbstractionTest::nodeClearanceMinimumClearanceWhenTerrainIsValidButAllNeighboursHardObstacles()$/;"	f	class:AnnotatedMapAbstractionTest
nodeClearanceMinimumClearanceWhenTerrainIsValidButNoNeighbours	tests/AnnotatedMapAbstractionTest.cpp	/^void AnnotatedMapAbstractionTest::nodeClearanceMinimumClearanceWhenTerrainIsValidButNoNeighbours()$/;"	f	class:AnnotatedMapAbstractionTest
nodeClearanceZeroWhenTerrainIsHardObstacle	tests/AnnotatedMapAbstractionTest.cpp	/^void AnnotatedMapAbstractionTest::nodeClearanceZeroWhenTerrainIsHardObstacle()$/;"	f	class:AnnotatedMapAbstractionTest
nodeExists	abstraction/clusterAbstraction.cpp	/^int clusterAbstraction::nodeExists(const Cluster& c,double x,double y, graph* g)$/;"	f	class:clusterAbstraction
nodeInCorridor	shared/aStar.cpp	/^bool aStar::nodeInCorridor(node *n)$/;"	f	class:aStar
nodeIterNext	util/graph.cpp	/^node *graph::nodeIterNext(node_iterator &node_iter) const$/;"	f	class:graph
nodeLimit	abstraction/NodeLimitAbstraction.h	/^	int nodeLimit;$/;"	m	class:NodeLimitAbstraction
nodeNeighborNext	util/graph.cpp	/^int node::nodeNeighborNext(neighbor_iterator& ni) const$/;"	f	class:node
nodeNum	util/graph.h	/^  unsigned int nodeNum;\/\/, label[MAXLABELS];$/;"	m	class:node
nodeOccupied	simulation/unitSimulation.h	/^	inline bool nodeOccupied(node *currNode)$/;"	f	class:unitSimulation
nodeTable	util/GenericIDAStar.h	/^	NodeHashTable nodeTable;$/;"	m	class:GenericIDAStar
node_iterator	util/graph.h	/^typedef std::vector<node *>::const_iterator node_iterator;$/;"	t
nodes	abstraction/clusterAbstraction.h	/^  std::vector<int> nodes; \/\/ node numbers in abstract graph of the entrances$/;"	m	class:Cluster
nodesExpanded	aha/AnnotatedClusterAbstraction.h	/^		int nodesExpanded; $/;"	m	class:AnnotatedClusterAbstraction
nodesExpanded	shared/patrolUnit.h	/^	int nodesExpanded;$/;"	m	class:patrolUnit
nodesExpanded	shared/searchAlgorithm.h	/^	long nodesExpanded;$/;"	m	class:searchAlgorithm
nodesExpanded	shared/searchUnit.h	/^	int nodesExpanded;$/;"	m	class:searchUnit
nodesExpanded	util/GenericAStar.h	/^		long nodesTouched, nodesExpanded;$/;"	m	class:GenericAStar
nodesExpanded	util/GenericIDAStar.h	/^	unsigned long nodesExpanded, nodesTouched;$/;"	m	class:GenericIDAStar
nodesTouched	aha/AnnotatedClusterAbstraction.h	/^		int nodesTouched; $/;"	m	class:AnnotatedClusterAbstraction
nodesTouched	shared/patrolUnit.h	/^	int nodesTouched;$/;"	m	class:patrolUnit
nodesTouched	shared/searchAlgorithm.h	/^	long nodesTouched;$/;"	m	class:searchAlgorithm
nodesTouched	shared/searchUnit.h	/^	int nodesTouched;$/;"	m	class:searchUnit
nodesTouched	util/GenericAStar.h	/^		long nodesTouched, nodesExpanded;$/;"	m	class:GenericAStar
nodesTouched	util/GenericIDAStar.h	/^	unsigned long nodesExpanded, nodesTouched;$/;"	m	class:GenericIDAStar
nonLinear	driver/MAC/HID Support/HID_Utilities.h	/^    Boolean nonLinear;						\/\/ are the values reported non-linear relative to element movement$/;"	m	struct:recElement
nonLinear	driver/MAC/HID Support/HID_Utilities_External.h	/^    unsigned char nonLinear;						\/\/ are the values reported non-linear relative to element movement$/;"	m	struct:recElement
normalise	util/glUtil.cpp	/^void recVec::normalise()$/;"	f	class:recVec
nullState	driver/MAC/HID Support/HID_Utilities.h	/^    Boolean nullState;						\/\/ does element have null state$/;"	m	struct:recElement
nullState	driver/MAC/HID Support/HID_Utilities_External.h	/^    unsigned char nullState;						\/\/ does element have null state$/;"	m	struct:recElement
numActions	simulation/constants.h	/^const int numActions = 10;$/;"	v
numLevels	shared/praStar2.h	/^  int numLevels; \/\/ the number of levels at which an abstract path is found$/;"	m	class:praStar2
numPrimitiveActions	simulation/constants.h	/^const int numPrimitiveActions = 8;$/;"	v
numscenarios	tests/ScenarioManagerTest.h	/^		int numscenarios;$/;"	m	class:ScenarioManagerTest
objectRotation	driver/common.h	/^	GLfloat objectRotation [4];$/;"	m	struct:recContext
octileDistance	abstraction/mapAbstraction.cpp	/^double mapAbstraction::octileDistance(double x1, double y1, double x2, double y2)$/;"	f	class:mapAbstraction
offsetDisplayTime	simulation/unitSimulation.cpp	/^void unitSimulation::offsetDisplayTime(double val)$/;"	f	class:unitSimulation
onTarget	shared/searchUnit.h	/^	bool onTarget;$/;"	m	class:searchUnit
openGLDraw	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::openGLDraw()$/;"	f	class:clusterAbstraction
openGLDraw	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::openGLDraw()$/;"	f	class:loadedCliqueAbstraction
openGLDraw	abstraction/mapAbstraction.cpp	/^void mapAbstraction::openGLDraw()$/;"	f	class:mapAbstraction
openGLDraw	aha/AnnotatedClusterAbstraction.cpp	/^void AnnotatedClusterAbstraction::openGLDraw()$/;"	f	class:AnnotatedClusterAbstraction
openGLDraw	aha/AnnotatedMapAbstraction.cpp	/^void AnnotatedMapAbstraction::openGLDraw()$/;"	f	class:AnnotatedMapAbstraction
openGLDraw	aha/CapabilityUnit.cpp	/^void CapabilityUnit::openGLDraw(mapProvider *mp, simulationInfo *si)$/;"	f	class:CapabilityUnit
openGLDraw	shared/patrolUnit.cpp	/^void patrolUnit::openGLDraw(mapProvider *mp, simulationInfo *)$/;"	f	class:patrolUnit
openGLDraw	shared/rewardUnit.cpp	/^void rewardSeekingUnit::openGLDraw(mapProvider *mp, simulationInfo *)$/;"	f	class:rewardSeekingUnit
openGLDraw	shared/rewardUnit.cpp	/^void rewardUnit::openGLDraw(mapProvider *mp, simulationInfo *)$/;"	f	class:rewardUnit
openGLDraw	shared/searchUnit.cpp	/^void searchUnit::openGLDraw(mapProvider *mp, simulationInfo *si)$/;"	f	class:searchUnit
openGLDraw	shared/sharedAMapGroup.cpp	/^void sharedAMapGroup::openGLDraw(mapProvider *, simulationInfo *)$/;"	f	class:sharedAMapGroup
openGLDraw	simulation/unit.cpp	/^void unit::openGLDraw(mapProvider *mp, simulationInfo *)$/;"	f	class:unit
openGLDraw	simulation/unitGroup.cpp	/^void unitGroup::openGLDraw(mapProvider *mp, simulationInfo *)$/;"	f	class:unitGroup
openGLDraw	simulation/unitSimulation.cpp	/^void unitSimulation::openGLDraw()$/;"	f	class:unitSimulation
openGLDraw	tests/AnnotatedMapAbstractionMock.h	/^		void openGLDraw() { }$/;"	f	class:AnnotatedMapAbstractionMock
openGLDraw	util/map.cpp	/^void Map::openGLDraw(tDisplay how)$/;"	f	class:Map
openGLDraw	util/mapOverlay.cpp	/^void MapOverlay::openGLDraw()$/;"	f	class:MapOverlay
openList	shared/aStar.h	/^	AStar3Util::NodeLookupTable openList, closedList;$/;"	m	class:aStar
openNewMap	driver/MAC/mac_main.cpp	/^void openNewMap()$/;"	f
openQueue	shared/aStar.h	/^	AStar3Util::PQueue openQueue;$/;"	m	class:aStar
openQueue	util/GenericAStar.h	/^	GenericAStarUtil::PQueue openQueue;$/;"	m	class:GenericAStar
openSimHistory	driver/MAC/mac_main.cpp	/^void openSimHistory()$/;"	f
operator ()	abstraction/clusterAbstraction.h	/^		bool operator()(const edge* e1, const edge* e2)$/;"	f	struct:clusterUtil::EdgeEqual
operator ()	abstraction/clusterAbstraction.h	/^		size_t operator()(const edge *e) const$/;"	f	struct:clusterUtil::EdgeHash
operator ()	shared/aStar.h	/^		bool operator()(const SearchNode &i1, const SearchNode &i2)$/;"	f	struct:AStar3Util::SearchNodeCompare
operator ()	shared/aStar.h	/^		bool operator()(const SearchNode &i1, const SearchNode &i2)$/;"	f	struct:AStar3Util::SearchNodeEqual
operator ()	shared/aStar.h	/^		bool operator()(const node *i1, const node *i2)$/;"	f	struct:AStar3Util::NodeEqual
operator ()	shared/aStar.h	/^		size_t operator()(const SearchNode &x) const$/;"	f	struct:AStar3Util::SearchNodeHash
operator ()	shared/aStar.h	/^		size_t operator()(const node *x) const$/;"	f	struct:AStar3Util::NodeHash
operator ()	simulation/unitSimulation.cpp	/^bool unitInfoCompare::operator()(const unitInfo* u1, const unitInfo* u2)$/;"	f	class:unitInfoCompare
operator ()	util/GenericAStar.h	/^		bool operator()(const SearchNode &i1, const SearchNode &i2)$/;"	f	struct:GenericAStarUtil::SearchNodeCompare
operator ()	util/GenericAStar.h	/^		bool operator()(const SearchNode &i1, const SearchNode &i2)$/;"	f	struct:GenericAStarUtil::SearchNodeEqual
operator ()	util/GenericAStar.h	/^		size_t operator()(const SearchNode &x) const$/;"	f	struct:GenericAStarUtil::SearchNodeHash
operator <<	util/graph.cpp	/^ostream& operator <<(ostream & out, const edge &_Edge)$/;"	f
operator <<	util/graph.cpp	/^ostream& operator <<(ostream & out, const graph &_Graph)$/;"	f
operator <<	util/graph.cpp	/^ostream& operator <<(ostream & out, const graph_object &_Obj)$/;"	f
operator <<	util/graph.cpp	/^ostream& operator <<(ostream & out, const node &_Node)$/;"	f
operator ==	tests/ComplexNumberTest.h	/^  friend bool operator ==(const Complex& a, const Complex& b) {   return a.real == b.real  &&  a.imaginary == b.imaginary; }$/;"	f	class:Complex
origin	driver/main.h	/^   CGPoint origin;$/;"	m	struct:CGRect
outputs	driver/MAC/HID Support/HID_Utilities.h	/^	long outputs;							\/\/ number of elements of type kIOHIDElementTypeOutput$/;"	m	struct:recDevice
outputs	driver/MAC/HID Support/HID_Utilities_External.h	/^	long outputs;							\/\/ number of elements of type kIOHIDElementTypeOutput$/;"	m	struct:recDevice
owner	util/statCollection.h	/^	int category, owner;$/;"	m	class:stat
owners	util/statCollection.h	/^	std::vector<const char *> owners;$/;"	m	class:statCollection
p	tests/AnnotatedHierarchicalAStarTest.h	/^		node  *p, *n;	$/;"	m	class:AnnotatedHierarchicalAStarTest
pActionRec	driver/MAC/HID Support/HIDSupport.h	/^typedef actionRec * pActionRec;$/;"	t
pChild	driver/MAC/HID Support/HID_Utilities.h	/^    struct recElement * pChild;				\/\/ next child (only of collections)$/;"	m	struct:recElement	typeref:struct:recElement::recElement
pChild	driver/MAC/HID Support/HID_Utilities_External.h	/^    struct recElement * pChild;				\/\/ next child (only of collections)$/;"	m	struct:recElement	typeref:struct:recElement::recElement
pDevice	driver/MAC/HID Support/HIDSupport.h	/^    pRecDevice pDevice;$/;"	m	struct:actionRec
pElement	driver/MAC/HID Support/HIDSupport.h	/^    pRecElement pElement;$/;"	m	struct:actionRec
pListElements	driver/MAC/HID Support/HID_Utilities.h	/^    recElement* pListElements; 				\/\/ head of linked list of elements $/;"	m	struct:recDevice
pListElements	driver/MAC/HID Support/HID_Utilities_External.h	/^    recElement* pListElements; 				\/\/ head of linked list of elements $/;"	m	struct:recDevice
pNext	driver/MAC/HID Support/HID_Utilities.h	/^    struct recDevice* pNext; 				\/\/ next device$/;"	m	struct:recDevice	typeref:struct:recDevice::recDevice
pNext	driver/MAC/HID Support/HID_Utilities_External.h	/^    struct recDevice* pNext; 				\/\/ next device$/;"	m	struct:recDevice	typeref:struct:recDevice::recDevice
pPrevious	driver/MAC/HID Support/HID_Utilities.h	/^	struct recElement * pPrevious;			\/\/ previous element (NULL at list head)$/;"	m	struct:recElement	typeref:struct:recElement::recElement
pPrevious	driver/MAC/HID Support/HID_Utilities_External.h	/^	struct recElement * pPrevious;			\/\/ previous element (NULL at list head)$/;"	m	struct:recElement	typeref:struct:recElement::recElement
pRecContext	driver/common.h	/^typedef struct recContext * pRecContext;$/;"	t	typeref:struct:recContext
pRecDevice	driver/MAC/HID Support/HID_Utilities.h	/^typedef recDevice* pRecDevice;$/;"	t
pRecDevice	driver/MAC/HID Support/HID_Utilities_External.h	/^typedef recDevice* pRecDevice;$/;"	t
pRecElement	driver/MAC/HID Support/HID_Utilities.h	/^typedef recElement* pRecElement;$/;"	t
pRecElement	driver/MAC/HID Support/HID_Utilities_External.h	/^typedef recElement* pRecElement;$/;"	t
pRecSaveHID	driver/MAC/HID Support/HID_Config_Utilities.h	/^typedef recSaveHID * pRecSaveHID;$/;"	t
pRecSaveHID	driver/MAC/HID Support/HID_Utilities_External.h	/^typedef recSaveHID * pRecSaveHID;$/;"	t
pSibling	driver/MAC/HID Support/HID_Utilities.h	/^    struct recElement * pSibling;			\/\/ next sibling (for elements and collections)$/;"	m	struct:recElement	typeref:struct:recElement::recElement
pSibling	driver/MAC/HID Support/HID_Utilities_External.h	/^    struct recElement * pSibling;			\/\/ next sibling (for elements and collections)$/;"	m	struct:recElement	typeref:struct:recElement::recElement
paintRoomInside	util/map.cpp	/^void Map::paintRoomInside(int x, int y)$/;"	f	class:Map
param	driver/common.h	/^	const char *param;$/;"	m	class:commandLineCallbackData
parents	abstraction/clusterAbstraction.h	/^    std::vector<node*> parents; \/\/ each connected component gets its own parent$/;"	m	class:Cluster
partialLimit	shared/craStar.h	/^	int partialLimit;$/;"	m	class:craStar
partialLimit	shared/hpaStar.h	/^	int partialLimit;$/;"	m	class:hpaStar
partialLimit	shared/praStar.h	/^  int partialLimit;$/;"	m	class:praStar
partialLimit	shared/praStar2.h	/^	int partialLimit;$/;"	m	class:praStar2
partialLimit	shared/spreadPRAStar.h	/^	int partialLimit;$/;"	m	class:spreadPRAStar
passFilter	util/statCollection.cpp	/^bool statCollection::passFilter(const char *category) const$/;"	f	class:statCollection
path	util/path.h	/^  path(node *_n, path *_next=0) : n(_n), next(_next) {}$/;"	f	class:path
path	util/path.h	/^class path {$/;"	c
pathCache	aha/AnnotatedClusterAbstraction.h	/^		ACAUtil::pathTable pathCache;$/;"	m	class:AnnotatedClusterAbstraction
pathTable	aha/AnnotatedClusterAbstraction.h	/^	typedef __gnu_cxx::hash_map<int, path*> pathTable;$/;"	t	namespace:ACAUtil
pathable	abstraction/MapLineAbstraction.cpp	/^bool MapLineAbstraction::MapLineAbstraction::pathable(node *from, node *to)$/;"	f	class:MapLineAbstraction::MapLineAbstraction
pathable	abstraction/NodeLimitAbstraction.cpp	/^bool NodeLimitAbstraction::pathable(node *from, node *to)$/;"	f	class:NodeLimitAbstraction
pathable	abstraction/clusterAbstraction.cpp	/^bool clusterAbstraction::pathable(node* from, node* to)$/;"	f	class:clusterAbstraction
pathable	abstraction/loadedCliqueAbstraction.cpp	/^bool loadedCliqueAbstraction::pathable(node *from, node *to)$/;"	f	class:loadedCliqueAbstraction
pathable	abstraction/loadedCliqueAbstraction.cpp	/^bool loadedCliqueAbstraction::pathable(unsigned int from, unsigned int to)$/;"	f	class:loadedCliqueAbstraction
pathable	abstraction/mapCliqueAbstraction.cpp	/^bool mapCliqueAbstraction::pathable(node *from, node *to)$/;"	f	class:mapCliqueAbstraction
pathable	abstraction/mapCliqueAbstraction.cpp	/^bool mapCliqueAbstraction::pathable(unsigned int from, unsigned int to)$/;"	f	class:mapCliqueAbstraction
pathable	abstraction/mapFlatAbstraction.cpp	/^bool mapFlatAbstraction::pathable(node *from, node *to)$/;"	f	class:mapFlatAbstraction
pathable	abstraction/mapQuadTreeAbstraction.cpp	/^bool mapQuadTreeAbstraction::pathable(node *from, node *to)$/;"	f	class:mapQuadTreeAbstraction
pathable	abstraction/radiusAbstraction.cpp	/^bool radiusAbstraction::pathable(node *from, node *to)$/;"	f	class:radiusAbstraction
pathable	aha/AnnotatedMapAbstraction.cpp	/^bool AnnotatedMapAbstraction::pathable(node* from, node* to)$/;"	f	class:AnnotatedMapAbstraction
pathable	aha/AnnotatedMapAbstraction.cpp	/^bool AnnotatedMapAbstraction::pathable(node* from, node* to, int capability, int agentsize)$/;"	f	class:AnnotatedMapAbstraction
pathable	tests/AnnotatedMapAbstractionMock.cpp	/^bool AnnotatedMapAbstractionMock::pathable(node* start, node* goal)$/;"	f	class:AnnotatedMapAbstractionMock
pathable	tests/AnnotatedMapAbstractionMock.cpp	/^bool AnnotatedMapAbstractionMock::pathable(node* start, node* goal, int caps, int agentsize)$/;"	f	class:AnnotatedMapAbstractionMock
pathable	tests/ExperimentManager.h	/^			bool pathable; \/\/ does a solution exist for this problem?$/;"	m	class:ExpMgrUtil::TestExperiment
paths	abstraction/clusterAbstraction.h	/^  clusterUtil::PathLookupTable paths;$/;"	m	class:clusterAbstraction
patrolUnit	shared/patrolUnit.cpp	/^patrolUnit::patrolUnit(int _x, int _y)$/;"	f	class:patrolUnit
patrolUnit	shared/patrolUnit.cpp	/^patrolUnit::patrolUnit(int _x, int _y, int numPLocations, unitSimulation* us)$/;"	f	class:patrolUnit
patrolUnit	shared/patrolUnit.h	/^class patrolUnit : public unit {$/;"	c
pause	simulation/unitSimulation.h	/^	bool pause;$/;"	m	class:unitSimulation
peakMemory	aha/AnnotatedClusterAbstraction.h	/^		int peakMemory; $/;"	m	class:AnnotatedClusterAbstraction
peakmemory	aha/AnnotatedAStar.h	/^		long peakmemory;$/;"	m	class:AbstractAnnotatedAStar
penalty	simulation/unitSimulation.h	/^	double penalty;$/;"	m	class:unitSimulation
planFromMiddle	shared/praStar.h	/^	bool planFromMiddle;$/;"	m	class:praStar
planFromMiddle	shared/praStar2.h	/^  bool planFromMiddle;$/;"	m	class:praStar2
point3d	util/glUtil.h	/^  point3d() {}$/;"	f	class:point3d
point3d	util/glUtil.h	/^  point3d(GLfloat a, GLfloat b, GLfloat c) :x(a), y(b), z(c) {}$/;"	f	class:point3d
point3d	util/glUtil.h	/^class point3d {$/;"	c
points	driver/common.h	/^	bool points;$/;"	m	struct:recContext
polygons	driver/common.h	/^	bool polygons;$/;"	m	struct:recContext
pop	util/heap2.h	/^	void pop() { remove(); }$/;"	f	class:heap2
pos	tests/AnnotatedAStarTest.h	/^		node  *pos, *n;	$/;"	m	class:AnnotatedAStarTest
possibleDir	simulation/constants.h	/^const tDirection possibleDir[numActions] = { kN, kNE, kE, kSE, kS, kSW, kW, kNW, kStay, kTeleport };$/;"	v
praStar	shared/praStar.cpp	/^praStar::praStar()$/;"	f	class:praStar
praStar	shared/praStar.h	/^class praStar : public searchAlgorithm {$/;"	c
praStar2	shared/praStar2.cpp	/^praStar2::praStar2()$/;"	f	class:praStar2
praStar2	shared/praStar2.h	/^class praStar2 : public searchAlgorithm {$/;"	c
praStarUnit	shared/praStarUnit.cpp	/^praStarUnit::praStarUnit(int _x, int _y, unit *_target, praStar *_alg)$/;"	f	class:praStarUnit
praStarUnit	shared/praStarUnit.h	/^class praStarUnit : public searchUnit {$/;"	c
preferredState	driver/MAC/HID Support/HID_Utilities.h	/^    Boolean preferredState;					\/\/ does element have a preferred state (such as a button)$/;"	m	struct:recElement
preferredState	driver/MAC/HID Support/HID_Utilities_External.h	/^    unsigned char preferredState;					\/\/ does element have a preferred state (such as a button)$/;"	m	struct:recElement
prevNode	shared/aStar.h	/^		node *prevNode;$/;"	m	class:AStar3Util::SearchNode
prevNode	util/GenericAStar.h	/^		uint32_t prevNode;$/;"	m	class:GenericAStarUtil::SearchNode
print	simulation/unitSimulation.cpp	/^void unitSimulation::print(bool forceOutput)$/;"	f	class:unitSimulation
print	util/map.cpp	/^void Map::print(int _scale)$/;"	f	class:Map
print	util/path.cpp	/^void path::print(bool beginning)$/;"	f	class:path
printCollectedStats	simulation/unitSimulation.h	/^	void printCollectedStats(bool v) { stats.enablePrintOutput(v); }$/;"	f	class:unitSimulation
printCommandLineArguments	driver/common.cpp	/^void printCommandLineArguments()$/;"	f
printKeyboardAssignments	driver/common.cpp	/^void printKeyboardAssignments()$/;"	f
printMapCoord	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::printMapCoord(node* n)$/;"	f	class:clusterAbstraction
printOutput	util/statCollection.h	/^	bool printOutput;$/;"	m	class:statCollection
printPathAsCoord	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::printPathAsCoord(path* p)$/;"	f	class:clusterAbstraction
printStats	shared/aStar.cpp	/^void aStar::printStats()$/;"	f	class:aStar
printStats	util/GenericAStar.cpp	/^void GenericAStar::printStats()$/;"	f	class:GenericAStar
printStats	util/graph.cpp	/^void graph::printStats()$/;"	f	class:graph
printStatsTable	util/statCollection.cpp	/^void statCollection::printStatsTable() const$/;"	f	class:statCollection
probDirChange	simulation/unit.h	/^	double probDirChange;$/;"	m	class:billiardBallUnit
problemNode	aha/AnnotatedCluster.h	/^		node *problemNode; $/;"	m	class:AnnotatedClusterException
processCommandLineArgs	driver/common.cpp	/^void processCommandLineArgs(int argc, char *argv[])$/;"	f
processFramesPerSecond	driver/main.cpp	/^int processFramesPerSecond(char *argument[], int maxNumArgs)$/;"	f
processMenuEvents	driver/main.cpp	/^void processMenuEvents(int option)$/;"	f
processStats	apps/sample/sample.cpp	/^void processStats(statCollection *stat)$/;"	f
processStats	apps/sample/sample.cpp	/^void processStats(statCollection* stat, const char* unitname)$/;"	f
product	driver/MAC/HID Support/HID_Utilities.h	/^    Str255 product;							\/\/ name of product$/;"	m	struct:recDevice
product	driver/MAC/HID Support/HID_Utilities_External.h	/^    char product[256];						\/\/ name of product$/;"	m	struct:recDevice
productID	driver/MAC/HID Support/HID_Config_Utilities.h	/^    long productID;$/;"	m	struct:recSaveHID
productID	driver/MAC/HID Support/HID_Utilities.h	/^    long productID;							\/\/ id for particular product, unique across all of a vendors devices$/;"	m	struct:recDevice
productID	driver/MAC/HID Support/HID_Utilities_External.h	/^    long productID;							\/\/ id for particular product, unique across all of a vendors devices$/;"	m	struct:recDevice
productID	driver/MAC/HID Support/HID_Utilities_External.h	/^    long productID;$/;"	m	struct:recSaveHID
px1	apps/sample/sample.cpp	/^int px1, py1, px2, py2;$/;"	v
px2	apps/sample/sample.cpp	/^int px1, py1, px2, py2;$/;"	v
py1	apps/sample/sample.cpp	/^int px1, py1, px2, py2;$/;"	v
py2	apps/sample/sample.cpp	/^int px1, py1, px2, py2;$/;"	v
quality	aha/AnnotatedClusterAbstraction.h	/^		ACAUtil::GraphQualityParameter quality;$/;"	m	class:AnnotatedClusterAbstraction
queue	driver/MAC/HID Support/HID_Utilities.h	/^    IOHIDQueueInterface ** queue;			\/\/ device queue, NULL = no queue$/;"	m	struct:recDevice
queue	driver/MAC/HID Support/HID_Utilities_External.h	/^    void * queue;							\/\/ device queue, NULL = no queue$/;"	m	struct:recDevice
r	simulation/unit.h	/^	GLfloat r, g, b;$/;"	m	class:unit
r	util/glUtil.h	/^	GLfloat r,g,b;$/;"	m	class:recColor
radius	abstraction/radiusAbstraction.h	/^	int radius;$/;"	m	class:radiusAbstraction
radiusAbstraction	abstraction/radiusAbstraction.cpp	/^radiusAbstraction::radiusAbstraction(Map *_m, int _radius)$/;"	f	class:radiusAbstraction
radiusAbstraction	abstraction/radiusAbstraction.h	/^class radiusAbstraction : public mapAbstraction {$/;"	c
randomUnit	simulation/unit.h	/^	randomUnit(int _x, int _y)$/;"	f	class:randomUnit
randomUnit	simulation/unit.h	/^	randomUnit(int _x, int _y, int _r, int _g, int _b)$/;"	f	class:randomUnit
randomUnit	simulation/unit.h	/^class randomUnit : public unit {$/;"	c
randomerUnit	simulation/unit.h	/^	randomerUnit(int _x, int _y)$/;"	f	class:randomerUnit
randomerUnit	simulation/unit.h	/^	randomerUnit(int _x, int _y, int _r, int _g, int _b)$/;"	f	class:randomerUnit
randomerUnit	simulation/unit.h	/^class randomerUnit : public unit {$/;"	c
real	tests/ComplexNumberTest.h	/^  double real, imaginary;$/;"	m	class:Complex
realTime	simulation/unitSimulation.h	/^	bool realTime;$/;"	m	class:unitSimulation
recCamera	driver/common.h	/^} recCamera;$/;"	t	typeref:struct:__anon7
recColor	util/glUtil.h	/^class recColor {$/;"	c
recContext	driver/common.h	/^struct recContext$/;"	s
recContext	driver/common.h	/^typedef struct recContext recContext;$/;"	t	typeref:struct:recContext
recDevice	driver/MAC/HID Support/HID_Utilities.h	/^struct recDevice$/;"	s
recDevice	driver/MAC/HID Support/HID_Utilities.h	/^typedef struct recDevice recDevice;$/;"	t	typeref:struct:recDevice
recDevice	driver/MAC/HID Support/HID_Utilities_External.h	/^struct recDevice$/;"	s
recDevice	driver/MAC/HID Support/HID_Utilities_External.h	/^typedef struct recDevice recDevice;$/;"	t	typeref:struct:recDevice
recElement	driver/MAC/HID Support/HID_Utilities.h	/^struct recElement$/;"	s
recElement	driver/MAC/HID Support/HID_Utilities.h	/^typedef struct recElement recElement;$/;"	t	typeref:struct:recElement
recElement	driver/MAC/HID Support/HID_Utilities_External.h	/^struct recElement$/;"	s
recElement	driver/MAC/HID Support/HID_Utilities_External.h	/^typedef struct recElement recElement;$/;"	t	typeref:struct:recElement
recSaveHID	driver/MAC/HID Support/HID_Config_Utilities.h	/^struct recSaveHID$/;"	s
recSaveHID	driver/MAC/HID Support/HID_Config_Utilities.h	/^typedef struct recSaveHID recSaveHID;$/;"	t	typeref:struct:recSaveHID
recSaveHID	driver/MAC/HID Support/HID_Utilities_External.h	/^struct recSaveHID$/;"	s
recSaveHID	driver/MAC/HID Support/HID_Utilities_External.h	/^typedef struct recSaveHID recSaveHID;$/;"	t	typeref:struct:recSaveHID
recVec	util/glUtil.h	/^class recVec {$/;"	c
receiveReward	shared/rewardUnit.cpp	/^void rewardSeekingUnit::receiveReward(double amount)$/;"	f	class:rewardSeekingUnit
receiveReward	shared/rewardUnit.h	/^	virtual void receiveReward(double) {}$/;"	f	class:rewardUnit
recording	driver/MAC/mac_main.cpp	/^bool recording = false;$/;"	v
refcount	tests/ExperimentManager.cpp	/^int ExperimentManager::refcount=0;$/;"	m	class:ExperimentManager	file:
refcount	tests/ExperimentManager.h	/^		static int refcount;$/;"	m	class:ExperimentManager
regFontList	driver/common.h	/^	GLuint regFontList;$/;"	m	struct:recContext
relative	driver/MAC/HID Support/HID_Utilities.h	/^    Boolean relative;						\/\/ are reports relative to last report (deltas)$/;"	m	struct:recElement
relative	driver/MAC/HID Support/HID_Utilities_External.h	/^    unsigned char relative;						\/\/ are reports relative to last report (deltas)$/;"	m	struct:recElement
relax	util/graph.cpp	/^bool graph::relax(edge *e, int weightIndex)$/;"	f	class:graph
relaxEdge	shared/aStar3.cpp	/^void aStarOld::relaxEdge(heap *nodeHeap, graph *g, edge *e, int source, int nextNode, node *d)$/;"	f	class:aStarOld
relaxEdge	shared/corridorAStar.cpp	/^void corridorAStar::relaxEdge(heap *nodeHeap, graph *, graphAbstraction *aMap,$/;"	f	class:corridorAStar
relaxEdge	shared/praStar.cpp	/^void praStar::relaxEdge(heap *nodeHeap, graph *g, edge *e, int source, int nextNode, int dest,$/;"	f	class:praStar
relaxFinalEdge	shared/corridorAStar.cpp	/^void corridorAStar::relaxFinalEdge(heap *nodeHeap, graph *, graphAbstraction *aMap,$/;"	f	class:corridorAStar
relaxFirstEdge	shared/corridorAStar.cpp	/^void corridorAStar::relaxFirstEdge(heap *nodeHeap, graph *, graphAbstraction *aMap,$/;"	f	class:corridorAStar
relaxReverseEdge	util/graph.cpp	/^bool graph::relaxReverseEdge(edge *e, int weightIndex)$/;"	f	class:graph
remove	util/heap.cpp	/^graph_object *heap::remove()$/;"	f	class:heap
remove	util/heap2.h	/^OBJ heap2<OBJ, HashKey, EqKey, CmpKey>::remove()$/;"	f	class:heap2
removeDominatedEdgesAndEndpoints	aha/AnnotatedClusterAbstraction.cpp	/^void AnnotatedClusterAbstraction::removeDominatedEdgesAndEndpoints()$/;"	f	class:AnnotatedClusterAbstraction
removeDominatedEdgesAndEndpointsShouldDeleteAllMarkedEdgesAndAnyEndpointsWhichAreNotRequiredByOtherInterEdges	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::removeDominatedEdgesAndEndpointsShouldDeleteAllMarkedEdgesAndAnyEndpointsWhichAreNotRequiredByOtherInterEdges()$/;"	f	class:AnnotatedClusterAbstractionTest
removeDominatedEdgesAndEndpointsShouldDeleteAnyDominatedEdgeButNotAnyEndpointsWhichConnectOtherInterEdges	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::removeDominatedEdgesAndEndpointsShouldDeleteAnyDominatedEdgeButNotAnyEndpointsWhichConnectOtherInterEdges()$/;"	f	class:AnnotatedClusterAbstractionTest
removeDominatedEdgesAndEndpointsShouldNotDeleteAnythingIfNoEdgesAreMarked	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::removeDominatedEdgesAndEndpointsShouldNotDeleteAnythingIfNoEdgesAreMarked()$/;"	f	class:AnnotatedClusterAbstractionTest
removeDominatedEdgesAndEndpointsShouldRemove__kParent__LabelOfLowLevelNodesThatWereAbstractedByADeletedNode	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::removeDominatedEdgesAndEndpointsShouldRemove__kParent__LabelOfLowLevelNodesThatWereAbstractedByADeletedNode()$/;"	f	class:AnnotatedClusterAbstractionTest
removeDominatedEdgesAndEndpointsShouldRepairAbstractNodeCollectionInEachAffectedCluster	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::removeDominatedEdgesAndEndpointsShouldRepairAbstractNodeCollectionInEachAffectedCluster()$/;"	f	class:AnnotatedClusterAbstractionTest
removeDominatedEdgesAndEndpointsShouldRepair__kParent__LabelsOfLowLevelsNodes	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::removeDominatedEdgesAndEndpointsShouldRepair__kParent__LabelsOfLowLevelsNodes()$/;"	f	class:AnnotatedClusterAbstractionTest
removeDominatedNodeFromGraph	aha/AnnotatedClusterAbstraction.cpp	/^void AnnotatedClusterAbstraction::removeDominatedNodeFromGraph(node* n, graph* absg)$/;"	f	class:AnnotatedClusterAbstraction
removeDominatedNodeFromParentCluster	aha/AnnotatedClusterAbstraction.cpp	/^void AnnotatedClusterAbstraction::removeDominatedNodeFromParentCluster(node* n)$/;"	f	class:AnnotatedClusterAbstraction
removeEdge	abstraction/MapLineAbstraction.cpp	/^void MapLineAbstraction::removeEdge(edge *, unsigned int)$/;"	f	class:MapLineAbstraction
removeEdge	abstraction/NodeLimitAbstraction.cpp	/^void NodeLimitAbstraction::removeEdge(edge *, unsigned int)$/;"	f	class:NodeLimitAbstraction
removeEdge	abstraction/clusterAbstraction.h	/^  void removeEdge(edge*, unsigned int) {}$/;"	f	class:clusterAbstraction
removeEdge	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::removeEdge(edge *e, unsigned int absLevel)$/;"	f	class:loadedCliqueAbstraction
removeEdge	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::removeEdge(edge *e, unsigned int absLevel)$/;"	f	class:mapCliqueAbstraction
removeEdge	abstraction/mapFlatAbstraction.cpp	/^void mapFlatAbstraction::removeEdge(edge *e, unsigned int)$/;"	f	class:mapFlatAbstraction
removeEdge	abstraction/mapQuadTreeAbstraction.cpp	/^void mapQuadTreeAbstraction::removeEdge(edge *, unsigned int)$/;"	f	class:mapQuadTreeAbstraction
removeEdge	abstraction/radiusAbstraction.cpp	/^void radiusAbstraction::removeEdge(edge *, unsigned int)$/;"	f	class:radiusAbstraction
removeEdge	aha/AnnotatedMapAbstraction.h	/^		void removeEdge(edge*, unsigned int) {}$/;"	f	class:AnnotatedMapAbstraction
removeEdge	tests/AnnotatedMapAbstractionMock.h	/^		void removeEdge(edge*, unsigned int) {}$/;"	f	class:AnnotatedMapAbstractionMock
removeEdge	util/graph.cpp	/^void graph::removeEdge(edge *e)$/;"	f	class:graph
removeEdge	util/graph.cpp	/^void node::removeEdge(edge *e)$/;"	f	class:node
removeJoystickHandler	driver/common.cpp	/^void removeJoystickHandler(joystickCallback jC, void *userdata)$/;"	f
removeMouseClickHandler	driver/common.cpp	/^void removeMouseClickHandler(mouseCallback mC)$/;"	f
removeNode	abstraction/MapLineAbstraction.cpp	/^void MapLineAbstraction::removeNode(node *)$/;"	f	class:MapLineAbstraction
removeNode	abstraction/NodeLimitAbstraction.cpp	/^void NodeLimitAbstraction::removeNode(node *)$/;"	f	class:NodeLimitAbstraction
removeNode	abstraction/clusterAbstraction.h	/^	void removeNode(node*) {}$/;"	f	class:clusterAbstraction
removeNode	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::removeNode(node *n)$/;"	f	class:loadedCliqueAbstraction
removeNode	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::removeNode(node *n)$/;"	f	class:mapCliqueAbstraction
removeNode	abstraction/mapFlatAbstraction.cpp	/^void mapFlatAbstraction::removeNode(node *n)$/;"	f	class:mapFlatAbstraction
removeNode	abstraction/mapQuadTreeAbstraction.cpp	/^void mapQuadTreeAbstraction::removeNode(node *)$/;"	f	class:mapQuadTreeAbstraction
removeNode	abstraction/radiusAbstraction.cpp	/^void radiusAbstraction::removeNode(node *)$/;"	f	class:radiusAbstraction
removeNode	aha/AnnotatedMapAbstraction.h	/^		void removeNode(node*) {} $/;"	f	class:AnnotatedMapAbstraction
removeNode	tests/AnnotatedMapAbstractionMock.h	/^		void removeNode(node*) {} $/;"	f	class:AnnotatedMapAbstractionMock
removeNode	util/graph.cpp	/^node *graph::removeNode(node *n, unsigned int &oldID)$/;"	f	class:graph
removeNode	util/graph.h	/^  void removeNode(node *n) { unsigned int x; removeNode(n, x); } \/\/ if you don't care about node #'s$/;"	f	class:graph
removeNode	util/graph.h	/^  void removeNode(unsigned int nodeNum) { removeNode(getNode(nodeNum)); }$/;"	f	class:graph
removeNodeFromRepairQ	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::removeNodeFromRepairQ(node *n)$/;"	f	class:loadedCliqueAbstraction
removeNodeFromRepairQ	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::removeNodeFromRepairQ(node *n)$/;"	f	class:mapCliqueAbstraction
removeNodes	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::removeNodes(node* start, node* goal)$/;"	f	class:clusterAbstraction
removeStartAndGoalNodesFromAbstractGraph	aha/AnnotatedClusterAbstraction.cpp	/^void AnnotatedClusterAbstraction::removeStartAndGoalNodesFromAbstractGraph()$/;"	f	class:AnnotatedClusterAbstraction
removeStartAndGoalNodesFromAbstractGraphShouldDeleteAllNodesAndEdgesAddedByInsertionMethodFromAbstractGraph	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::removeStartAndGoalNodesFromAbstractGraphShouldDeleteAllNodesAndEdgesAddedByInsertionMethodFromAbstractGraph()$/;"	f	class:AnnotatedClusterAbstractionTest
removeStartAndGoalNodesFromAbstractGraphShouldDeleteAllNodesAndEdgesAddedByInsertionMethodFromParentClusters	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::removeStartAndGoalNodesFromAbstractGraphShouldDeleteAllNodesAndEdgesAddedByInsertionMethodFromParentClusters()$/;"	f	class:AnnotatedClusterAbstractionTest
removeStartAndGoalNodesFromAbstractGraphShouldDeleteAllPathsAddedByInsertionMethod	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::removeStartAndGoalNodesFromAbstractGraphShouldDeleteAllPathsAddedByInsertionMethod()$/;"	f	class:AnnotatedClusterAbstractionTest
removeStartAndGoalNodesFromAbstractGraphShouldNotDeleteAnyNodesOriginallyInTheAbstractGraph	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::removeStartAndGoalNodesFromAbstractGraphShouldNotDeleteAnyNodesOriginallyInTheAbstractGraph()$/;"	f	class:AnnotatedClusterAbstractionTest
removeStartAndGoalNodesFromAbstractGraphShouldResetStartIDAndGoalIDToDefaultValues	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::removeStartAndGoalNodesFromAbstractGraphShouldResetStartIDAndGoalIDToDefaultValues()$/;"	f	class:AnnotatedClusterAbstractionTest
removeStartAndGoalNodesFromAbstractGraphShouldResetToDefault_kParent_LabelOfOriginalNodesForWhichANewNodeWasInsertedIntoAbstractGraph	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::removeStartAndGoalNodesFromAbstractGraphShouldResetToDefault_kParent_LabelOfOriginalNodesForWhichANewNodeWasInsertedIntoAbstractGraph()$/;"	f	class:AnnotatedClusterAbstractionTest
removeUnit	simulation/unitGroup.cpp	/^void unitGroup::removeUnit(unit *u)$/;"	f	class:unitGroup
renameNodeInAbstraction	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::renameNodeInAbstraction(node *which, unsigned int oldID)$/;"	f	class:loadedCliqueAbstraction
renameNodeInAbstraction	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::renameNodeInAbstraction(node *which, unsigned int oldID)$/;"	f	class:mapCliqueAbstraction
renderScene	driver/main.cpp	/^void renderScene(void)$/;"	f
rendererID	driver/MAC/macGlCheck.h	/^  unsigned long rendererID; \/\/ renderer ID$/;"	m	struct:__anon15
repairAbstractNodeCollectionInClusters	aha/AnnotatedClusterAbstraction.cpp	/^void AnnotatedClusterAbstraction::repairAbstractNodeCollectionInClusters()$/;"	f	class:AnnotatedClusterAbstraction
repairAbstraction	abstraction/MapLineAbstraction.cpp	/^void MapLineAbstraction::repairAbstraction()$/;"	f	class:MapLineAbstraction
repairAbstraction	abstraction/NodeLimitAbstraction.cpp	/^void NodeLimitAbstraction::repairAbstraction()$/;"	f	class:NodeLimitAbstraction
repairAbstraction	abstraction/clusterAbstraction.h	/^  void repairAbstraction() {}$/;"	f	class:clusterAbstraction
repairAbstraction	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::repairAbstraction()$/;"	f	class:loadedCliqueAbstraction
repairAbstraction	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::repairAbstraction()$/;"	f	class:mapCliqueAbstraction
repairAbstraction	abstraction/mapFlatAbstraction.cpp	/^void mapFlatAbstraction::repairAbstraction()$/;"	f	class:mapFlatAbstraction
repairAbstraction	abstraction/mapQuadTreeAbstraction.cpp	/^void mapQuadTreeAbstraction::repairAbstraction()$/;"	f	class:mapQuadTreeAbstraction
repairAbstraction	abstraction/radiusAbstraction.cpp	/^void radiusAbstraction::repairAbstraction()$/;"	f	class:radiusAbstraction
repairAbstraction	aha/AnnotatedMapAbstraction.h	/^		void repairAbstraction() {}$/;"	f	class:AnnotatedMapAbstraction
repairAbstraction	tests/AnnotatedMapAbstractionMock.h	/^		void repairAbstraction() {}$/;"	f	class:AnnotatedMapAbstractionMock
repair_kParent_Labels	aha/AnnotatedClusterAbstraction.cpp	/^void AnnotatedClusterAbstraction::repair_kParent_Labels()$/;"	f	class:AnnotatedClusterAbstraction
reportError	driver/MAC/mac_main.cpp	/^void reportError(char * strError)$/;"	f
require	tests/AnnotatedClusterAbstractionMock.h	/^#undef require$/;"	d
require	tests/AnnotatedClusterMock.h	/^#undef require$/;"	d
resRefNum	driver/MAC/mac_main.cpp	/^short resRefNum;$/;"	v
reservationProvider	simulation/reservationProvider.h	/^class reservationProvider {$/;"	c
reserveMove	simulation/unitSimulation.h	/^	virtual bool reserveMove(node *, node *, double, unit *) { return true; }$/;"	f	class:unitSimulation
reset	util/heap2.h	/^void heap2<OBJ, HashKey, EqKey, CmpKey>::reset()$/;"	f	class:heap2
resetCamera	driver/common.cpp	/^void resetCamera()$/;"	f
resetCamera	driver/common.cpp	/^void resetCamera(recCamera * pCamera)$/;"	f
resetLocationCache	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::resetLocationCache(node *n)$/;"	f	class:loadedCliqueAbstraction
resetLocationCache	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::resetLocationCache(node *n)$/;"	f	class:mapCliqueAbstraction
resetNodeCount	shared/aStar.h	/^	void resetNodeCount() { nodesExpanded = nodesTouched = 0; }$/;"	f	class:aStar
resetNodeCount	util/GenericAStar.h	/^	void resetNodeCount() { nodesExpanded = nodesTouched = 0; }$/;"	f	class:GenericAStar
resetNodeCount	util/GenericIDAStar.h	/^	void resetNodeCount() { nodesExpanded = nodesTouched = 0; }$/;"	f	class:GenericIDAStar
resetValues	util/mapOverlay.cpp	/^void MapOverlay::resetValues()$/;"	f	class:MapOverlay
resizeGL	driver/MAC/mac_main.cpp	/^OSStatus resizeGL(pRecContext pContextInfo, CGRect viewRect)$/;"	f
resizeGL	driver/main.cpp	/^void resizeGL(pRecContext pContextInfo, CGRect viewRect)$/;"	f
resizeWindow	driver/main.cpp	/^void resizeWindow(int x, int y)$/;"	f
reverse	util/path.cpp	/^path *path::reverse()$/;"	f	class:path
revision	util/map.h	/^  int revision;$/;"	m	class:Map
rewardLocs	shared/rewardUnit.h	/^	std::vector<rewardUnit *> rewardLocs;$/;"	m	class:rewardSeekingUnit
rewardSeekingUnit	shared/rewardUnit.cpp	/^rewardSeekingUnit::rewardSeekingUnit(int _x, int _y)$/;"	f	class:rewardSeekingUnit
rewardSeekingUnit	shared/rewardUnit.h	/^class rewardSeekingUnit : public rewardUnit {$/;"	c
rewardUnit	shared/rewardUnit.cpp	/^rewardUnit::rewardUnit(int _x, int _y)$/;"	f	class:rewardUnit
rewardUnit	shared/rewardUnit.h	/^class rewardUnit : public unit {$/;"	c
rhrUnit	simulation/unit.h	/^	rhrUnit(int _x, int _y)$/;"	f	class:rhrUnit
rhrUnit	simulation/unit.h	/^class rhrUnit : public unit {$/;"	c
rollToTrackball	driver/trackball.cpp	/^void rollToTrackball (long x, long y, float rot [4]) \/\/ rot is output rotation angle$/;"	f
rotPoint	driver/common.h	/^	recVec rotPoint; \/\/ Point to rotate about$/;"	m	struct:__anon7
rotation2Quat	driver/trackball.cpp	/^static void rotation2Quat (float *A, float *q)$/;"	f	file:
rows	abstraction/clusterAbstraction.h	/^  int rows; \/\/rows of clusters$/;"	m	class:clusterAbstraction
rp	shared/praStar.h	/^	reservationProvider *rp;$/;"	m	class:praStar
rp	shared/spreadExecSearchAlgorithm.h	/^	reservationProvider *rp;$/;"	m	class:spreadExecSearchAlgorithm
runAHA	apps/sample/sample.cpp	/^bool runAHA=false;$/;"	v
runEvaluateTest	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::runEvaluateTest(TestExperiment* exp)$/;"	f	class:AnnotatedAStarTest
runExperiment	tests/AnnotatedMapAbstractionTest.cpp	/^void AnnotatedMapAbstractionTest::runExperiment(ExperimentKey expkey)$/;"	f	class:AnnotatedMapAbstractionTest
runGetPathTest	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::runGetPathTest(TestExperiment* exp, string &errmsg)$/;"	f	class:AnnotatedAStarTest
runNextExperiment	apps/sample/sample.cpp	/^void runNextExperiment(unitSimulation *unitSim)$/;"	f
runSimulationNoGUI	apps/sample/sample.cpp	/^void runSimulationNoGUI()$/;"	f
sType	util/statCollection.h	/^	storedType sType;$/;"	m	class:stat
s_algorithm	shared/searchUnit.h	/^	spreadExecSearchAlgorithm *s_algorithm;$/;"	m	class:searchUnit
sameStart	simulation/unitRaceSimulation.h	/^	bool sameStart;$/;"	m	class:unitRaceSimulation
sample_OBJS	apps/sample.mk	/^sample_OBJS = sample.o$/;"	m
save	util/map.cpp	/^void Map::save(FILE *f)$/;"	f	class:Map
save	util/map.cpp	/^void Map::save(const char *filename)$/;"	f	class:Map
save	util/map.cpp	/^void Map::save(std::stringstream &\/*data*\/) {}$/;"	f	class:Map
saveHistory	simulation/unitSimulation.cpp	/^bool unitSimulation::saveHistory(char *fname, bool includeMap)$/;"	f	class:unitSimulation
saveOctile	util/map.cpp	/^void Map::saveOctile(FILE *f)$/;"	f	class:Map
savePath	driver/MAC/mac_main.cpp	/^void savePath(WindowRef window, pRecContext pContextInfo)$/;"	f
savePicture	driver/MAC/mac_main.cpp	/^void savePicture(WindowRef window, pRecContext pContextInfo)$/;"	f
saveRaw	util/map.cpp	/^void Map::saveRaw(FILE *f)$/;"	f	class:Map
saveSimHistory	driver/MAC/mac_main.cpp	/^void saveSimHistory(WindowRef window, pRecContext pContextInfo)$/;"	f
sawNewLand	shared/sharedAMapGroup.h	/^	bool sawNewLand;$/;"	m	class:sharedAMapGroup
scale	util/map.cpp	/^void Map::scale(long newWidth, long newHeight)$/;"	f	class:Map
scaleX	shared/scenarioLoader.h	/^  int scaleX;$/;"	m	class:Experiment
scaleY	shared/scenarioLoader.h	/^  int scaleY;$/;"	m	class:Experiment
scaledMax	driver/MAC/HID Support/HID_Utilities.h	/^    long scaledMax;							\/\/ reported scaled max value possible$/;"	m	struct:recElement
scaledMax	driver/MAC/HID Support/HID_Utilities_External.h	/^    long scaledMax;							\/\/ reported scaled max value possible$/;"	m	struct:recElement
scaledMin	driver/MAC/HID Support/HID_Utilities.h	/^    long scaledMin;							\/\/ reported scaled min value possible$/;"	m	struct:recElement
scaledMin	driver/MAC/HID Support/HID_Utilities_External.h	/^    long scaledMin;							\/\/ reported scaled min value possible$/;"	m	struct:recElement
scenName	shared/scenarioLoader.h	/^		char scenName[1024];$/;"	m	class:ScenarioLoader
scenario	apps/sample/sample.cpp	/^bool scenario=false;$/;"	v
scenariomgr	apps/sample/sample.cpp	/^AHAScenarioManager scenariomgr;$/;"	v
scrolling	driver/TextBox.h	/^	bool deform, scrolling;$/;"	m	class:TextBox
searchAlgorithm	shared/searchAlgorithm.h	/^	searchAlgorithm() { nodesExpanded = nodesTouched = 0; }$/;"	f	class:searchAlgorithm
searchAlgorithm	shared/searchAlgorithm.h	/^class searchAlgorithm {$/;"	c
searchTime	aha/AnnotatedClusterAbstraction.h	/^		double searchTime;$/;"	m	class:AnnotatedClusterAbstraction
searchUnit	shared/searchUnit.cpp	/^searchUnit::searchUnit(int _x, int _y, float _r, float _g, float _b, unit *_target, searchAlgorithm *alg)$/;"	f	class:searchUnit
searchUnit	shared/searchUnit.cpp	/^searchUnit::searchUnit(int _x, int _y, int _r, int _g, int _b, unit *_target, searchAlgorithm *alg)$/;"	f	class:searchUnit
searchUnit	shared/searchUnit.cpp	/^searchUnit::searchUnit(int _x, int _y, unit *_target, searchAlgorithm *alg)$/;"	f	class:searchUnit
searchUnit	shared/searchUnit.cpp	/^searchUnit::searchUnit(int _x, int _y, unit *_target, spreadExecSearchAlgorithm *alg)$/;"	f	class:searchUnit
searchUnit	shared/searchUnit.h	/^class searchUnit : public unit {$/;"	c
searchUnit_H	shared/searchUnit.h	/^#define searchUnit_H$/;"	d
searchalg	aha/AnnotatedMapAbstraction.h	/^		AbstractAnnotatedAStar* searchalg;$/;"	m	class:AbstractAnnotatedMapAbstraction
searchtime	aha/AnnotatedAStar.h	/^		double searchtime;$/;"	m	class:AbstractAnnotatedAStar
sectorSize	abstraction/mapQuadTreeAbstraction.h	/^	int sectorSize;$/;"	m	class:mapQuadTreeAbstraction
seen	shared/sharedAMapGroup.h	/^	bitVector *seen;$/;"	m	class:sharedAMapGroup
seenBefore	shared/sharedAMapGroup.h	/^        bool seenBefore(int x, int y) { return (seen->get(y * map->getMapWidth() + x)); }$/;"	f	class:sharedAMapGroup
selectTopAbstractionLevel	shared/praStar2.cpp	/^void praStar2::selectTopAbstractionLevel(graphAbstraction *aMap,$/;"	f	class:praStar2
sendReward	shared/rewardUnit.h	/^	virtual double sendReward() { return 1.0; }$/;"	f	class:rewardUnit
serial	driver/MAC/HID Support/HID_Utilities.h	/^    Str255 serial;							\/\/ serial number of specific product, can be assumed unique across specific product or specific vendor (not used often)$/;"	m	struct:recDevice
serial	driver/MAC/HID Support/HID_Utilities_External.h	/^    char serial[256];						\/\/ serial number of specific product, can be assumed unique across specific product or specific vendor (not used often)$/;"	m	struct:recDevice
set	util/bitVector.cpp	/^void bitVector::set(int index, bool value)$/;"	f	class:bitVector
setAbstractGraph	tests/AnnotatedClusterTest.h	/^		void setAbstractGraph(graph *g) { this->absg = g; }$/;"	f	class:exceptionThrownHelper
setAbstractLevel	shared/craStar.h	/^	void setAbstractLevel(int level) { absLevel = level; }$/;"	f	class:craStar
setAbstraction	shared/hpaStar.h	/^	void setAbstraction(clusterAbstraction* _m) { m = _m; } $/;"	f	class:hpaStar
setAgentLocation	simulation/unitSimulation.cpp	/^void unitSimulation::setAgentLocation(unitInfo *u, bool success, bool timer)$/;"	f	class:unitSimulation
setAgentsize	aha/ScenarioManager.h	/^		void setAgentsize(int newsize) { agentsize = newsize; }$/;"	f	class:AHAExperiment
setAnnotatedCluster	tests/AnnotatedClusterTest.h	/^		void setAnnotatedCluster(AnnotatedCluster* ac) { this->ac = ac; }$/;"	f	class:exceptionThrownHelper
setAnnotatedClusterAbstraction	tests/AnnotatedClusterTest.h	/^		void setAnnotatedClusterAbstraction(AnnotatedClusterAbstraction* aca) { this->aca = aca; }$/;"	f	class:exceptionThrownHelper
setAsynchronous	simulation/unitSimulation.h	/^	void setAsynchronous() { asynch = true; }$/;"	f	class:unitSimulation
setCache	shared/praStar.cpp	/^void praStar::setCache(path **p)$/;"	f	class:praStar
setCanCrossDiagonally	simulation/unitSimulation.h	/^	void setCanCrossDiagonally(bool cross) { disallowDiagonalCrossingMoves = !cross; }$/;"	f	class:unitSimulation
setCapability	aha/AnnotatedAStar.h	/^		void setCapability(int capability) { this->capability = capability; }$/;"	f	class:AbstractAnnotatedAStar
setCapability	aha/ScenarioManager.h	/^		void setCapability(int newcapability) { capability = newcapability; }$/;"	f	class:AHAExperiment
setClearance	aha/AnnotatedAStar.h	/^		void setClearance(int clearance) { this->clearance = clearance; }$/;"	f	class:AbstractAnnotatedAStar
setClearance	util/graph.cpp	/^void edge::setClearance(int capability, int clearance)$/;"	f	class:edge
setClearance	util/graph.cpp	/^void node::setClearance(int terraintype, int value)$/;"	f	class:node
setClearanceFailsWhenNodeTerrainNotValid	tests/TestNode.cpp	/^void TestNode::setClearanceFailsWhenNodeTerrainNotValid()$/;"	f	class:TestNode
setClearanceShouldDoNothingWhenCapabilityIsNotValid	tests/EdgeTest.cpp	/^void EdgeTest::setClearanceShouldDoNothingWhenCapabilityIsNotValid()$/;"	f	class:EdgeTest
setClearanceShouldDoNothingWhenClearanceValueIsLessThanOrEqualToZero	tests/EdgeTest.cpp	/^void EdgeTest::setClearanceShouldDoNothingWhenClearanceValueIsLessThanOrEqualToZero()$/;"	f	class:EdgeTest
setClearanceShouldStoreAGivenCapabilityAndItsCorrespondingClearanceValue	tests/EdgeTest.cpp	/^void EdgeTest::setClearanceShouldStoreAGivenCapabilityAndItsCorrespondingClearanceValue()$/;"	f	class:EdgeTest
setCluster1Id	abstraction/clusterAbstraction.h	/^  void setCluster1Id(int id) {m_cluster1Id=id;}$/;"	f	class:Entrance
setCluster2Id	abstraction/clusterAbstraction.h	/^  void setCluster2Id(int id) {m_cluster2Id=id;}  $/;"	f	class:Entrance
setClusterId	abstraction/clusterAbstraction.h	/^	void setClusterId(const int newid) { m_id = newid; }$/;"	f	class:Cluster
setColor	driver/TextBox.h	/^	void setColor(recColor _myColor) { myColor = _myColor; }$/;"	f	class:TextBox
setColor	simulation/unit.h	/^	void setColor(GLfloat _r, GLfloat _g, GLfloat _b) { r=_r; g=_g; b=_b; }$/;"	f	class:unit
setColorMap	util/mapOverlay.h	/^	void setColorMap(int val) { colorMap = val; }$/;"	f	class:MapOverlay
setCornerHeight	util/map.cpp	/^void Map::setCornerHeight(long x, long y, tCorner which,$/;"	f	class:Map
setCorridor	abstraction/clusterAbstraction.cpp	/^	void setCorridor(std::vector<node *> &corr)$/;"	f	class:ClusterSearchEnvironment
setCorridor	shared/aStar.cpp	/^void aStar::setCorridor(path *corridor, int width)$/;"	f	class:aStar
setCorridor	shared/corridorAStar.cpp	/^void corridorAStar::setCorridor(const std::vector<node *> *c)$/;"	f	class:corridorAStar
setCorridorClusters	aha/AnnotatedAStar.h	/^		void setCorridorClusters(int cid1, int cid2) { cluster1 = cid1; cluster2 = cid2; }$/;"	f	class:AbstractAnnotatedAStar
setCurrentTestExperiment	tests/AnnotatedAStarMock.h	/^		void setCurrentTestExperiment(ExpMgrUtil::TestExperiment* exp) { curexp = exp; }$/;"	f	class:AnnotatedAStarMock
setCurrentTestExperiment	tests/AnnotatedMapAbstractionMock.cpp	/^void AnnotatedMapAbstractionMock::setCurrentTestExperiment(TestExperiment* exp)$/;"	f	class:AnnotatedMapAbstractionMock
setDebugInfo	aha/AnnotatedMapAbstraction.h	/^		void setDebugInfo(bool debug) { this->debuginfo = debug; }$/;"	f	class:AbstractAnnotatedMapAbstraction
setDebugInfo	util/graph.h	/^  void setDebugInfo(bool debug) { debuginfo = debug; }$/;"	f	class:graph_object
setDefaultEdgeWeight	shared/aStar3.h	/^	void setDefaultEdgeWeight(double newwh) { wh = newwh; }$/;"	f	class:aStarOld
setDisjunctiveTrialEnd	simulation/unitRaceSimulation.h	/^	void setDisjunctiveTrialEnd(bool value) { disjunctiveTrialEnd = value; }$/;"	f	class:unitRaceSimulation
setDisplayTime	simulation/unitSimulation.cpp	/^void unitSimulation::setDisplayTime(double val)$/;"	f	class:unitSimulation
setDrawClearance	aha/AnnotatedClusterAbstraction.h	/^		void setDrawClearance(bool draw) { drawClearance = draw; }$/;"	f	class:AnnotatedClusterAbstraction
setDrawClusters	aha/AnnotatedClusterAbstraction.h	/^		void setDrawClusters(bool draw) { drawClusters = draw; }$/;"	f	class:AnnotatedClusterAbstraction
setDrawLand	util/map.cpp	/^void Map::setDrawLand(bool dLand)$/;"	f	class:Map
setEnhancedAbstractPathing	shared/praStar2.h	/^	void setEnhancedAbstractPathing(bool enhance) { enhancedAbstractPathing = enhance; }$/;"	f	class:praStar2
setExpandSearchRadius	shared/praStar.h	/^	void setExpandSearchRadius(bool _expandSearchRadius) { expandSearchRadius = _expandSearchRadius; }$/;"	f	class:praStar
setExpandSearchRadius	shared/praStar2.h	/^  void setExpandSearchRadius(bool _expandSearchRadius) { expandSearchRadius = _expandSearchRadius; }$/;"	f	class:praStar2
setFailMessage	tests/AnnotatedClusterTest.h	/^		void setFailMessage(std::string& msg) { failmessage = msg; } $/;"	f	class:exceptionThrownHelper
setFixedPlanLevel	shared/praStar.h	/^	void setFixedPlanLevel(int p) { fixedPlanLevel = p; }$/;"	f	class:praStar
setFixedPlanLevel	shared/praStar2.h	/^  void setFixedPlanLevel(int p) { fixedPlanLevel = p; }$/;"	f	class:praStar2
setGraphAbstraction	shared/aStar3.h	/^	void setGraphAbstraction(graphAbstraction *aMap) { map = aMap; }$/;"	f	class:aStarOld
setGraphQualityParameter	aha/AnnotatedClusterAbstraction.h	/^		void setGraphQualityParameter(ACAUtil::GraphQualityParameter newqual) { quality = newqual; }$/;"	f	class:AnnotatedClusterAbstraction
setHOrig	abstraction/clusterAbstraction.h	/^	void setHOrig(const int newhorig) { m_horizOrigin = newhorig; }$/;"	f	class:Cluster
setHeight	abstraction/clusterAbstraction.h	/^	void setHeight(const int newheight) { m_height = newheight; }$/;"	f	class:Cluster
setHeight	util/map.cpp	/^void Map::setHeight(long x, long y, long tHeight, tSplitSide split)$/;"	f	class:Map
setHome	driver/common.cpp	/^void setHome(char* val) { HOGHOME=val; std::cout<<"\\nHOGHOME="<<HOGHOME<<". Can be overridden by setting the HOGHOME environment variable."; }$/;"	f
setIgnoreOnTarget	simulation/unitSimulation.cpp	/^bool unitSimulation::setIgnoreOnTarget(unit* u, bool x)$/;"	f	class:unitSimulation
setKeyLabel	util/graph.h	/^  void setKeyLabel(int which) { keyLabel = which; }$/;"	f	class:node
setLabelF	util/graph.cpp	/^void edge::setLabelF(unsigned int index, double val)$/;"	f	class:edge
setLabelF	util/graph.cpp	/^void node::setLabelF(unsigned int index, double val)$/;"	f	class:node
setLabelL	util/graph.cpp	/^void edge::setLabelL(unsigned int index, long val)$/;"	f	class:edge
setLabelL	util/graph.cpp	/^void node::setLabelL(unsigned int index, long val)$/;"	f	class:node
setLockstepTime	simulation/unitSimulation.h	/^	inline void setLockstepTime(bool b) { lockstepTime = b; }$/;"	f	class:unitSimulation
setMarked	util/graph.h	/^	void setMarked(bool marked) { mark = marked; }$/;"	f	class:edge
setMoveStochasticity	simulation/unitSimulation.h	/^	void setMoveStochasticity(double _stochasticity) { stochasticity = _stochasticity; }$/;"	f	class:unitSimulation
setNextDirection	shared/humanUnit.h	/^	void setNextDirection(tDirection dir) { nextDir = dir; }$/;"	f	class:humanUnit
setNextExperimentPtr	simulation/unitSimulation.h	/^	void setNextExperimentPtr(void (*nextExpPtr)(unitSimulation*)) { nextExperiment = nextExpPtr; }$/;"	f	class:unitSimulation
setNodeNum	util/map.cpp	/^void Map::setNodeNum(int num, int x, int y, tCorner corner)$/;"	f	class:Map
setNodesExpanded	aha/AnnotatedClusterAbstraction.h	/^		void setNodesExpanded(int num) {  nodesExpanded = num; }$/;"	f	class:AnnotatedClusterAbstraction
setNodesTouched	aha/AnnotatedClusterAbstraction.h	/^		void setNodesTouched(int num) {  nodesTouched = num; }$/;"	f	class:AnnotatedClusterAbstraction
setObjectType	simulation/unit.h	/^	void setObjectType(tObjectType _unitType) { unitType = _unitType; }$/;"	f	class:unit
setOverlayValue	util/mapOverlay.cpp	/^void MapOverlay::setOverlayValue(int x, int y, double value)$/;"	f	class:MapOverlay
setParentCluster	util/graph.cpp	/^void node::setParentCluster(int clusterid)$/;"	f	class:node
setParentClusterFailsWhenClusterIdLessThanZero	tests/TestNode.cpp	/^void TestNode::setParentClusterFailsWhenClusterIdLessThanZero()$/;"	f	class:TestNode
setParentClusterStoresClusterIdWhenClusterIdEqualsZero	tests/TestNode.cpp	/^void TestNode::setParentClusterStoresClusterIdWhenClusterIdEqualsZero()$/;"	f	class:TestNode
setParentClusterStoresClusterIdWhenClusterIdMoreThanZero	tests/TestNode.cpp	/^void TestNode::setParentClusterStoresClusterIdWhenClusterIdMoreThanZero()$/;"	f	class:TestNode
setPartialPathLimit	shared/craStar.h	/^	void setPartialPathLimit(int limit)$/;"	f	class:craStar
setPartialPathLimit	shared/hpaStar.h	/^	void setPartialPathLimit(int limit) { partialLimit = limit; $/;"	f	class:hpaStar
setPartialPathLimit	shared/praStar.h	/^	void setPartialPathLimit(int limit) { partialLimit = limit; $/;"	f	class:praStar
setPartialPathLimit	shared/praStar2.h	/^	void setPartialPathLimit(int limit)$/;"	f	class:praStar2
setPartialPathLimit	shared/spreadPRAStar.h	/^	void setPartialPathLimit(int limit)$/;"	f	class:spreadPRAStar
setPeakMemory	aha/AnnotatedClusterAbstraction.h	/^		void setPeakMemory(int num) {  peakMemory = num; }$/;"	f	class:AnnotatedClusterAbstraction
setPenalty	simulation/unitSimulation.h	/^	void setPenalty(double pen) { penalty = pen; }$/;"	f	class:unitSimulation
setPlanFromMiddle	shared/praStar.h	/^	void setPlanFromMiddle(bool _planFromMiddle) { planFromMiddle = _planFromMiddle; }$/;"	f	class:praStar
setPlanFromMiddle	shared/praStar2.h	/^  void setPlanFromMiddle(bool _planFromMiddle) { planFromMiddle = _planFromMiddle; } $/;"	f	class:praStar2
setRealTime	simulation/unitSimulation.cpp	/^void unitSimulation::setRealTime(bool _realTime)$/;"	f	class:unitSimulation
setRectHeight	util/map.cpp	/^void Map::setRectHeight(long x1, long y1, long x2, long y2, long h, tTerrain type)$/;"	f	class:Map
setSearchAlgorithm	aha/AnnotatedMapAbstraction.h	/^		virtual void setSearchAlgorithm(AbstractAnnotatedAStar* alg) { this->searchalg = alg; }$/;"	f	class:AbstractAnnotatedMapAbstraction
setSearchTime	aha/AnnotatedClusterAbstraction.h	/^		void setSearchTime(double newtime) { searchTime = newtime; }$/;"	f	class:AnnotatedClusterAbstraction
setSimulationPaused	simulation/unitSimulation.h	/^	void setSimulationPaused(bool val) { pause = val; }$/;"	f	class:unitSimulation
setSizeMultipler	util/map.h	/^	void setSizeMultipler(int _sizeMultiplier)$/;"	f	class:Map
setSkipParameter	shared/praStar2.h	/^  void setSkipParameter(int _skip) { skip = _skip; }$/;"	f	class:praStar2
setSmoothType	shared/craStar.h	/^	void setSmoothType(SmoothType s) { smType = s; }$/;"	f	class:craStar
setSmoothType	shared/hpaStar.h	/^	void setSmoothType(SmoothType s) { smType = s; }$/;"	f	class:hpaStar
setSmoothing	shared/craStar.h	/^	void setSmoothing(bool smooth) {smoothing = smooth;}$/;"	f	class:craStar
setSmoothing	shared/hpaStar.cpp	/^void hpaStar::setSmoothing(bool smooth){$/;"	f	class:hpaStar
setSpeed	simulation/unit.h	/^	void setSpeed(double s) { speed = s; }$/;"	f	class:unit
setSplit	util/map.cpp	/^void Map::setSplit(long x, long y, tSplit split)$/;"	f	class:Map
setStopOnConvergence	simulation/unitRaceSimulation.h	/^	void setStopOnConvergence(bool stop) { stopOnConvergence = stop; }$/;"	f	class:unitRaceSimulation
setSynchronous	simulation/unitSimulation.h	/^	void setSynchronous() { asynch = false; }$/;"	f	class:unitSimulation
setTarget	simulation/unit.h	/^	virtual void setTarget(unit *u) { target = u; }$/;"	f	class:unit
setTargetTolerance	simulation/unitRaceSimulation.h	/^	void setTargetTolerance(double x) { targetTolerance = x; }$/;"	f	class:unitRaceSimulation
setTargets	shared/spreadExecSearchAlgorithm.h	/^	virtual void setTargets(graphAbstraction *_aMap, node *s, node *e, reservationProvider *_rp = 0)$/;"	f	class:spreadExecSearchAlgorithm
setTargets	shared/spreadPRAStar.cpp	/^void spreadPRAStar::setTargets(graphAbstraction *_aMap, node *s, node *e, reservationProvider *_rp)$/;"	f	class:spreadPRAStar
setTerrainType	util/graph.cpp	/^void node::setTerrainType(int terrain)$/;"	f	class:node
setTerrainType	util/map.cpp	/^void Map::setTerrainType(long x, long y, tTerrain type, tSplitSide split)$/;"	f	class:Map
setTest	tests/AnnotatedClusterMockFactory.h	/^		void setTest(int current) { currentTest = current; }$/;"	f	class:AnnotatedClusterMockFactory
setTileSet	util/map.cpp	/^void Map::setTileSet(tTileset ts)$/;"	f	class:Map
setTransparentValue	util/mapOverlay.h	/^	void setTransparentValue(double v) { ignoreVal = v; }$/;"	f	class:MapOverlay
setTravelLimit	simulation/unitRaceSimulation.h	/^	void setTravelLimit(double lim) { useTravelLimit = true; travelLimit = lim; }$/;"	f	class:unitRaceSimulation
setTrialLimit	simulation/unitRaceSimulation.h	/^	void setTrialLimit(long maxTrials) { useMaxRounds = true; maxRounds = maxTrials; }$/;"	f	class:unitRaceSimulation
setUnitGroup	simulation/unit.cpp	/^void unit::setUnitGroup(unitGroup *_group)$/;"	f	class:unit
setUp	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::setUp()$/;"	f	class:AnnotatedAStarTest
setUp	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::setUp()$/;"	f	class:AnnotatedClusterAbstractionTest
setUp	tests/AnnotatedClusterFactoryTest.cpp	/^void AnnotatedClusterFactoryTest::setUp()$/;"	f	class:AnnotatedClusterFactoryTest
setUp	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::setUp()$/;"	f	class:AnnotatedClusterTest
setUp	tests/AnnotatedHierarchicalAStarTest.cpp	/^void AnnotatedHierarchicalAStarTest::setUp()$/;"	f	class:AnnotatedHierarchicalAStarTest
setUp	tests/AnnotatedMapAbstractionTest.cpp	/^void AnnotatedMapAbstractionTest::setUp()$/;"	f	class:AnnotatedMapAbstractionTest
setUp	tests/ComplexNumberTest.cpp	/^void ComplexNumberTest::setUp() $/;"	f	class:ComplexNumberTest
setUp	tests/EdgeTest.cpp	/^void EdgeTest::setUp()$/;"	f	class:EdgeTest
setUp	tests/ScenarioManagerTest.cpp	/^void ScenarioManagerTest::setUp()$/;"	f	class:ScenarioManagerTest
setUp	tests/TestNode.cpp	/^void TestNode::setUp()$/;"	f	class:TestNode
setUpParents	abstraction/clusterAbstraction.cpp	/^void clusterAbstraction::setUpParents(graph* g)$/;"	f	class:clusterAbstraction
setUpSearch	shared/hpaStar.cpp	/^void hpaStar::setUpSearch(node* from, node* to)$/;"	f	class:hpaStar
setUseBDPathMax	util/GenericIDAStar.h	/^	void setUseBDPathMax(bool val) { usePathMax = val; }$/;"	f	class:GenericIDAStar
setUseBlocking	simulation/unitSimulation.h	/^	void setUseBlocking(bool val) { blocking = val; }$/;"	f	class:unitSimulation
setUseSameStart	simulation/unitRaceSimulation.h	/^	void setUseSameStart(bool val) { sameStart = val; }$/;"	f	class:unitRaceSimulation
setUseSmoothing	shared/praStar.h	/^	void setUseSmoothing(bool _smoothing) { smoothing = _smoothing; }$/;"	f	class:praStar
setVOrig	abstraction/clusterAbstraction.h	/^	void setVOrig(const int newvorig) { m_vertOrigin = newvorig; }$/;"	f	class:Cluster
setVisibilityRadius	shared/sharedAMapGroup.cpp	/^void sharedAMapGroup::setVisibilityRadius(int _visibility)$/;"	f	class:sharedAMapGroup
setWeight	util/graph.h	/^	void setWeight(double val) { setLabelF(kEdgeWeight, val); }$/;"	f	class:edge
setWidth	abstraction/clusterAbstraction.h	/^	void setWidth(const int newwidth) { m_width = newwidth; }$/;"	f	class:Cluster
setWidth	util/graph.h	/^	void setWidth(double val) { setLabelF(kEdgeWidth, val); }$/;"	f	class:edge
setWidth	util/graph.h	/^  void setWidth(double val) { width = val; }$/;"	f	class:node
setmapAbstractionDisplay	simulation/unitSimulation.cpp	/^void unitSimulation::setmapAbstractionDisplay(int _whichMap)$/;"	f	class:unitSimulation
setupAverageRatio	util/statUtil.cpp	/^void setupAverageRatio(statCollection *stats, char *stat1, char *stat2)$/;"	f
setupDominanceRelationshipTestData	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::setupDominanceRelationshipTestData(int dmCapability, int dmClearance, int dtCapability, int dtClearance)$/;"	f	class:AnnotatedClusterAbstractionTest
setupExceptionThrownTestHelper	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::setupExceptionThrownTestHelper(graph* g, AnnotatedCluster* myac, AnnotatedClusterAbstraction* aca, std::string& errmsg)$/;"	f	class:AnnotatedClusterTest
setupMockClusterExpectationsForBuildClusterTests	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::setupMockClusterExpectationsForBuildClusterTests(AnnotatedClusterMock* acm)$/;"	f	class:AnnotatedClusterAbstractionTest
setupMockClusterExpectationsForBuildEntranceTests	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::setupMockClusterExpectationsForBuildEntranceTests(AnnotatedClusterMock* acm)$/;"	f	class:AnnotatedClusterAbstractionTest
setupNeighbourAnnotations	tests/AnnotatedMapAbstractionTest.cpp	/^void AnnotatedMapAbstractionTest::setupNeighbourAnnotations(int x, int y)$/;"	f	class:AnnotatedMapAbstractionTest
setupSearch	shared/craStar.cpp	/^void craStar::setupSearch(graphAbstraction *aMap,$/;"	f	class:craStar
setupSearch	shared/praStar2.cpp	/^void praStar2::setupSearch(graphAbstraction *aMap,$/;"	f	class:praStar2
setupSearch	shared/spreadPRAStar.cpp	/^void spreadPRAStar::setupSearch(graphAbstraction *_aMap,$/;"	f	class:spreadPRAStar
sg	tests/ScenarioManagerTest.h	/^		AHAScenarioManager* sg;$/;"	m	class:ScenarioManagerTest
shapeSize	driver/common.h	/^	GLfloat shapeSize;$/;"	m	struct:recContext
sharedAMapGroup	shared/sharedAMapGroup.cpp	/^sharedAMapGroup::sharedAMapGroup(mapProvider *mp)$/;"	f	class:sharedAMapGroup
sharedAMapGroup	shared/sharedAMapGroup.h	/^class sharedAMapGroup : public unitGroup, public mapProvider {$/;"	c
showCredits	driver/common.h	/^	bool showCredits;$/;"	m	struct:recContext
showLand	driver/common.h	/^	bool showLand;$/;"	m	struct:recContext
sim	tests/CapabilityUnitTest.h	/^		simulationInfo *sim;$/;"	m	class:CapabilityUnitTest
simulationInfo	simulation/unitSimulation.h	/^class simulationInfo {$/;"	c
size	driver/MAC/HID Support/HID_Utilities.h	/^    long size;								\/\/ size in bits of data return from element$/;"	m	struct:recElement
size	driver/MAC/HID Support/HID_Utilities_External.h	/^    long size;								\/\/ size in bits of data return from element$/;"	m	struct:recElement
size	driver/main.h	/^   CGSize size;$/;"	m	struct:CGRect
size	tests/ExperimentManager.h	/^			int size; \/\/ agent size$/;"	m	class:ExpMgrUtil::TestExperiment
size	util/bitVector.h	/^  int size, true_size;$/;"	m	class:bitVector
size	util/heap.cpp	/^unsigned int heap::size()$/;"	f	class:heap
size	util/heap2.h	/^	unsigned size() { return _elts.size(); }$/;"	f	class:heap2
sizeMultiplier	util/map.h	/^	int sizeMultiplier;$/;"	m	class:Map
skip	shared/praStar2.h	/^  int skip; $/;"	m	class:praStar2
sliders	driver/MAC/HID Support/HID_Utilities.h	/^    long sliders;							\/\/ number of sliders (calculated, not reported by device)$/;"	m	struct:recDevice
sliders	driver/MAC/HID Support/HID_Utilities_External.h	/^    long sliders;							\/\/ number of sliders (calculated, not reported by device)$/;"	m	struct:recDevice
smType	shared/craStar.h	/^	SmoothType smType;$/;"	m	class:craStar
smType	shared/hpaStar.h	/^	SmoothType smType;$/;"	m	class:hpaStar
smoothPath	shared/craStar.cpp	/^path* craStar::smoothPath(graphAbstraction *m,path* p)$/;"	f	class:craStar
smoothPath	shared/hpaStar.cpp	/^path* hpaStar::smoothPath(path* p)$/;"	f	class:hpaStar
smoothPath	shared/praStar.cpp	/^path *praStar::smoothPath(path *p)$/;"	f	class:praStar
smoothSetRectHeight	util/map.cpp	/^void Map::smoothSetRectHeight(long x1, long y1, long x2, long y2, long h, tTerrain type)$/;"	f	class:Map
smoothing	shared/craStar.h	/^	bool smoothing;$/;"	m	class:craStar
smoothing	shared/hpaStar.h	/^	bool smoothing;$/;"	m	class:hpaStar
smoothing	shared/praStar.h	/^	bool smoothing;$/;"	m	class:praStar
snode	tests/ExperimentManager.h	/^			node *snode, *gnode;$/;"	m	class:ExpMgrUtil::TestExperiment
sortEdgeWidths	abstraction/width.cpp	/^void sortEdgeWidths(vector<edge*>* edges)$/;"	f
speed	simulation/unit.h	/^	double speed;$/;"	m	class:unit
sphereDispList	simulation/unit.cpp	/^GLuint unit::sphereDispList = 0;$/;"	m	class:unit	file:
sphereDispList	simulation/unit.h	/^	static GLuint sphereDispList;$/;"	m	class:unit
split	util/map.h	/^	tSplit split;$/;"	m	class:Tile
splitNode	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::splitNode(node *parent, int numGroups)$/;"	f	class:loadedCliqueAbstraction
splitNode	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::splitNode(node *parent, int numGroups)$/;"	f	class:mapCliqueAbstraction
spreadExecSearchAlgorithm	shared/spreadExecSearchAlgorithm.h	/^	spreadExecSearchAlgorithm() { }$/;"	f	class:spreadExecSearchAlgorithm
spreadExecSearchAlgorithm	shared/spreadExecSearchAlgorithm.h	/^class spreadExecSearchAlgorithm : public searchAlgorithm {$/;"	c
spreadPRAStar	shared/spreadPRAStar.cpp	/^spreadPRAStar::spreadPRAStar()$/;"	f	class:spreadPRAStar
spreadPRAStar	shared/spreadPRAStar.h	/^class spreadPRAStar : public spreadExecSearchAlgorithm {$/;"	c
spread_cache	shared/searchUnit.h	/^	path *spread_cache;$/;"	m	class:searchUnit
stamp	util/timer.h	/^	void stamp() {$/;"	f	struct:Timer::CycleCounter
start	shared/aStar.h	/^	node *goal, *start;$/;"	m	class:aStar
start	shared/spreadExecSearchAlgorithm.h	/^	node *start, *end;$/;"	m	class:spreadExecSearchAlgorithm
start	util/GenericAStar.h	/^	uint32_t goal, start;$/;"	m	class:GenericAStar
startChain	shared/spreadPRAStar.h	/^	std::vector<node *> startChain, endChain;$/;"	m	class:spreadPRAStar
startNewTrial	shared/sharedAMapGroup.cpp	/^void sharedAMapGroup::startNewTrial(statCollection *stats)$/;"	f	class:sharedAMapGroup
startNewTrial	simulation/unitGroup.cpp	/^void unitGroup::startNewTrial(statCollection *)$/;"	f	class:unitGroup
startTime	simulation/unitSimulation.h	/^  double startTime;$/;"	m	class:timeStep
startTime	util/timer.h	/^  AbsoluteTime startTime;$/;"	m	class:Timer
startTime	util/timer.h	/^  uint64_t startTime;$/;"	m	class:Timer
startTimer	util/timer.cpp	/^void Timer::startTimer()$/;"	f	class:Timer
startTrackball	driver/trackball.cpp	/^void startTrackball (long x, long y, long originX, long originY, long width, long height)$/;"	f
startTrajRecap	driver/main.h	/^bool startTrajRecap;$/;"	v
startid	aha/AnnotatedClusterAbstraction.h	/^		int startid, goalid;$/;"	m	class:AnnotatedClusterAbstraction
startx	shared/scenarioLoader.h	/^  int startx, starty, goalx, goaly;$/;"	m	class:Experiment
startx	simulation/unitSimulation.h	/^	int startx, starty;$/;"	m	class:unitInfo
startx	tests/ExperimentManager.h	/^			int startx;$/;"	m	class:ExpMgrUtil::TestExperiment
starty	shared/scenarioLoader.h	/^  int startx, starty, goalx, goaly;$/;"	m	class:Experiment
starty	simulation/unitSimulation.h	/^	int startx, starty;$/;"	m	class:unitInfo
starty	tests/ExperimentManager.h	/^			int starty;$/;"	m	class:ExpMgrUtil::TestExperiment
stat	util/statCollection.h	/^class stat {$/;"	c
statCollection	util/statCollection.cpp	/^statCollection::statCollection()$/;"	f	class:statCollection
statCollection	util/statCollection.h	/^class statCollection {$/;"	c
statValue	util/statCollection.h	/^typedef union { double fval; long lval; } statValue;$/;"	t	typeref:union:__anon26
stats	simulation/unitSimulation.h	/^	statCollection stats;$/;"	m	class:unitSimulation
stats	util/statCollection.h	/^	std::vector<stat> stats;$/;"	m	class:statCollection
stayTime	simulation/unit.h	/^		int stayTime;$/;"	m	class:teleportUnit
stdevStatEntries	util/statUtil.cpp	/^double stdevStatEntries(statCollection *stats, const char *category, const char *owner)$/;"	f
stepTime	driver/TextBox.cpp	/^void TextBox::stepTime(double amount)$/;"	f	class:TextBox
stepUnitTime	simulation/unitSimulation.cpp	/^void unitSimulation::stepUnitTime(unitInfo *theUnit)$/;"	f	class:unitSimulation
sterrain	tests/ExperimentManager.h	/^			int sterrain; $/;"	m	class:ExpMgrUtil::TestExperiment
stochasticity	simulation/unitSimulation.h	/^	double stochasticity;$/;"	m	class:unitSimulation
stopOnConvergence	simulation/unitRaceSimulation.h	/^	bool stopOnConvergence;$/;"	m	class:unitRaceSimulation
storage	util/bitVector.h	/^  uint32_t *storage;$/;"	m	class:bitVector
storedType	util/statCollection.h	/^enum storedType { floatStored, longStored };$/;"	g
strRendererName	driver/MAC/macGlCheck.h	/^  char strRendererName [256]; \/\/ name of hardware renderer$/;"	m	struct:__anon15
strRendererVendor	driver/MAC/macGlCheck.h	/^  char strRendererVendor [256]; \/\/ name of hardware renderer vendor$/;"	m	struct:__anon15
strRendererVersion	driver/MAC/macGlCheck.h	/^  char strRendererVersion [256]; \/\/ string rep of hardware renderer version$/;"	m	struct:__anon15
subdivisions	driver/common.h	/^	unsigned long subdivisions;$/;"	m	struct:recContext
submitTextToBuffer	driver/MAC/mac_main.cpp	/^void submitTextToBuffer(const char *val)$/;"	f
submitTextToBuffer	driver/main.cpp	/^void submitTextToBuffer(const char *val)$/;"	f
sumStat	util/statCollection.cpp	/^void statCollection::sumStat(const char *category, const char *owner, double value)$/;"	f	class:statCollection
sumStat	util/statCollection.cpp	/^void statCollection::sumStat(const char *category, const char *owner, long value)$/;"	f	class:statCollection
sumStatEntries	util/statUtil.cpp	/^double sumStatEntries(statCollection *stats, const char *category, const char *owner)$/;"	f
supersetcapability	aha/AHAConstants.h	/^const int supersetcapability = (kGround|kTrees);$/;"	v
surface	driver/common.h	/^	long surface; $/;"	m	struct:recContext
tButtonType	driver/common.h	/^enum tButtonType {$/;"	g
tCorner	util/map.h	/^enum tCorner {$/;"	g
tDirection	simulation/constants.h	/^enum tDirection {$/;"	g
tDisplay	util/map.h	/^enum tDisplay {$/;"	g
tEdge	util/map.h	/^enum tEdge {$/;"	g
tKeyboardModifier	driver/common.h	/^enum tKeyboardModifier {$/;"	g
tMapType	util/map.h	/^enum tMapType {$/;"	g
tMouseEventType	driver/common.h	/^enum tMouseEventType {$/;"	g
tObjectType	simulation/constants.h	/^enum tObjectType {$/;"	g
tSplit	util/map.h	/^enum tSplit {$/;"	g
tSplitSide	util/map.h	/^enum tSplitSide {$/;"	g
tTerrain	util/map.h	/^enum tTerrain {$/;"	g
tTileset	util/map.h	/^enum tTileset {$/;"	g
tUnitOnTargetStatus	simulation/unitRaceSimulation.h	/^enum tUnitOnTargetStatus {$/;"	g
table	util/heap2.h	/^	IndexTable table;$/;"	m	class:heap2
tail	util/path.h	/^	path *tail() { if (next) return next->tail(); return this; }$/;"	f	class:path
target	aha/ScenarioManager.h	/^		int generated, target;$/;"	m	class:TooManyTriesException
target	simulation/unit.h	/^	unit *target;$/;"	m	class:unit
target	tests/CapabilityUnitTest.h	/^		unit* target;$/;"	m	class:CapabilityUnitTest
targetTime	shared/searchUnit.h	/^	double targetTime;$/;"	m	class:searchUnit
targetTolerance	simulation/unitRaceSimulation.h	/^	double targetTolerance;$/;"	m	class:unitRaceSimulation
tearDown	tests/AnnotatedAStarTest.cpp	/^void AnnotatedAStarTest::tearDown()$/;"	f	class:AnnotatedAStarTest
tearDown	tests/AnnotatedClusterAbstractionTest.cpp	/^void AnnotatedClusterAbstractionTest::tearDown()$/;"	f	class:AnnotatedClusterAbstractionTest
tearDown	tests/AnnotatedClusterFactoryTest.cpp	/^void AnnotatedClusterFactoryTest::tearDown()$/;"	f	class:AnnotatedClusterFactoryTest
tearDown	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::tearDown()$/;"	f	class:AnnotatedClusterTest
tearDown	tests/AnnotatedHierarchicalAStarTest.cpp	/^void AnnotatedHierarchicalAStarTest::tearDown()$/;"	f	class:AnnotatedHierarchicalAStarTest
tearDown	tests/AnnotatedMapAbstractionTest.cpp	/^void AnnotatedMapAbstractionTest::tearDown()$/;"	f	class:AnnotatedMapAbstractionTest
tearDown	tests/ComplexNumberTest.cpp	/^void ComplexNumberTest::tearDown()$/;"	f	class:ComplexNumberTest
tearDown	tests/EdgeTest.cpp	/^void EdgeTest::tearDown()$/;"	f	class:EdgeTest
tearDown	tests/ScenarioManagerTest.cpp	/^void ScenarioManagerTest::tearDown()$/;"	f	class:ScenarioManagerTest
tearDown	tests/TestNode.cpp	/^void TestNode::tearDown()$/;"	f	class:TestNode
teleportUnit	simulation/unit.h	/^	teleportUnit(int _x, int _y, int _stayTime)$/;"	f	class:teleportUnit
teleportUnit	simulation/unit.h	/^class teleportUnit : public unit {$/;"	c
temp	abstraction/clusterAbstraction.h	/^  clusterUtil::PathLookupTable temp;$/;"	m	class:clusterAbstraction
terrainBits	util/map.h	/^const int terrainBits = 4;$/;"	v
terrains	tests/TestNode.h	/^	int terrains[3];$/;"	m	class:TestNode
terraintype	util/graph.h	/^  int terraintype;$/;"	m	class:node
testEquality	tests/ComplexNumberTest.cpp	/^void ComplexNumberTest::testEquality()$/;"	f	class:ComplexNumberTest
testHelper	tests/AnnotatedClusterTest.h	/^		exceptionThrownHelper *testHelper;$/;"	m	class:AnnotatedClusterTest
testfile	tests/ScenarioManagerTest.h	/^		std::ifstream testfile;$/;"	m	class:ScenarioManagerTest
testmap	tests/AnnotatedClusterAbstractionTest.h	/^		Map *testmap;$/;"	m	class:AnnotatedClusterAbstractionTest
testmap	tests/AnnotatedMapAbstractionTest.h	/^		Map* testmap;$/;"	m	class:AnnotatedMapAbstractionTest
tests	tests/ExperimentManager.h	/^		static ExpMgrUtil::ExperimentCollection* tests;$/;"	m	class:ExperimentManager
text	driver/TextBox.h	/^	char *text;$/;"	m	class:TextBox
textureUnits	driver/MAC/macGlCheck.h	/^  long textureUnits; \/\/ standard gl path max number of texture units$/;"	m	struct:__anon15
theMovie	driver/MAC/mac_main.cpp	/^Movie theMovie = NULL;$/;"	v
theSourceTrack	driver/MAC/mac_main.cpp	/^Track theSourceTrack = NULL;$/;"	v
think	shared/spreadPRAStar.cpp	/^path *spreadPRAStar::think()$/;"	f	class:spreadPRAStar
think	simulation/unitGroup.h	/^	virtual void think(mapProvider *) { }$/;"	f	class:unitGroup
thinkTime	simulation/unitSimulation.h	/^	double thinkTime, moveDist;$/;"	m	class:unitInfo
tile1	util/map.h	/^	halfTile tile1, tile2;$/;"	m	class:Tile
tile2	util/map.h	/^	halfTile tile1, tile2;$/;"	m	class:Tile
tileOccupied	simulation/unitSimulation.h	/^	inline bool tileOccupied(int x, int y) { return bv->get(y*map_width+x); }$/;"	f	class:unitSimulation
tileSet	util/map.h	/^	tTileset tileSet;$/;"	m	class:Map
time	driver/common.h	/^	AbsoluteTime time;$/;"	m	struct:recContext
timeStep	simulation/unitSimulation.h	/^	timeStep() { x = -1; y = -1; startTime = 0; }$/;"	f	class:timeStep
timeStep	simulation/unitSimulation.h	/^	timeStep(int _x, int _y, double time)$/;"	f	class:timeStep
timeStep	simulation/unitSimulation.h	/^class timeStep {$/;"	c
timer	driver/common.h	/^	EventLoopTimerRef timer;$/;"	m	struct:recContext
timer	simulation/unit.h	/^	int timer;$/;"	m	class:teleportUnit
timerCB	driver/MAC/mac_main.cpp	/^static pascal void timerCB(EventLoopTimerRef inTimer, void* userData)$/;"	f	file:
timerContextCB	driver/MAC/mac_main.cpp	/^static void timerContextCB(pRecContext pContextInfo, WindowRef window)$/;"	f	file:
title	driver/common.h	/^	const char *title;$/;"	m	class:keyboardCallbackData
tl	driver/TextBox.h	/^	point3d tl, br;$/;"	m	class:TextBox
to	tests/TestNode.h	/^	node *from, *to;$/;"	m	class:TestNode
to	util/graph.h	/^	unsigned int from, to;$/;"	m	class:edge
toClusterId	tests/AnnotatedClusterTest.h	/^		int fromx, fromy, tox, toy, capability, clearance, fromClusterId, toClusterId;$/;"	m	class:TestEntrance
toggleDrawAbstraction	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::toggleDrawAbstraction(int which)$/;"	f	class:loadedCliqueAbstraction
toggleDrawAbstraction	abstraction/mapAbstraction.cpp	/^void mapAbstraction::toggleDrawAbstraction(int which)$/;"	f	class:mapAbstraction
toggleNoOpenGLDraw	simulation/unitSimulation.h	/^	void toggleNoOpenGLDraw() { noOpenGLDraw = !noOpenGLDraw; }$/;"	f	class:unitSimulation
tonum	shared/hpaStar.h	/^	node* tonum;$/;"	m	class:hpaStar
top	util/heap2.h	/^	OBJ top() { return _elts[0]; }$/;"	f	class:heap2
topLevel	shared/praStar2.h	/^  int topLevel; \/\/the highest level at which an abstract path is found$/;"	m	class:praStar2
totalElements	driver/MAC/HID Support/HID_Utilities.h	/^    long totalElements;						\/\/ number of total elements (should be total of all elements on device including collections) (calculated, not reported by device)$/;"	m	struct:recDevice
totalElements	driver/MAC/HID Support/HID_Utilities_External.h	/^    long totalElements;						\/\/ number of total elements (should be total of all elements on device including collections) (calculated, not reported by device)$/;"	m	struct:recDevice
tox	tests/AnnotatedClusterTest.h	/^		int fromx, fromy, tox, toy, capability, clearance, fromClusterId, toClusterId;$/;"	m	class:TestEntrance
toy	tests/AnnotatedClusterTest.h	/^		int fromx, fromy, tox, toy, capability, clearance, fromClusterId, toClusterId;$/;"	m	class:TestEntrance
transferGroup	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::transferGroup(int group, node *oldParent, node *newParent)$/;"	f	class:loadedCliqueAbstraction
transferGroup	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::transferGroup(int group, node *oldParent, node *newParent)$/;"	f	class:mapCliqueAbstraction
transport	driver/MAC/HID Support/HID_Utilities.h	/^    Str255 transport;						\/\/ device transport$/;"	m	struct:recDevice
transport	driver/MAC/HID Support/HID_Utilities_External.h	/^    char transport[256];					\/\/ device transport (c string)$/;"	m	struct:recDevice
travelLimit	simulation/unitRaceSimulation.h	/^	double travelLimit;$/;"	m	class:unitRaceSimulation
traversing	aha/AnnotatedAStar.h	/^		edge* traversing() { return e; }$/;"	f	class:AnnotatedAStar
trimPath	shared/craStar.cpp	/^path *craStar::trimPath(path *lastPath, node *origDest)$/;"	f	class:craStar
trimPath	shared/praStar2.cpp	/^path *praStar2::trimPath(path *lastPath, node *origDest)$/;"	f	class:praStar2
trimPath	shared/spreadPRAStar.cpp	/^path *spreadPRAStar::trimPath(path *lastPth, node *origDest)$/;"	f	class:spreadPRAStar
true_size	util/bitVector.h	/^  int size, true_size;$/;"	m	class:bitVector
tryLoadRollingStone	util/map.cpp	/^bool Map::tryLoadRollingStone(FILE *f)$/;"	f	class:Map
tslocation	tests/TestConstants.h	/^const string tslocation = "test.scenario"; \/\/ test scenario file$/;"	v
type	driver/MAC/HID Support/HID_Utilities.h	/^    IOHIDElementType type;					\/\/ the type defined by IOHIDElementType in IOHIDKeys.h$/;"	m	struct:recElement
type	driver/MAC/HID Support/HID_Utilities_External.h	/^    unsigned long type;						\/\/ the type defined by IOHIDElementType in IOHIDKeys.h$/;"	m	struct:recElement
type	util/map.h	/^  tTerrain type;$/;"	m	class:halfTile
uniqueClusterIdCnt	aha/AnnotatedCluster.cpp	/^unsigned AnnotatedCluster::uniqueClusterIdCnt = 0;$/;"	m	class:AnnotatedCluster	file:
uniqueClusterIdCnt	aha/AnnotatedCluster.h	/^		static unsigned int uniqueClusterIdCnt;$/;"	m	class:AnnotatedCluster
uniqueID	util/graph.h	/^  int uniqueID;$/;"	m	class:graph_object
uniqueIDCounter	util/graph.cpp	/^unsigned graph_object::uniqueIDCounter = 0;$/;"	m	class:graph_object	file:
uniqueIDCounter	util/graph.h	/^  static unsigned int uniqueIDCounter;$/;"	m	class:graph_object
unit	simulation/unit.cpp	/^unit::unit(int _x, int _y, float _r, float _g, float _b, unit *_target)$/;"	f	class:unit
unit	simulation/unit.cpp	/^unit::unit(int _x, int _y, int _r, int _g, int _b, unit *_target)$/;"	f	class:unit
unit	simulation/unit.cpp	/^unit::unit(int _x, int _y, unit *_target)$/;"	f	class:unit
unit	simulation/unit.h	/^class unit {$/;"	c
unitExp	driver/MAC/HID Support/HID_Utilities.h	/^    long unitExp;							\/\/ exponent for units (also not used very often)$/;"	m	struct:recElement
unitExp	driver/MAC/HID Support/HID_Utilities_External.h	/^    long unitExp;							\/\/ exponent for units (also not used very often)$/;"	m	struct:recElement
unitGroup	simulation/unitGroup.cpp	/^unitGroup::unitGroup(mapProvider *)$/;"	f	class:unitGroup
unitGroup	simulation/unitGroup.h	/^class unitGroup {$/;"	c
unitGroups	simulation/unitSimulation.h	/^	std::vector<unitGroup *> unitGroups;$/;"	m	class:unitSimulation
unitID	simulation/unit.cpp	/^int unit::unitID = 0;$/;"	m	class:unit	file:
unitID	simulation/unit.h	/^	static int unitID;$/;"	m	class:unit
unitInfo	simulation/unitSimulation.h	/^	unitInfo() :actionHistory(0) {}$/;"	f	class:unitInfo
unitInfo	simulation/unitSimulation.h	/^class unitInfo {$/;"	c
unitInfoCompare	simulation/unitSimulation.h	/^class unitInfoCompare {$/;"	c
unitLayer	driver/common.h	/^	unitSimulation *unitLayer;$/;"	m	struct:recContext
unitOnTarget	simulation/unitRaceSimulation.cpp	/^bool unitRaceSimulation::unitOnTarget(unitInfo *u)$/;"	f	class:unitRaceSimulation
unitOnTargetStatus	simulation/unitRaceSimulation.cpp	/^tUnitOnTargetStatus unitRaceSimulation::unitOnTargetStatus(unitInfo *u)$/;"	f	class:unitRaceSimulation
unitRaceSimulation	simulation/unitRaceSimulation.cpp	/^unitRaceSimulation::unitRaceSimulation(mapAbstraction *m, bool keepStats)$/;"	f	class:unitRaceSimulation
unitRaceSimulation	simulation/unitRaceSimulation.h	/^class unitRaceSimulation : public unitSimulation {$/;"	c
unitSimulation	simulation/unitSimulation.cpp	/^unitSimulation::unitSimulation(mapAbstraction *_aMap, bool keepStats)$/;"	f	class:unitSimulation
unitSimulation	simulation/unitSimulation.h	/^class unitSimulation : public mapProvider, reservationProvider, public simulationInfo {$/;"	c
unitType	simulation/unit.h	/^	tObjectType unitType;$/;"	m	class:unit
units	driver/MAC/HID Support/HID_Utilities.h	/^    long units;								\/\/ units value is reported in (not used very often)$/;"	m	struct:recElement
units	driver/MAC/HID Support/HID_Utilities_External.h	/^    long units;								\/\/ units value is reported in (not used very often)$/;"	m	struct:recElement
units	simulation/unitSimulation.h	/^	std::vector<unitInfo *> units;$/;"	m	class:unitSimulation
unitsMoved	simulation/unitSimulation.h	/^	bool unitsMoved;$/;"	m	class:unitSimulation
updateLocation	shared/patrolUnit.h	/^	void updateLocation(int _x, int _y, bool worked, simulationInfo *)$/;"	f	class:patrolUnit
updateLocation	shared/searchUnit.cpp	/^void searchUnit::updateLocation(int _x, int _y, bool success, simulationInfo *)$/;"	f	class:searchUnit
updateLocation	shared/sharedAMapGroup.cpp	/^void sharedAMapGroup::updateLocation(unit *u, mapProvider *mp, int _x, int _y, bool success, simulationInfo *simInfo)$/;"	f	class:sharedAMapGroup
updateLocation	simulation/unit.cpp	/^void billiardBallUnit::updateLocation(int _x, int _y, bool success, simulationInfo *)$/;"	f	class:billiardBallUnit
updateLocation	simulation/unit.cpp	/^void randomUnit::updateLocation(int _x, int _y, bool success, simulationInfo *)$/;"	f	class:randomUnit
updateLocation	simulation/unit.cpp	/^void rhrUnit::updateLocation(int _x, int _y, bool success, simulationInfo *)$/;"	f	class:rhrUnit
updateLocation	simulation/unit.cpp	/^void teleportUnit::updateLocation(int _x, int _y, bool, simulationInfo *)$/;"	f	class:teleportUnit
updateLocation	simulation/unit.h	/^	virtual void updateLocation(int _x, int _y, bool, simulationInfo *) { x = _x; y = _y; }$/;"	f	class:unit
updateLocation	simulation/unitGroup.cpp	/^void unitGroup::updateLocation(unit *u, mapProvider *, int _x, int _y,$/;"	f	class:unitGroup
updateMap	simulation/unitSimulation.cpp	/^void unitSimulation::updateMap()$/;"	f	class:unitSimulation
updateModelView	driver/MAC/mac_main.cpp	/^void updateModelView(pRecContext pContextInfo)$/;"	f
updateModelView	driver/main.cpp	/^void updateModelView (pRecContext pContextInfo)$/;"	f
updateNextBound	util/GenericIDAStar.cpp	/^void GenericIDAStar::updateNextBound(double currBound, double fCost)$/;"	f	class:GenericIDAStar
updateProjection	driver/MAC/mac_main.cpp	/^void updateProjection(pRecContext pContextInfo)$/;"	f
updateProjection	driver/main.cpp	/^void updateProjection(pRecContext pContextInfo)$/;"	f
updateRotation	driver/MAC/mac_main.cpp	/^void updateRotation(double deltaTime, GLfloat * fRot, GLfloat * fVel, GLfloat * fAccel, GLfloat * objectRotation )$/;"	f
updateWeight	shared/aStar.cpp	/^void aStar::updateWeight(node *currOpenNode, node *neighbor, edge *e)$/;"	f	class:aStar
updateWeight	util/GenericAStar.cpp	/^void GenericAStar::updateWeight(uint32_t currOpenNode, uint32_t neighbor)$/;"	f	class:GenericAStar
updated	util/map.h	/^  bool updated;$/;"	m	class:Map
updatemapAbstraction	simulation/unitSimulation.cpp	/^bool unitSimulation::updatemapAbstraction()$/;"	f	class:unitSimulation
usage	driver/MAC/HID Support/HID_Config_Utilities.h	/^    long usage;$/;"	m	struct:recSaveHID
usage	driver/MAC/HID Support/HID_Utilities.h	/^    long usage;								\/\/ usage page from IOUSBHID Parser.h which defines general usage$/;"	m	struct:recDevice
usage	driver/MAC/HID Support/HID_Utilities.h	/^    long usage;								\/\/ usage within above page from IOUSBHIDParser.h which defines specific usage$/;"	m	struct:recElement
usage	driver/MAC/HID Support/HID_Utilities_External.h	/^    long usage;								\/\/ usage page from IOUSBHID Parser.h which defines general usage$/;"	m	struct:recDevice
usage	driver/MAC/HID Support/HID_Utilities_External.h	/^    long usage;								\/\/ usage within above page from IOUSBHIDParser.h which defines specific usage$/;"	m	struct:recElement
usage	driver/MAC/HID Support/HID_Utilities_External.h	/^    long usage;$/;"	m	struct:recSaveHID
usageE	driver/MAC/HID Support/HID_Config_Utilities.h	/^    long usageE;$/;"	m	struct:recSaveHID
usageE	driver/MAC/HID Support/HID_Utilities_External.h	/^    long usageE;$/;"	m	struct:recSaveHID
usagePage	driver/MAC/HID Support/HID_Config_Utilities.h	/^    long usagePage;$/;"	m	struct:recSaveHID
usagePage	driver/MAC/HID Support/HID_Utilities.h	/^    long usagePage;							\/\/ usage page from IOUSBHIDParser.h which defines general usage$/;"	m	struct:recElement
usagePage	driver/MAC/HID Support/HID_Utilities.h	/^    long usagePage;							\/\/ usage within above page from IOUSBHID Parser.h which defines specific usage$/;"	m	struct:recDevice
usagePage	driver/MAC/HID Support/HID_Utilities_External.h	/^    long usagePage;							\/\/ usage page from IOUSBHIDParser.h which defines general usage$/;"	m	struct:recElement
usagePage	driver/MAC/HID Support/HID_Utilities_External.h	/^    long usagePage;							\/\/ usage within above page from IOUSBHID Parser.h which defines specific usage$/;"	m	struct:recDevice
usagePage	driver/MAC/HID Support/HID_Utilities_External.h	/^    long usagePage;$/;"	m	struct:recSaveHID
usagePageE	driver/MAC/HID Support/HID_Config_Utilities.h	/^    long usagePageE;$/;"	m	struct:recSaveHID
usagePageE	driver/MAC/HID Support/HID_Utilities_External.h	/^    long usagePageE;$/;"	m	struct:recSaveHID
useCorridor	aha/AnnotatedAStar.h	/^		bool useCorridor;$/;"	m	class:AbstractAnnotatedAStar
useMaxRounds	simulation/unitRaceSimulation.h	/^	bool useMaxRounds;$/;"	m	class:unitRaceSimulation
usePathMax	util/GenericIDAStar.h	/^	bool usePathMax;$/;"	m	class:GenericIDAStar
useTravelLimit	simulation/unitRaceSimulation.h	/^	bool useTravelLimit;$/;"	m	class:unitRaceSimulation
userData	driver/common.h	/^	void *userData;$/;"	m	class:joystickCallbackData
userMax	driver/MAC/HID Support/HID_Utilities.h	/^    long userMax;							$/;"	m	struct:recElement
userMax	driver/MAC/HID Support/HID_Utilities_External.h	/^    long userMax;							$/;"	m	struct:recElement
userMin	driver/MAC/HID Support/HID_Utilities.h	/^    long userMin; 							\/\/ user set value to scale to (scale call)$/;"	m	struct:recElement
userMin	driver/MAC/HID Support/HID_Utilities_External.h	/^    long userMin; 							\/\/ user set value to scale to (scale call)$/;"	m	struct:recElement
validateMapAbstraction	aha/AnnotatedCluster.cpp	/^void AnnotatedCluster::validateMapAbstraction(AnnotatedClusterAbstraction* aca) throw(ValidateMapAbstractionException)$/;"	f	class:AnnotatedCluster
validateMapAbstractionThrowsExceptionGivenNullParameter	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::validateMapAbstractionThrowsExceptionGivenNullParameter()$/;"	f	class:AnnotatedClusterTest
validateTransitionEndpoints	aha/AnnotatedCluster.cpp	/^void AnnotatedCluster::validateTransitionEndpoints(node* from, node* to) throw(ValidateTransitionEndpointsException)$/;"	f	class:AnnotatedCluster
validateTransitionEndpointsShouldThrowExceptionWhenParameterNodesAreNull	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::validateTransitionEndpointsShouldThrowExceptionWhenParameterNodesAreNull()$/;"	f	class:AnnotatedClusterTest
validateTransitionEndpointsShouldThrowExceptionWhenParameterNodesHaveIdenticalCoordinates	tests/AnnotatedClusterTest.cpp	/^void AnnotatedClusterTest::validateTransitionEndpointsShouldThrowExceptionWhenParameterNodesHaveIdenticalCoordinates()$/;"	f	class:AnnotatedClusterTest
validterrains	aha/AHAConstants.h	/^const int validterrains[NUMTERRAINS] = {kGround, kTrees};$/;"	v
value	driver/MAC/HID Support/HIDSupport.h	/^    long value;$/;"	m	struct:actionRec
value	util/statCollection.h	/^	statValue value;$/;"	m	class:stat
values	util/mapOverlay.h	/^	std::vector<double> values;$/;"	m	class:MapOverlay
vendorID	driver/MAC/HID Support/HID_Config_Utilities.h	/^    long vendorID;$/;"	m	struct:recSaveHID
vendorID	driver/MAC/HID Support/HID_Utilities.h	/^    long vendorID;							\/\/ id for device vendor, unique across all devices$/;"	m	struct:recDevice
vendorID	driver/MAC/HID Support/HID_Utilities_External.h	/^    long vendorID;							\/\/ id for device vendor, unique across all devices$/;"	m	struct:recDevice
vendorID	driver/MAC/HID Support/HID_Utilities_External.h	/^    long vendorID;$/;"	m	struct:recSaveHID
verbose	abstraction/clusterAbstraction.cpp	/^const static int verbose = 0;$/;"	v	file:
verbose	abstraction/graphAbstraction.cpp	/^const int verbose = kQuiet;\/\/kRepairGraph;$/;"	v
verbose	abstraction/loadedCliqueAbstraction.cpp	/^const int verbose = kMiscMessages;\/\/kMiscMessages;\/\/kRepairGraph;$/;"	v
verbose	abstraction/mapCliqueAbstraction.cpp	/^const int verbose = kQuiet;\/\/kMiscMessages;\/\/kRepairGraph;$/;"	v
verbose	aha/AnnotatedAStar.h	/^		bool verbose;$/;"	m	class:AbstractAnnotatedAStar
verbose	driver/common.cpp	/^static bool const verbose = false;$/;"	v	file:
verbose	shared/aStar.cpp	/^static const bool verbose = false;$/;"	v	file:
verbose	shared/aStar3.cpp	/^static const int verbose = 0;$/;"	v	file:
verbose	shared/corridorAStar.cpp	/^const static int verbose = 0;$/;"	v	file:
verbose	shared/craStar.cpp	/^static const int verbose = 0;$/;"	v	file:
verbose	shared/hpaStar.cpp	/^const static int verbose = 0;$/;"	v	file:
verbose	shared/praStar.cpp	/^const bool verbose = false;$/;"	v
verbose	shared/praStar2.cpp	/^static const int verbose = 0;$/;"	v	file:
verbose	shared/searchAlgorithm.cpp	/^static const int verbose = 0;$/;"	v	file:
verbose	shared/searchUnit.cpp	/^static const bool verbose = false;$/;"	v	file:
verbose	shared/spreadPRAStar.cpp	/^static const int verbose = 0;$/;"	v	file:
verbose	simulation/unitRaceSimulation.cpp	/^static const bool verbose = false;$/;"	v	file:
verbose	simulation/unitSimulation.cpp	/^const bool verbose = false;$/;"	v
verbose	util/GenericAStar.cpp	/^static const bool verbose = false;$/;"	v	file:
verbose	util/map.cpp	/^static const bool verbose = false; $/;"	v	file:
verify	tests/AnnotatedClusterAbstractionMock.h	/^#undef verify$/;"	d
verify	tests/AnnotatedClusterMock.h	/^#undef verify$/;"	d
verifyGraph	util/graph.cpp	/^bool graph::verifyGraph() const$/;"	f	class:graph
verifyHierarchy	abstraction/MapLineAbstraction.cpp	/^void MapLineAbstraction::verifyHierarchy()$/;"	f	class:MapLineAbstraction
verifyHierarchy	abstraction/NodeLimitAbstraction.cpp	/^void NodeLimitAbstraction::verifyHierarchy()$/;"	f	class:NodeLimitAbstraction
verifyHierarchy	abstraction/clusterAbstraction.h	/^  void verifyHierarchy() {}$/;"	f	class:clusterAbstraction
verifyHierarchy	abstraction/loadedCliqueAbstraction.cpp	/^void loadedCliqueAbstraction::verifyHierarchy()$/;"	f	class:loadedCliqueAbstraction
verifyHierarchy	abstraction/mapCliqueAbstraction.cpp	/^void mapCliqueAbstraction::verifyHierarchy()$/;"	f	class:mapCliqueAbstraction
verifyHierarchy	abstraction/mapFlatAbstraction.cpp	/^void mapFlatAbstraction::verifyHierarchy()$/;"	f	class:mapFlatAbstraction
verifyHierarchy	abstraction/mapQuadTreeAbstraction.cpp	/^void mapQuadTreeAbstraction::verifyHierarchy()$/;"	f	class:mapQuadTreeAbstraction
verifyHierarchy	abstraction/radiusAbstraction.cpp	/^void radiusAbstraction::verifyHierarchy()$/;"	f	class:radiusAbstraction
verifyHierarchy	aha/AnnotatedMapAbstraction.h	/^		void verifyHierarchy() {}$/;"	f	class:AnnotatedMapAbstraction
verifyHierarchy	tests/AnnotatedMapAbstractionMock.h	/^		void verifyHierarchy() {}$/;"	f	class:AnnotatedMapAbstractionMock
version	driver/MAC/HID Support/HID_Utilities.h	/^    long version;							\/\/ version of product$/;"	m	struct:recDevice
version	driver/MAC/HID Support/HID_Utilities_External.h	/^    long version;							\/\/ version of product$/;"	m	struct:recDevice
viewDir	driver/common.h	/^	recVec viewDir; \/\/ View direction vector$/;"	m	struct:__anon7
viewHeight	driver/common.h	/^	GLint viewWidth,viewHeight; \/\/ current window\/screen height and width$/;"	m	struct:__anon7
viewOriginX	driver/common.h	/^	GLfloat viewOriginX, viewOriginY; \/\/ always 0 $/;"	m	struct:__anon7
viewOriginY	driver/common.h	/^	GLfloat viewOriginX, viewOriginY; \/\/ always 0 $/;"	m	struct:__anon7
viewPos	driver/common.h	/^	recVec viewPos; \/\/ View position$/;"	m	struct:__anon7
viewTime	simulation/unitSimulation.h	/^	double currTime, viewTime;$/;"	m	class:unitSimulation
viewUp	driver/common.h	/^	recVec viewUp; \/\/ View up direction$/;"	m	struct:__anon7
viewWidth	driver/common.h	/^	GLint viewWidth,viewHeight; \/\/ current window\/screen height and width$/;"	m	struct:__anon7
visRadius	shared/sharedAMapGroup.h	/^	int visRadius;$/;"	m	class:sharedAMapGroup
wh	shared/aStar3.h	/^	double wh;$/;"	m	class:aStarOld
what	aha/AnnotatedCluster.cpp	/^const char* AnnotatedClusterAbstractionIsNullException::what() const throw()$/;"	f	class:AnnotatedClusterAbstractionIsNullException
what	aha/AnnotatedCluster.cpp	/^const char* AnnotatedClusterException::what() const throw()$/;"	f	class:AnnotatedClusterException
what	aha/AnnotatedCluster.cpp	/^const char* CannotBuildEntranceToSelfException::what() const throw() { return message->c_str(); }$/;"	f	class:CannotBuildEntranceToSelfException
what	aha/AnnotatedCluster.cpp	/^const char* InvalidClusterDimensionsException::what() const throw()$/;"	f	class:InvalidClusterDimensionsException
what	aha/AnnotatedCluster.cpp	/^const char* InvalidClusterOriginCoordinatesException::what() const throw()$/;"	f	class:InvalidClusterOriginCoordinatesException
what	aha/AnnotatedCluster.h	/^		virtual const char* what() const throw() { return "tried to build an entrance using a parameter node which is already part of an abstract graph"; }$/;"	f	class:CannotBuildEntranceFromAbstractNodeException
what	aha/AnnotatedCluster.h	/^		virtual const char* what() const throw() { return "tried to build an entrance using two non-adjacent nodes"; }	$/;"	f	class:EntranceNodesAreNotAdjacentException
what	aha/AnnotatedCluster.h	/^		virtual const char* what() const throw() { return "tried to build an entrance with weight <= 0"; }	$/;"	f	class:InvalidTransitionWeightException
what	aha/AnnotatedCluster.h	/^		virtual const char* what() const throw() { return errmsg; }	$/;"	f	class:ValidateTransitionEndpointsException
what	aha/AnnotatedCluster.h	/^	virtual const char* what() const throw() { return "Map abstraction parameter cannot be null"; }$/;"	f	class:ValidateMapAbstractionException
what	aha/AnnotatedCluster.h	/^	virtual const char* what() const throw() { return "clearance parameter <=0 or otherwise inconsistent with entrance endpoints"; }	$/;"	f	class:InvalidClearanceParameterException
what	aha/AnnotatedCluster.h	/^	virtual const char* what() const throw() { return "entrance's capability clearance parameter does not match endpoint node clearance"; }	$/;"	f	class:EntranceNodeIsNotTraversable
what	aha/AnnotatedCluster.h	/^	virtual const char* what() const throw() { return "no agent exists with specified capability"; }	$/;"	f	class:InvalidCapabilityParameterException
what	aha/AnnotatedCluster.h	/^	virtual const char* what() const throw() { return "tried to build an entrance using two nodes from the same cluster"; }$/;"	f	class:EntranceNodeIsHardObstacleException
what	aha/AnnotatedClusterAbstraction.h	/^	const char* what() const throw() { return "found a node with kAbstractionlLevel label > 0 when it should be == 0"; }$/;"	f	class:NodeHasNonZeroAbstractionLevelException
what	aha/ScenarioManager.h	/^		const char* what() const throw()$/;"	f	class:TooManyTriesException
wheels	driver/MAC/HID Support/HID_Utilities.h	/^    long wheels;							\/\/ number of wheels (calculated, not reported by device)$/;"	m	struct:recDevice
wheels	driver/MAC/HID Support/HID_Utilities_External.h	/^    long wheels;							\/\/ number of wheels (calculated, not reported by device)$/;"	m	struct:recDevice
which_map	simulation/unitSimulation.h	/^	int which_map;						\/\/ the number of the group to display info for$/;"	m	class:unitSimulation
width	aha/AnnotatedCluster.h	/^		int width, height, xorigin, yorigin;$/;"	m	class:InvalidClusterDimensionsException
width	driver/MAC/mac_main.cpp	/^	int width, height;$/;"	m	class:movieFrame	file:
width	driver/main.h	/^   float width;$/;"	m	struct:CGSize
width	util/graph.h	/^  double width;$/;"	m	class:node
width	util/map.h	/^	int width, height;$/;"	m	class:Map
widthBFS	abstraction/graphAbstraction.cpp	/^int graphAbstraction::widthBFS(node *child, node *parent)$/;"	f	class:graphAbstraction
windowEDMUPP	driver/common.h	/^	DMExtendedNotificationUPP  windowEDMUPP;$/;"	m	struct:recContext
windowEvtHndlr	driver/MAC/mac_main.cpp	/^static pascal OSStatus windowEvtHndlr (EventHandlerCallRef myHandler, EventRef event, void* userData)$/;"	f	file:
worldRotation	driver/common.h	/^	GLfloat worldRotation [4];$/;"	m	struct:recContext
wrapping	driver/MAC/HID Support/HID_Utilities.h	/^    Boolean wrapping;						\/\/ does element wrap around (one value higher than max is min)$/;"	m	struct:recElement
wrapping	driver/MAC/HID Support/HID_Utilities_External.h	/^    unsigned char wrapping;						\/\/ does element wrap around (one value higher than max is min)$/;"	m	struct:recElement
writeScenarioFile	aha/ScenarioManager.cpp	/^void AHAScenarioManager::writeScenarioFile(const char* filelocation)$/;"	f	class:AHAScenarioManager
x	driver/main.h	/^   float x;$/;"	m	struct:CGPoint
x	simulation/unit.h	/^	int x, y;$/;"	m	class:unit
x	simulation/unitSimulation.h	/^  int x, y;$/;"	m	class:timeStep
x	tests/CapabilityUnitTest.h	/^		int x, y;$/;"	m	class:CapabilityUnitTest
x	util/glUtil.h	/^  GLdouble x,y,z;$/;"	m	class:recVec
x	util/glUtil.h	/^  GLfloat x, y, z;$/;"	m	class:point3d
xorigin	aha/AnnotatedCluster.h	/^		int width, height, xorigin, yorigin;$/;"	m	class:InvalidClusterDimensionsException
xorigin	aha/AnnotatedCluster.h	/^		int xorigin, yorigin;$/;"	m	class:InvalidClusterOriginCoordinatesException
xyRatio	driver/common.h	/^	unsigned long xyRatio;$/;"	m	struct:recContext
y	driver/main.h	/^   float y;$/;"	m	struct:CGPoint
y	simulation/unit.h	/^	int x, y;$/;"	m	class:unit
y	simulation/unitSimulation.h	/^  int x, y;$/;"	m	class:timeStep
y	tests/CapabilityUnitTest.h	/^		int x, y;$/;"	m	class:CapabilityUnitTest
y	util/glUtil.h	/^  GLdouble x,y,z;$/;"	m	class:recVec
y	util/glUtil.h	/^  GLfloat x, y, z;$/;"	m	class:point3d
yorigin	aha/AnnotatedCluster.h	/^		int width, height, xorigin, yorigin;$/;"	m	class:InvalidClusterDimensionsException
yorigin	aha/AnnotatedCluster.h	/^		int xorigin, yorigin;$/;"	m	class:InvalidClusterOriginCoordinatesException
z	util/glUtil.h	/^  GLdouble x,y,z;$/;"	m	class:recVec
z	util/glUtil.h	/^  GLfloat x, y, z;$/;"	m	class:point3d
~AHAExperiment	aha/ScenarioManager.h	/^		virtual ~AHAExperiment() { }$/;"	f	class:AHAExperiment
~AbstractAnnotatedMapAbstraction	aha/AnnotatedMapAbstraction.h	/^		virtual ~AbstractAnnotatedMapAbstraction() { delete searchalg; }$/;"	f	class:AbstractAnnotatedMapAbstraction
~AbstractScenarioManager	aha/ScenarioManager.cpp	/^AbstractScenarioManager::~AbstractScenarioManager()$/;"	f	class:AbstractScenarioManager
~AbstractionSearchEnvironment	abstraction/AbstractionSearchEnvironment.h	/^	~AbstractionSearchEnvironment() {}$/;"	f	class:AbstractionSearchEnvironment
~AnnotatedClusterAbstraction	aha/AnnotatedClusterAbstraction.cpp	/^AnnotatedClusterAbstraction::~AnnotatedClusterAbstraction()$/;"	f	class:AnnotatedClusterAbstraction
~AnnotatedClusterAbstractionMock	tests/AnnotatedClusterAbstractionMock.h	/^		~AnnotatedClusterAbstractionMock()$/;"	f	class:AnnotatedClusterAbstractionMock
~AnnotatedClusterFactory	aha/AnnotatedClusterFactory.h	/^		virtual ~AnnotatedClusterFactory() { }$/;"	f	class:AnnotatedClusterFactory
~AnnotatedMapAbstractionMock	tests/AnnotatedMapAbstractionMock.h	/^		~AnnotatedMapAbstractionMock() {}$/;"	f	class:AnnotatedMapAbstractionMock
~CapabilityUnit	aha/CapabilityUnit.h	/^		virtual ~CapabilityUnit() { }$/;"	f	class:CapabilityUnit
~Cluster	abstraction/clusterAbstraction.cpp	/^Cluster::~Cluster()$/;"	f	class:Cluster
~EntranceException	aha/AnnotatedCluster.h	/^		virtual ~EntranceException() throw() { if(message)  delete message; } $/;"	f	class:EntranceException
~Experiment	shared/scenarioLoader.h	/^  virtual ~Experiment() { }$/;"	f	class:Experiment
~ExperimentManager	tests/ExperimentManager.cpp	/^ExperimentManager::~ExperimentManager()$/;"	f	class:ExperimentManager
~GenericAStar	util/GenericAStar.h	/^	virtual ~GenericAStar() {}$/;"	f	class:GenericAStar
~GenericIDAStar	util/GenericIDAStar.h	/^	virtual ~GenericIDAStar() {}$/;"	f	class:GenericIDAStar
~GraphSearchEnvironment	util/SearchEnvironment.h	/^	~GraphSearchEnvironment() {}$/;"	f	class:GraphSearchEnvironment
~IAnnotatedClusterFactory	aha/AnnotatedClusterFactory.h	/^		virtual ~IAnnotatedClusterFactory() { }$/;"	f	class:IAnnotatedClusterFactory
~Map	util/map.cpp	/^Map::~Map()$/;"	f	class:Map
~MapLineAbstraction	abstraction/MapLineAbstraction.cpp	/^MapLineAbstraction::~MapLineAbstraction()$/;"	f	class:MapLineAbstraction
~MapSearchEnvironment	util/SearchEnvironment.h	/^	~MapSearchEnvironment() {}$/;"	f	class:MapSearchEnvironment
~NodeLimitAbstraction	abstraction/NodeLimitAbstraction.cpp	/^NodeLimitAbstraction::~NodeLimitAbstraction()$/;"	f	class:NodeLimitAbstraction
~SearchEnvironment	util/SearchEnvironment.h	/^	virtual ~SearchEnvironment() {}$/;"	f	class:SearchEnvironment
~TestExperiment	tests/ExperimentManager.cpp	/^ExpMgrUtil::TestExperiment::~TestExperiment()$/;"	f	class:ExpMgrUtil::TestExperiment
~TextBox	driver/TextBox.cpp	/^TextBox::~TextBox()$/;"	f	class:TextBox
~Timer	util/timer.h	/^	~Timer(){}$/;"	f	class:Timer
~aStar	shared/aStar.h	/^	virtual ~aStar() {}$/;"	f	class:aStar
~bitVector	util/bitVector.cpp	/^bitVector::~bitVector()$/;"	f	class:bitVector
~clusterAbstraction	abstraction/clusterAbstraction.cpp	/^clusterAbstraction::~clusterAbstraction()$/;"	f	class:clusterAbstraction
~corridorAStar	shared/corridorAStar.h	/^	virtual ~corridorAStar() {}$/;"	f	class:corridorAStar
~craStar	shared/craStar.h	/^	virtual ~craStar() {}$/;"	f	class:craStar
~graph	util/graph.cpp	/^graph::~graph()$/;"	f	class:graph
~graphAbstraction	abstraction/graphAbstraction.cpp	/^graphAbstraction::~graphAbstraction()$/;"	f	class:graphAbstraction
~graph_object	util/graph.h	/^  virtual ~graph_object() {}$/;"	f	class:graph_object
~heap	util/heap.cpp	/^heap::~heap()$/;"	f	class:heap
~heap2	util/heap2.h	/^heap2<OBJ, HashKey, EqKey, CmpKey>::~heap2()$/;"	f	class:heap2
~hpaStar	shared/hpaStar.h	/^	virtual ~hpaStar(){}$/;"	f	class:hpaStar
~loadedCliqueAbstraction	abstraction/loadedCliqueAbstraction.cpp	/^loadedCliqueAbstraction::~loadedCliqueAbstraction()$/;"	f	class:loadedCliqueAbstraction
~mapAbstraction	abstraction/mapAbstraction.cpp	/^mapAbstraction::~mapAbstraction()$/;"	f	class:mapAbstraction
~mapCliqueAbstraction	abstraction/mapCliqueAbstraction.cpp	/^mapCliqueAbstraction::~mapCliqueAbstraction()$/;"	f	class:mapCliqueAbstraction
~mapFlatAbstraction	abstraction/mapFlatAbstraction.cpp	/^mapFlatAbstraction::~mapFlatAbstraction()$/;"	f	class:mapFlatAbstraction
~mapProvider	abstraction/mapProvider.h	/^	virtual ~mapProvider() {};$/;"	f	class:mapProvider
~mapQuadTreeAbstraction	abstraction/mapQuadTreeAbstraction.cpp	/^mapQuadTreeAbstraction::~mapQuadTreeAbstraction()$/;"	f	class:mapQuadTreeAbstraction
~movieFrame	driver/MAC/mac_main.cpp	/^	~movieFrame() { DisposePtr(image); }$/;"	f	class:movieFrame
~path	util/path.h	/^  ~path() { if (next != NULL) delete next; }$/;"	f	class:path
~praStar	shared/praStar.h	/^	virtual ~praStar() {}$/;"	f	class:praStar
~praStar2	shared/praStar2.h	/^	virtual ~praStar2() {}$/;"	f	class:praStar2
~praStarUnit	shared/praStarUnit.h	/^	~praStarUnit() { delete cache; }$/;"	f	class:praStarUnit
~radiusAbstraction	abstraction/radiusAbstraction.cpp	/^radiusAbstraction::~radiusAbstraction()$/;"	f	class:radiusAbstraction
~reservationProvider	simulation/reservationProvider.h	/^	virtual ~reservationProvider() {};$/;"	f	class:reservationProvider
~searchAlgorithm	shared/searchAlgorithm.h	/^	virtual ~searchAlgorithm() {}$/;"	f	class:searchAlgorithm
~searchUnit	shared/searchUnit.cpp	/^searchUnit::~searchUnit()$/;"	f	class:searchUnit
~sharedAMapGroup	shared/sharedAMapGroup.cpp	/^sharedAMapGroup::~sharedAMapGroup()$/;"	f	class:sharedAMapGroup
~simulationInfo	simulation/unitSimulation.h	/^	virtual ~simulationInfo() {};$/;"	f	class:simulationInfo
~spreadPRAStar	shared/spreadPRAStar.h	/^	virtual ~spreadPRAStar() {}$/;"	f	class:spreadPRAStar
~statCollection	util/statCollection.cpp	/^statCollection::~statCollection()$/;"	f	class:statCollection
~unit	simulation/unit.cpp	/^unit::~unit()$/;"	f	class:unit
~unitGroup	simulation/unitGroup.h	/^	virtual ~unitGroup() {}$/;"	f	class:unitGroup
~unitRaceSimulation	simulation/unitRaceSimulation.cpp	/^unitRaceSimulation::~unitRaceSimulation()$/;"	f	class:unitRaceSimulation
~unitSimulation	simulation/unitSimulation.cpp	/^unitSimulation::~unitSimulation()$/;"	f	class:unitSimulation
